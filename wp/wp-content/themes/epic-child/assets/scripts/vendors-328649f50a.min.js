(window.webpackJsonp = window.webpackJsonp || []).push([
    [0],
    [function(t, e, n) {
        ! function(t) {
            "use strict";
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : +t
            }), "name" in Function.prototype == 0 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(t) {
                if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), n = 1; n < arguments.length; n++) {
                    var i = arguments[n];
                    if (void 0 !== i && null !== i)
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
                }
                return e
            });
            var e = 0,
                n = 1,
                i = 2,
                r = 1,
                o = 2,
                a = 3,
                s = 0,
                c = 1,
                l = 2,
                h = 0,
                u = 1,
                p = 2,
                d = 0,
                f = 1,
                m = 2,
                v = 3,
                g = 4,
                y = 5,
                _ = 100,
                x = 101,
                b = 102,
                w = 103,
                M = 104,
                T = 200,
                E = 201,
                S = 202,
                A = 203,
                P = 204,
                L = 205,
                R = 206,
                C = 207,
                O = 208,
                I = 209,
                D = 210,
                N = 0,
                B = 1,
                H = 2,
                F = 3,
                k = 4,
                U = 5,
                z = 6,
                G = 7,
                j = 0,
                V = 1,
                W = 2,
                X = 0,
                q = 1,
                Y = 2,
                Z = 3,
                J = 4,
                K = 5,
                Q = 301,
                $ = 302,
                tt = 303,
                et = 304,
                nt = 305,
                it = 306,
                rt = 307,
                ot = 1e3,
                at = 1001,
                st = 1002,
                ct = 1003,
                lt = 1004,
                ht = 1005,
                ut = 1006,
                pt = 1007,
                dt = 1008,
                ft = 1009,
                mt = 1010,
                vt = 1011,
                gt = 1012,
                yt = 1013,
                _t = 1014,
                xt = 1015,
                bt = 1016,
                wt = 1017,
                Mt = 1018,
                Tt = 1019,
                Et = 1020,
                St = 1021,
                At = 1022,
                Pt = 1023,
                Lt = 1024,
                Rt = 1025,
                Ct = Pt,
                Ot = 1026,
                It = 1027,
                Dt = 1028,
                Nt = 33776,
                Bt = 33777,
                Ht = 33778,
                Ft = 33779,
                kt = 35840,
                Ut = 35841,
                zt = 35842,
                Gt = 35843,
                jt = 36196,
                Vt = 37808,
                Wt = 37809,
                Xt = 37810,
                qt = 37811,
                Yt = 37812,
                Zt = 37813,
                Jt = 37814,
                Kt = 37815,
                Qt = 37816,
                $t = 37817,
                te = 37818,
                ee = 37819,
                ne = 37820,
                ie = 37821,
                re = 2201,
                oe = 2400,
                ae = 0,
                se = 1,
                ce = 2,
                le = 3e3,
                he = 3001,
                ue = 3007,
                pe = 3002,
                de = 3003,
                fe = 3004,
                me = 3005,
                ve = 3006,
                ge = 3200,
                ye = 3201,
                _e = 0,
                xe = 1,
                be = 7680,
                we = 519;

            function Me() {}
            Object.assign(Me.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners,
                            i = n[t];
                        if (void 0 !== i) {
                            var r = i.indexOf(e); - 1 !== r && i.splice(r, 1)
                        }
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners,
                            n = e[t.type];
                        if (void 0 !== n) {
                            t.target = this;
                            for (var i = n.slice(0), r = 0, o = i.length; r < o; r++) i[r].call(this, t)
                        }
                    }
                }
            });
            for (var Te = [], Ee = 0; Ee < 256; Ee++) Te[Ee] = (Ee < 16 ? "0" : "") + Ee.toString(16);
            var Se = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    var t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0,
                        r = Te[255 & t] + Te[t >> 8 & 255] + Te[t >> 16 & 255] + Te[t >> 24 & 255] + "-" + Te[255 & e] + Te[e >> 8 & 255] + "-" + Te[e >> 16 & 15 | 64] + Te[e >> 24 & 255] + "-" + Te[63 & n | 128] + Te[n >> 8 & 255] + "-" + Te[n >> 16 & 255] + Te[n >> 24 & 255] + Te[255 & i] + Te[i >> 8 & 255] + Te[i >> 16 & 255] + Te[i >> 24 & 255];
                    return r.toUpperCase()
                },
                clamp: function(t, e, n) {
                    return Math.max(e, Math.min(n, t))
                },
                euclideanModulo: function(t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function(t, e, n, i, r) {
                    return i + (t - e) * (r - i) / (n - e)
                },
                lerp: function(t, e, n) {
                    return (1 - n) * t + n * e
                },
                smoothstep: function(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                },
                smootherstep: function(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                },
                randInt: function(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function(t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function(t) {
                    return t * (.5 - Math.random())
                },
                degToRad: function(t) {
                    return t * Se.DEG2RAD
                },
                radToDeg: function(t) {
                    return t * Se.RAD2DEG
                },
                isPowerOfTwo: function(t) {
                    return 0 == (t & t - 1) && 0 !== t
                },
                ceilPowerOfTwo: function(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }
            };

            function Ae(t, e) {
                this.x = t || 0, this.y = e || 0
            }

            function Pe(t, e, n, i) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
            }
            Object.defineProperties(Ae.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }
            }), Object.assign(Ae.prototype, {
                isVector2: !0,
                set: function(t, e) {
                    return this.x = t, this.y = e, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                },
                multiply: function(t) {
                    return this.x *= t.x, this.y *= t.y, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = t.elements;
                    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                },
                clampScalar: function(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                },
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var t = Math.atan2(this.y, this.x);
                    return t < 0 && (t += 2 * Math.PI), t
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                },
                rotateAround: function(t, e) {
                    var n = Math.cos(e),
                        i = Math.sin(e),
                        r = this.x - t.x,
                        o = this.y - t.y;
                    return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this
                }
            }), Object.assign(Pe, {
                slerp: function(t, e, n, i) {
                    return n.copy(t).slerp(e, i)
                },
                slerpFlat: function(t, e, n, i, r, o, a) {
                    var s = n[i + 0],
                        c = n[i + 1],
                        l = n[i + 2],
                        h = n[i + 3],
                        u = r[o + 0],
                        p = r[o + 1],
                        d = r[o + 2],
                        f = r[o + 3];
                    if (h !== f || s !== u || c !== p || l !== d) {
                        var m = 1 - a,
                            v = s * u + c * p + l * d + h * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var _ = Math.sqrt(y),
                                x = Math.atan2(_, v * g);
                            m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                        }
                        var b = a * g;
                        if (s = s * m + u * b, c = c * m + p * b, l = l * m + d * b, h = h * m + f * b, m === 1 - a) {
                            var w = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
                            s *= w, c *= w, l *= w, h *= w
                        }
                    }
                    t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h
                }
            }), Object.defineProperties(Pe.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this._onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this._onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this._onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(t) {
                        this._w = t, this._onChangeCallback()
                    }
                }
            }), Object.assign(Pe.prototype, {
                isQuaternion: !0,
                set: function(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                },
                setFromEuler: function(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = t._x,
                        i = t._y,
                        r = t._z,
                        o = t.order,
                        a = Math.cos,
                        s = Math.sin,
                        c = a(n / 2),
                        l = a(i / 2),
                        h = a(r / 2),
                        u = s(n / 2),
                        p = s(i / 2),
                        d = s(r / 2);
                    return "XYZ" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d) : "YXZ" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d) : "ZXY" === o ? (this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d) : "ZYX" === o ? (this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d) : "YZX" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h - u * p * d) : "XZY" === o && (this._x = u * l * h - c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h + u * p * d), !1 !== e && this._onChangeCallback(), this
                },
                setFromAxisAngle: function(t, e) {
                    var n = e / 2,
                        i = Math.sin(n);
                    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                },
                setFromRotationMatrix: function(t) {
                    var e, n = t.elements,
                        i = n[0],
                        r = n[4],
                        o = n[8],
                        a = n[1],
                        s = n[5],
                        c = n[9],
                        l = n[2],
                        h = n[6],
                        u = n[10],
                        p = i + s + u;
                    return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (h - c) * e, this._y = (o - l) * e, this._z = (a - r) * e) : i > s && i > u ? (e = 2 * Math.sqrt(1 + i - s - u), this._w = (h - c) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (o + l) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - i - u), this._w = (o - l) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (c + h) / e) : (e = 2 * Math.sqrt(1 + u - i - s), this._w = (a - r) / e, this._x = (o + l) / e, this._y = (c + h) / e, this._z = .25 * e), this._onChangeCallback(), this
                },
                setFromUnitVectors: function(t, e) {
                    var n = t.dot(e) + 1;
                    return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                },
                angleTo: function(t) {
                    return 2 * Math.acos(Math.abs(Se.clamp(this.dot(t), -1, 1)))
                },
                rotateTowards: function(t, e) {
                    var n = this.angleTo(t);
                    if (0 === n) return this;
                    var i = Math.min(1, e / n);
                    return this.slerp(t, i), this
                },
                inverse: function() {
                    return this.conjugate()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                },
                dot: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyQuaternions(t, this)
                },
                multiplyQuaternions: function(t, e) {
                    var n = t._x,
                        i = t._y,
                        r = t._z,
                        o = t._w,
                        a = e._x,
                        s = e._y,
                        c = e._z,
                        l = e._w;
                    return this._x = n * l + o * a + i * c - r * s, this._y = i * l + o * s + r * a - n * c, this._z = r * l + o * c + n * s - i * a, this._w = o * l - n * a - i * s - r * c, this._onChangeCallback(), this
                },
                slerp: function(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    var n = this._x,
                        i = this._y,
                        r = this._z,
                        o = this._w,
                        a = o * t._w + n * t._x + i * t._y + r * t._z;
                    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
                    var s = 1 - a * a;
                    if (s <= Number.EPSILON) {
                        var c = 1 - e;
                        return this._w = c * o + e * this._w, this._x = c * n + e * this._x, this._y = c * i + e * this._y, this._z = c * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    var l = Math.sqrt(s),
                        h = Math.atan2(l, a),
                        u = Math.sin((1 - e) * h) / l,
                        p = Math.sin(e * h) / l;
                    return this._w = o * u + this._w * p, this._x = n * u + this._x * p, this._y = i * u + this._y * p, this._z = r * u + this._z * p, this._onChangeCallback(), this
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                },
                _onChange: function(t) {
                    return this._onChangeCallback = t, this
                },
                _onChangeCallback: function() {}
            });
            var Le = new Ce,
                Re = new Pe;

            function Ce(t, e, n) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0
            }
            Object.assign(Ce.prototype, {
                isVector3: !0,
                set: function(t, e, n) {
                    return this.x = t, this.y = e, this.z = n, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                },
                multiplyVectors: function(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                },
                applyEuler: function(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Re.setFromEuler(t))
                },
                applyAxisAngle: function(t, e) {
                    return this.applyQuaternion(Re.setFromAxisAngle(t, e))
                },
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements,
                        o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this
                },
                applyQuaternion: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.x,
                        o = t.y,
                        a = t.z,
                        s = t.w,
                        c = s * e + o * i - a * n,
                        l = s * n + a * e - r * i,
                        h = s * i + r * n - o * e,
                        u = -r * e - o * n - a * i;
                    return this.x = c * s + u * -r + l * -a - h * -o, this.y = l * s + u * -o + h * -r - c * -a, this.z = h * s + u * -a + c * -o - l * -r, this
                },
                project: function(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                },
                unproject: function(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                },
                transformDirection: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                },
                clampScalar: function(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                },
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                cross: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                },
                crossVectors: function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        o = e.x,
                        a = e.y,
                        s = e.z;
                    return this.x = i * s - r * a, this.y = r * o - n * s, this.z = n * a - i * o, this
                },
                projectOnVector: function(t) {
                    var e = t.dot(this) / t.lengthSq();
                    return this.copy(t).multiplyScalar(e)
                },
                projectOnPlane: function(t) {
                    return Le.copy(this).projectOnVector(t), this.sub(Le)
                },
                reflect: function(t) {
                    return this.sub(Le.copy(t).multiplyScalar(2 * this.dot(t)))
                },
                angleTo: function(t) {
                    var e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    0 === e && console.error("THREE.Vector3: angleTo() can't handle zero length vectors.");
                    var n = this.dot(t) / e;
                    return Math.acos(Se.clamp(n, -1, 1))
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y,
                        i = this.z - t.z;
                    return e * e + n * n + i * i
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                },
                setFromSpherical: function(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                },
                setFromSphericalCoords: function(t, e, n) {
                    var i = Math.sin(e) * t;
                    return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
                },
                setFromCylindrical: function(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                },
                setFromCylindricalCoords: function(t, e, n) {
                    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                },
                setFromMatrixPosition: function(t) {
                    var e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                },
                setFromMatrixScale: function(t) {
                    var e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        i = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = n, this.z = i, this
                },
                setFromMatrixColumn: function(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
            });
            var Oe, Ie = new Ce;

            function De() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.assign(De.prototype, {
                isMatrix3: !0,
                set: function(t, e, n, i, r, o, a, s, c) {
                    var l = this.elements;
                    return l[0] = t, l[1] = i, l[2] = a, l[3] = e, l[4] = r, l[5] = s, l[6] = n, l[7] = o, l[8] = c, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                },
                setFromMatrix4: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                },
                applyToBufferAttribute: function(t) {
                    for (var e = 0, n = t.count; e < n; e++) Ie.x = t.getX(e), Ie.y = t.getY(e), Ie.z = t.getZ(e), Ie.applyMatrix3(this), t.setXYZ(e, Ie.x, Ie.y, Ie.z);
                    return t
                },
                multiply: function(t) {
                    return this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        o = n[0],
                        a = n[3],
                        s = n[6],
                        c = n[1],
                        l = n[4],
                        h = n[7],
                        u = n[2],
                        p = n[5],
                        d = n[8],
                        f = i[0],
                        m = i[3],
                        v = i[6],
                        g = i[1],
                        y = i[4],
                        _ = i[7],
                        x = i[2],
                        b = i[5],
                        w = i[8];
                    return r[0] = o * f + a * g + s * x, r[3] = o * m + a * y + s * b, r[6] = o * v + a * _ + s * w, r[1] = c * f + l * g + h * x, r[4] = c * m + l * y + h * b, r[7] = c * v + l * _ + h * w, r[2] = u * f + p * g + d * x, r[5] = u * m + p * y + d * b, r[8] = u * v + p * _ + d * w, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                },
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        o = t[4],
                        a = t[5],
                        s = t[6],
                        c = t[7],
                        l = t[8];
                    return e * o * l - e * a * c - n * r * l + n * a * s + i * r * c - i * o * s
                },
                getInverse: function(t, e) {
                    t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = t.elements,
                        i = this.elements,
                        r = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4],
                        l = n[5],
                        h = n[6],
                        u = n[7],
                        p = n[8],
                        d = p * c - l * u,
                        f = l * h - p * s,
                        m = u * s - c * h,
                        v = r * d + o * f + a * m;
                    if (0 === v) {
                        var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(g);
                        return console.warn(g), this.identity()
                    }
                    var y = 1 / v;
                    return i[0] = d * y, i[1] = (a * u - p * o) * y, i[2] = (l * o - a * c) * y, i[3] = f * y, i[4] = (p * r - a * h) * y, i[5] = (a * s - l * r) * y, i[6] = m * y, i[7] = (o * h - u * r) * y, i[8] = (c * r - o * s) * y, this
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                },
                getNormalMatrix: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                },
                transposeIntoArray: function(t) {
                    var e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                },
                setUvTransform: function(t, e, n, i, r, o, a) {
                    var s = Math.cos(r),
                        c = Math.sin(r);
                    this.set(n * s, n * c, -n * (s * o + c * a) + o + t, -i * c, i * s, -i * (-c * o + s * a) + a + e, 0, 0, 1)
                },
                scale: function(t, e) {
                    var n = this.elements;
                    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t),
                        i = this.elements,
                        r = i[0],
                        o = i[3],
                        a = i[6],
                        s = i[1],
                        c = i[4],
                        l = i[7];
                    return i[0] = e * r + n * s, i[3] = e * o + n * c, i[6] = e * a + n * l, i[1] = -n * r + e * s, i[4] = -n * o + e * c, i[7] = -n * a + e * l, this
                },
                translate: function(t, e) {
                    var n = this.elements;
                    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                }
            });
            var Ne = {
                    getDataURL: function(t) {
                        var e;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === Oe && (Oe = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Oe.width = t.width, Oe.height = t.height;
                            var n = Oe.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Oe
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }
                },
                Be = 0;

            function He(t, e, n, i, r, o, a, s, c, l) {
                Object.defineProperty(this, "id", {
                    value: Be++
                }), this.uuid = Se.generateUUID(), this.name = "", this.image = void 0 !== t ? t : He.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : He.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : at, this.wrapT = void 0 !== i ? i : at, this.magFilter = void 0 !== r ? r : ut, this.minFilter = void 0 !== o ? o : dt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Pt, this.type = void 0 !== s ? s : ft, this.offset = new Ae(0, 0), this.repeat = new Ae(1, 1), this.center = new Ae(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new De, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : le, this.version = 0, this.onUpdate = null
            }

            function Fe(t, e, n, i) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
            }

            function ke(t, e, n) {
                this.width = t, this.height = e, this.scissor = new Fe(0, 0, t, e), this.scissorTest = !1, this.viewport = new Fe(0, 0, t, e), n = n || {}, this.texture = new He(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ut, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function Ue(t, e, n) {
                ke.call(this, t, e, n), this.samples = 4
            }
            He.DEFAULT_IMAGE = void 0, He.DEFAULT_MAPPING = 300, He.prototype = Object.assign(Object.create(Me.prototype), {
                constructor: He,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        var i = this.image;
                        if (void 0 === i.uuid && (i.uuid = Se.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                            var r;
                            if (Array.isArray(i)) {
                                r = [];
                                for (var o = 0, a = i.length; o < a; o++) r.push(Ne.getDataURL(i[o]))
                            } else r = Ne.getDataURL(i);
                            t.images[i.uuid] = {
                                uuid: i.uuid,
                                url: r
                            }
                        }
                        n.image = i.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case ot:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case at:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case st:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case ot:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case at:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case st:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(He.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.defineProperties(Fe.prototype, {
                width: {
                    get: function() {
                        return this.z
                    },
                    set: function(t) {
                        this.z = t
                    }
                },
                height: {
                    get: function() {
                        return this.w
                    },
                    set: function(t) {
                        this.w = t
                    }
                }
            }), Object.assign(Fe.prototype, {
                isVector4: !0,
                set: function(t, e, n, i) {
                    return this.x = t, this.y = e, this.z = n, this.w = i, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setW: function(t) {
                    return this.w = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        o = t.elements;
                    return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                setAxisAngleFromQuaternion: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                },
                setAxisAngleFromRotationMatrix: function(t) {
                    var e, n, i, r, o = t.elements,
                        a = o[0],
                        s = o[4],
                        c = o[8],
                        l = o[1],
                        h = o[5],
                        u = o[9],
                        p = o[2],
                        d = o[6],
                        f = o[10];
                    if (Math.abs(s - l) < .01 && Math.abs(c - p) < .01 && Math.abs(u - d) < .01) {
                        if (Math.abs(s + l) < .1 && Math.abs(c + p) < .1 && Math.abs(u + d) < .1 && Math.abs(a + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        var m = (a + 1) / 2,
                            v = (h + 1) / 2,
                            g = (f + 1) / 2,
                            y = (s + l) / 4,
                            _ = (c + p) / 4,
                            x = (u + d) / 4;
                        return m > v && m > g ? m < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(m), i = y / n, r = _ / n) : v > g ? v < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(v), n = y / i, r = x / i) : g < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(g), n = _ / r, i = x / r), this.set(n, i, r, e), this
                    }
                    var b = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (l - s) * (l - s));
                    return Math.abs(b) < .001 && (b = 1), this.x = (d - u) / b, this.y = (c - p) / b, this.z = (l - s) / b, this.w = Math.acos((a + h + f - 1) / 2), this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                },
                clampScalar: function(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                },
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
            }), ke.prototype = Object.assign(Object.create(Me.prototype), {
                constructor: ke,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Ue.prototype = Object.assign(Object.create(ke.prototype), {
                constructor: Ue,
                isWebGLMultisampleRenderTarget: !0,
                copy: function(t) {
                    return ke.prototype.copy.call(this, t), this.samples = t.samples, this
                }
            });
            var ze = new Ce,
                Ge = new Ye,
                je = new Ce(0, 0, 0),
                Ve = new Ce(1, 1, 1),
                We = new Ce,
                Xe = new Ce,
                qe = new Ce;

            function Ye() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.assign(Ye.prototype, {
                isMatrix4: !0,
                set: function(t, e, n, i, r, o, a, s, c, l, h, u, p, d, f, m) {
                    var v = this.elements;
                    return v[0] = t, v[4] = e, v[8] = n, v[12] = i, v[1] = r, v[5] = o, v[9] = a, v[13] = s, v[2] = c, v[6] = l, v[10] = h, v[14] = u, v[3] = p, v[7] = d, v[11] = f, v[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new Ye).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                },
                copyPosition: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                },
                extractBasis: function(t, e, n) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function(t) {
                    var e = this.elements,
                        n = t.elements,
                        i = 1 / ze.setFromMatrixColumn(t, 0).length(),
                        r = 1 / ze.setFromMatrixColumn(t, 1).length(),
                        o = 1 / ze.setFromMatrixColumn(t, 2).length();
                    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                makeRotationFromEuler: function(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z,
                        o = Math.cos(n),
                        a = Math.sin(n),
                        s = Math.cos(i),
                        c = Math.sin(i),
                        l = Math.cos(r),
                        h = Math.sin(r);
                    if ("XYZ" === t.order) {
                        var u = o * l,
                            p = o * h,
                            d = a * l,
                            f = a * h;
                        e[0] = s * l, e[4] = -s * h, e[8] = c, e[1] = p + d * c, e[5] = u - f * c, e[9] = -a * s, e[2] = f - u * c, e[6] = d + p * c, e[10] = o * s
                    } else if ("YXZ" === t.order) {
                        var m = s * l,
                            v = s * h,
                            g = c * l,
                            y = c * h;
                        e[0] = m + y * a, e[4] = g * a - v, e[8] = o * c, e[1] = o * h, e[5] = o * l, e[9] = -a, e[2] = v * a - g, e[6] = y + m * a, e[10] = o * s
                    } else if ("ZXY" === t.order) {
                        var m = s * l,
                            v = s * h,
                            g = c * l,
                            y = c * h;
                        e[0] = m - y * a, e[4] = -o * h, e[8] = g + v * a, e[1] = v + g * a, e[5] = o * l, e[9] = y - m * a, e[2] = -o * c, e[6] = a, e[10] = o * s
                    } else if ("ZYX" === t.order) {
                        var u = o * l,
                            p = o * h,
                            d = a * l,
                            f = a * h;
                        e[0] = s * l, e[4] = d * c - p, e[8] = u * c + f, e[1] = s * h, e[5] = f * c + u, e[9] = p * c - d, e[2] = -c, e[6] = a * s, e[10] = o * s
                    } else if ("YZX" === t.order) {
                        var _ = o * s,
                            x = o * c,
                            b = a * s,
                            w = a * c;
                        e[0] = s * l, e[4] = w - _ * h, e[8] = b * h + x, e[1] = h, e[5] = o * l, e[9] = -a * l, e[2] = -c * l, e[6] = x * h + b, e[10] = _ - w * h
                    } else if ("XZY" === t.order) {
                        var _ = o * s,
                            x = o * c,
                            b = a * s,
                            w = a * c;
                        e[0] = s * l, e[4] = -h, e[8] = c * l, e[1] = _ * h + w, e[5] = o * l, e[9] = x * h - b, e[2] = b * h - x, e[6] = a * l, e[10] = w * h + _
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                makeRotationFromQuaternion: function(t) {
                    return this.compose(je, t, Ve)
                },
                lookAt: function(t, e, n) {
                    var i = this.elements;
                    return qe.subVectors(t, e), 0 === qe.lengthSq() && (qe.z = 1), qe.normalize(), We.crossVectors(n, qe), 0 === We.lengthSq() && (1 === Math.abs(n.z) ? qe.x += 1e-4 : qe.z += 1e-4, qe.normalize(), We.crossVectors(n, qe)), We.normalize(), Xe.crossVectors(qe, We), i[0] = We.x, i[4] = Xe.x, i[8] = qe.x, i[1] = We.y, i[5] = Xe.y, i[9] = qe.y, i[2] = We.z, i[6] = Xe.z, i[10] = qe.z, this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        o = n[0],
                        a = n[4],
                        s = n[8],
                        c = n[12],
                        l = n[1],
                        h = n[5],
                        u = n[9],
                        p = n[13],
                        d = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        _ = n[11],
                        x = n[15],
                        b = i[0],
                        w = i[4],
                        M = i[8],
                        T = i[12],
                        E = i[1],
                        S = i[5],
                        A = i[9],
                        P = i[13],
                        L = i[2],
                        R = i[6],
                        C = i[10],
                        O = i[14],
                        I = i[3],
                        D = i[7],
                        N = i[11],
                        B = i[15];
                    return r[0] = o * b + a * E + s * L + c * I, r[4] = o * w + a * S + s * R + c * D, r[8] = o * M + a * A + s * C + c * N, r[12] = o * T + a * P + s * O + c * B, r[1] = l * b + h * E + u * L + p * I, r[5] = l * w + h * S + u * R + p * D, r[9] = l * M + h * A + u * C + p * N, r[13] = l * T + h * P + u * O + p * B, r[2] = d * b + f * E + m * L + v * I, r[6] = d * w + f * S + m * R + v * D, r[10] = d * M + f * A + m * C + v * N, r[14] = d * T + f * P + m * O + v * B, r[3] = g * b + y * E + _ * L + x * I, r[7] = g * w + y * S + _ * R + x * D, r[11] = g * M + y * A + _ * C + x * N, r[15] = g * T + y * P + _ * O + x * B, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                },
                applyToBufferAttribute: function(t) {
                    for (var e = 0, n = t.count; e < n; e++) ze.x = t.getX(e), ze.y = t.getY(e), ze.z = t.getZ(e), ze.applyMatrix4(this), t.setXYZ(e, ze.x, ze.y, ze.z);
                    return t
                },
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[4],
                        i = t[8],
                        r = t[12],
                        o = t[1],
                        a = t[5],
                        s = t[9],
                        c = t[13],
                        l = t[2],
                        h = t[6],
                        u = t[10],
                        p = t[14],
                        d = t[3],
                        f = t[7],
                        m = t[11],
                        v = t[15];
                    return d * (+r * s * h - i * c * h - r * a * u + n * c * u + i * a * p - n * s * p) + f * (+e * s * p - e * c * u + r * o * u - i * o * p + i * c * l - r * s * l) + m * (+e * c * h - e * a * p - r * o * h + n * o * p + r * a * l - n * c * l) + v * (-i * a * l - e * s * h + e * a * u + i * o * h - n * o * u + n * s * l)
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                },
                setPosition: function(t, e, n) {
                    var i = this.elements;
                    return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
                },
                getInverse: function(t, e) {
                    var n = this.elements,
                        i = t.elements,
                        r = i[0],
                        o = i[1],
                        a = i[2],
                        s = i[3],
                        c = i[4],
                        l = i[5],
                        h = i[6],
                        u = i[7],
                        p = i[8],
                        d = i[9],
                        f = i[10],
                        m = i[11],
                        v = i[12],
                        g = i[13],
                        y = i[14],
                        _ = i[15],
                        x = d * y * u - g * f * u + g * h * m - l * y * m - d * h * _ + l * f * _,
                        b = v * f * u - p * y * u - v * h * m + c * y * m + p * h * _ - c * f * _,
                        w = p * g * u - v * d * u + v * l * m - c * g * m - p * l * _ + c * d * _,
                        M = v * d * h - p * g * h - v * l * f + c * g * f + p * l * y - c * d * y,
                        T = r * x + o * b + a * w + s * M;
                    if (0 === T) {
                        var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(E);
                        return console.warn(E), this.identity()
                    }
                    var S = 1 / T;
                    return n[0] = x * S, n[1] = (g * f * s - d * y * s - g * a * m + o * y * m + d * a * _ - o * f * _) * S, n[2] = (l * y * s - g * h * s + g * a * u - o * y * u - l * a * _ + o * h * _) * S, n[3] = (d * h * s - l * f * s - d * a * u + o * f * u + l * a * m - o * h * m) * S, n[4] = b * S, n[5] = (p * y * s - v * f * s + v * a * m - r * y * m - p * a * _ + r * f * _) * S, n[6] = (v * h * s - c * y * s - v * a * u + r * y * u + c * a * _ - r * h * _) * S, n[7] = (c * f * s - p * h * s + p * a * u - r * f * u - c * a * m + r * h * m) * S, n[8] = w * S, n[9] = (v * d * s - p * g * s - v * o * m + r * g * m + p * o * _ - r * d * _) * S, n[10] = (c * g * s - v * l * s + v * o * u - r * g * u - c * o * _ + r * l * _) * S, n[11] = (p * l * s - c * d * s - p * o * u + r * d * u + c * o * m - r * l * m) * S, n[12] = M * S, n[13] = (p * g * a - v * d * a + v * o * f - r * g * f - p * o * y + r * d * y) * S, n[14] = (v * l * a - c * g * a - v * o * h + r * g * h + c * o * y - r * l * y) * S, n[15] = (c * d * a - p * l * a + p * o * h - r * d * h - c * o * f + r * l * f) * S, this
                },
                scale: function(t) {
                    var e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z;
                    return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                },
                getMaxScaleOnAxis: function() {
                    var t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, i))
                },
                makeTranslation: function(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(t, e) {
                    var n = Math.cos(e),
                        i = Math.sin(e),
                        r = 1 - n,
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = r * o,
                        l = r * a;
                    return this.set(c * o + n, c * a - i * s, c * s + i * a, 0, c * a + i * s, l * a + n, l * s - i * o, 0, c * s - i * a, l * s + i * o, r * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function(t, e, n) {
                    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(t, e, n) {
                    var i = this.elements,
                        r = e._x,
                        o = e._y,
                        a = e._z,
                        s = e._w,
                        c = r + r,
                        l = o + o,
                        h = a + a,
                        u = r * c,
                        p = r * l,
                        d = r * h,
                        f = o * l,
                        m = o * h,
                        v = a * h,
                        g = s * c,
                        y = s * l,
                        _ = s * h,
                        x = n.x,
                        b = n.y,
                        w = n.z;
                    return i[0] = (1 - (f + v)) * x, i[1] = (p + _) * x, i[2] = (d - y) * x, i[3] = 0, i[4] = (p - _) * b, i[5] = (1 - (u + v)) * b, i[6] = (m + g) * b, i[7] = 0, i[8] = (d + y) * w, i[9] = (m - g) * w, i[10] = (1 - (u + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                },
                decompose: function(t, e, n) {
                    var i = this.elements,
                        r = ze.set(i[0], i[1], i[2]).length(),
                        o = ze.set(i[4], i[5], i[6]).length(),
                        a = ze.set(i[8], i[9], i[10]).length(),
                        s = this.determinant();
                    s < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Ge.copy(this);
                    var c = 1 / r,
                        l = 1 / o,
                        h = 1 / a;
                    return Ge.elements[0] *= c, Ge.elements[1] *= c, Ge.elements[2] *= c, Ge.elements[4] *= l, Ge.elements[5] *= l, Ge.elements[6] *= l, Ge.elements[8] *= h, Ge.elements[9] *= h, Ge.elements[10] *= h, e.setFromRotationMatrix(Ge), n.x = r, n.y = o, n.z = a, this
                },
                makePerspective: function(t, e, n, i, r, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var a = this.elements,
                        s = 2 * r / (e - t),
                        c = 2 * r / (n - i),
                        l = (e + t) / (e - t),
                        h = (n + i) / (n - i),
                        u = -(o + r) / (o - r),
                        p = -2 * o * r / (o - r);
                    return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makeOrthographic: function(t, e, n, i, r, o) {
                    var a = this.elements,
                        s = 1 / (e - t),
                        c = 1 / (n - i),
                        l = 1 / (o - r),
                        h = (e + t) * s,
                        u = (n + i) * c,
                        p = (o + r) * l;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                }
            });
            var Ze = new Ye,
                Je = new Pe;

            function Ke(t, e, n, i) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || Ke.DefaultOrder
            }

            function Qe() {
                this.mask = 1
            }
            Ke.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Ke.DefaultOrder = "XYZ", Object.defineProperties(Ke.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this._onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this._onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this._onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(t) {
                        this._order = t, this._onChangeCallback()
                    }
                }
            }), Object.assign(Ke.prototype, {
                isEuler: !0,
                set: function(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                },
                setFromRotationMatrix: function(t, e, n) {
                    var i = Se.clamp,
                        r = t.elements,
                        o = r[0],
                        a = r[4],
                        s = r[8],
                        c = r[1],
                        l = r[5],
                        h = r[9],
                        u = r[2],
                        p = r[6],
                        d = r[10];
                    return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === e ? (this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math.asin(-i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-h, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== n && this._onChangeCallback(), this
                },
                setFromQuaternion: function(t, e, n) {
                    return Ze.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Ze, e, n)
                },
                setFromVector3: function(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                },
                reorder: function(t) {
                    return Je.setFromEuler(this), this.setFromQuaternion(Je, t)
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                },
                fromArray: function(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                },
                toVector3: function(t) {
                    return t ? t.set(this._x, this._y, this._z) : new Ce(this._x, this._y, this._z)
                },
                _onChange: function(t) {
                    return this._onChangeCallback = t, this
                },
                _onChangeCallback: function() {}
            }), Object.assign(Qe.prototype, {
                set: function(t) {
                    this.mask = 1 << t | 0
                },
                enable: function(t) {
                    this.mask |= 1 << t | 0
                },
                enableAll: function() {
                    this.mask = -1
                },
                toggle: function(t) {
                    this.mask ^= 1 << t | 0
                },
                disable: function(t) {
                    this.mask &= ~(1 << t | 0)
                },
                disableAll: function() {
                    this.mask = 0
                },
                test: function(t) {
                    return 0 != (this.mask & t.mask)
                }
            });
            var $e = 0,
                tn = new Ce,
                en = new Pe,
                nn = new Ye,
                rn = new Ce,
                on = new Ce,
                an = new Ce,
                sn = new Pe,
                cn = new Ce(1, 0, 0),
                ln = new Ce(0, 1, 0),
                hn = new Ce(0, 0, 1),
                un = {
                    type: "added"
                },
                pn = {
                    type: "removed"
                };

            function dn() {
                Object.defineProperty(this, "id", {
                    value: $e++
                }), this.uuid = Se.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = dn.DefaultUp.clone();
                var t = new Ce,
                    e = new Ke,
                    n = new Pe,
                    i = new Ce(1, 1, 1);
                e._onChange(function() {
                    n.setFromEuler(e, !1)
                }), n._onChange(function() {
                    e.setFromQuaternion(n, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Ye
                    },
                    normalMatrix: {
                        value: new De
                    }
                }), this.matrix = new Ye, this.matrixWorld = new Ye, this.matrixAutoUpdate = dn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Qe, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }

            function fn() {
                dn.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            dn.DefaultUp = new Ce(0, 1, 0), dn.DefaultMatrixAutoUpdate = !0, dn.prototype = Object.assign(Object.create(Me.prototype), {
                constructor: dn,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function(t, e) {
                    return en.setFromAxisAngle(t, e), this.quaternion.multiply(en), this
                },
                rotateOnWorldAxis: function(t, e) {
                    return en.setFromAxisAngle(t, e), this.quaternion.premultiply(en), this
                },
                rotateX: function(t) {
                    return this.rotateOnAxis(cn, t)
                },
                rotateY: function(t) {
                    return this.rotateOnAxis(ln, t)
                },
                rotateZ: function(t) {
                    return this.rotateOnAxis(hn, t)
                },
                translateOnAxis: function(t, e) {
                    return tn.copy(t).applyQuaternion(this.quaternion), this.position.add(tn.multiplyScalar(e)), this
                },
                translateX: function(t) {
                    return this.translateOnAxis(cn, t)
                },
                translateY: function(t) {
                    return this.translateOnAxis(ln, t)
                },
                translateZ: function(t) {
                    return this.translateOnAxis(hn, t)
                },
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function(t) {
                    return t.applyMatrix4(nn.getInverse(this.matrixWorld))
                },
                lookAt: function(t, e, n) {
                    t.isVector3 ? rn.copy(t) : rn.set(t, e, n);
                    var i = this.parent;
                    this.updateWorldMatrix(!0, !1), on.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? nn.lookAt(on, rn, this.up) : nn.lookAt(rn, on, this.up), this.quaternion.setFromRotationMatrix(nn), i && (nn.extractRotation(i.matrixWorld), en.setFromRotationMatrix(nn), this.quaternion.premultiply(en.inverse()))
                },
                add: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(un)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    var n = this.children.indexOf(t);
                    return -1 !== n && (t.parent = null, this.children.splice(n, 1), t.dispatchEvent(pn)), this
                },
                attach: function(t) {
                    return this.updateWorldMatrix(!0, !1), nn.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), nn.multiply(t.parent.matrixWorld)), t.applyMatrix(nn), t.updateWorldMatrix(!1, !1), this.add(t), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (var n = 0, i = this.children.length; n < i; n++) {
                        var r = this.children[n],
                            o = r.getObjectByProperty(t, e);
                        if (void 0 !== o) return o
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Ce), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new Pe), this.updateMatrixWorld(!0), this.matrixWorld.decompose(on, t, an), t
                },
                getWorldScale: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new Ce), this.updateMatrixWorld(!0), this.matrixWorld.decompose(on, sn, t), t
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Ce), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 !== this.visible) {
                        t(this);
                        for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    var n = this.parent;
                    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                        for (var i = this.children, r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0)
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t,
                        n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var i = {};

                    function r(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== ae && (i.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(t.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, c = a.length; s < c; s++) {
                                    var l = a[s];
                                    r(t.shapes, l)
                                } else r(t.shapes, a)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            for (var h = [], s = 0, c = this.material.length; s < c; s++) h.push(r(t.materials, this.material[s]));
                            i.material = h
                        } else i.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (var s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(t).object)
                    }
                    if (e) {
                        var u = m(t.geometries),
                            p = m(t.materials),
                            d = m(t.textures),
                            f = m(t.images),
                            a = m(t.shapes);
                        u.length > 0 && (n.geometries = u), p.length > 0 && (n.materials = p), d.length > 0 && (n.textures = d), f.length > 0 && (n.images = f), a.length > 0 && (n.shapes = a)
                    }
                    return n.object = i, n;

                    function m(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (var n = 0; n < t.children.length; n++) {
                            var i = t.children[n];
                            this.add(i.clone())
                        }
                    return this
                }
            }), fn.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: fn,
                isScene: !0,
                copy: function(t, e) {
                    return dn.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                },
                toJSON: function(t) {
                    var e = dn.prototype.toJSON.call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var mn = [new Ce, new Ce, new Ce, new Ce, new Ce, new Ce, new Ce, new Ce],
                vn = new Ce,
                gn = new Ce,
                yn = new Ce,
                _n = new Ce,
                xn = new Ce,
                bn = new Ce,
                wn = new Ce,
                Mn = new Ce,
                Tn = new Ce,
                En = new Ce,
                Sn = new Ce;

            function An(t, e) {
                this.min = void 0 !== t ? t : new Ce(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ce(-1 / 0, -1 / 0, -1 / 0)
            }

            function Pn(t, e, n, i, r) {
                var o, a;
                for (o = 0, a = t.length - 3; o <= a; o += 3) {
                    Sn.fromArray(t, o);
                    var s = r.x * Math.abs(Sn.x) + r.y * Math.abs(Sn.y) + r.z * Math.abs(Sn.z),
                        c = e.dot(Sn),
                        l = n.dot(Sn),
                        h = i.dot(Sn);
                    if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > s) return !1
                }
                return !0
            }
            Object.assign(An.prototype, {
                isBox3: !0,
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromArray: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                        var l = t[s],
                            h = t[s + 1],
                            u = t[s + 2];
                        l < e && (e = l), h < n && (n = h), u < i && (i = u), l > r && (r = l), h > o && (o = h), u > a && (a = u)
                    }
                    return this.min.set(e, n, i), this.max.set(r, o, a), this
                },
                setFromBufferAttribute: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
                        var l = t.getX(s),
                            h = t.getY(s),
                            u = t.getZ(s);
                        l < e && (e = l), h < n && (n = h), u < i && (i = u), l > r && (r = l), h > o && (o = h), u > a && (a = u)
                    }
                    return this.min.set(e, n, i), this.max.set(r, o, a), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function(t, e) {
                    var n = vn.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                },
                setFromObject: function(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Ce), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Ce), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                expandByObject: function(t) {
                    var e, n;
                    t.updateWorldMatrix(!1, !1);
                    var i = t.geometry;
                    if (void 0 !== i)
                        if (i.isGeometry) {
                            var r = i.vertices;
                            for (e = 0, n = r.length; e < n; e++) vn.copy(r[e]), vn.applyMatrix4(t.matrixWorld), this.expandByPoint(vn)
                        } else if (i.isBufferGeometry) {
                        var o = i.attributes.position;
                        if (void 0 !== o)
                            for (e = 0, n = o.count; e < n; e++) vn.fromBufferAttribute(o, e).applyMatrix4(t.matrixWorld), this.expandByPoint(vn)
                    }
                    var a = t.children;
                    for (e = 0, n = a.length; e < n; e++) this.expandByObject(a[e]);
                    return this
                },
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                },
                getParameter: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Ce), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                },
                intersectsSphere: function(t) {
                    return this.clampPoint(t.center, vn), vn.distanceToSquared(t.center) <= t.radius * t.radius
                },
                intersectsPlane: function(t) {
                    var e, n;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                },
                intersectsTriangle: function(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Mn), Tn.subVectors(this.max, Mn), gn.subVectors(t.a, Mn), yn.subVectors(t.b, Mn), _n.subVectors(t.c, Mn), xn.subVectors(yn, gn), bn.subVectors(_n, yn), wn.subVectors(gn, _n);
                    var e = [0, -xn.z, xn.y, 0, -bn.z, bn.y, 0, -wn.z, wn.y, xn.z, 0, -xn.x, bn.z, 0, -bn.x, wn.z, 0, -wn.x, -xn.y, xn.x, 0, -bn.y, bn.x, 0, -wn.y, wn.x, 0];
                    return !!Pn(e, gn, yn, _n, Tn) && !!Pn(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], gn, yn, _n, Tn) && (En.crossVectors(xn, bn), Pn(e = [En.x, En.y, En.z], gn, yn, _n, Tn))
                },
                clampPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Ce), e.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function(t) {
                    var e = vn.copy(t).clamp(this.min, this.max);
                    return e.sub(t).length()
                },
                getBoundingSphere: function(t) {
                    return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(vn).length(), t
                },
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                applyMatrix4: function(t) {
                    return this.isEmpty() ? this : (mn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), mn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), mn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), mn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), mn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), mn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), mn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), mn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(mn), this)
                },
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            });
            var Ln = new An;

            function Rn(t, e) {
                this.center = void 0 !== t ? t : new Ce, this.radius = void 0 !== e ? e : 0
            }
            Object.assign(Rn.prototype, {
                set: function(t, e) {
                    return this.center.copy(t), this.radius = e, this
                },
                setFromPoints: function(t, e) {
                    var n = this.center;
                    void 0 !== e ? n.copy(e) : Ln.setFromPoints(t).getCenter(n);
                    for (var i = 0, r = 0, o = t.length; r < o; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                    return this.radius = Math.sqrt(i), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(t) {
                    return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(t) {
                    var e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function(t) {
                    return t.intersectsSphere(this)
                },
                intersectsPlane: function(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(t, e) {
                    var n = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Ce), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                },
                getBoundingBox: function(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new An), t.set(this.center, this.center), t.expandByScalar(this.radius), t
                },
                applyMatrix4: function(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                },
                translate: function(t) {
                    return this.center.add(t), this
                },
                equals: function(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            });
            var Cn = new Ce,
                On = new Ce,
                In = new Ce,
                Dn = new Ce,
                Nn = new Ce,
                Bn = new Ce,
                Hn = new Ce;

            function Fn(t, e) {
                this.origin = void 0 !== t ? t : new Ce, this.direction = void 0 !== e ? e : new Ce
            }
            Object.assign(Fn.prototype, {
                set: function(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                },
                at: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Ce), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                },
                recast: function(t) {
                    return this.origin.copy(this.at(t, Cn)), this
                },
                closestPointToPoint: function(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Ce), e.subVectors(t, this.origin);
                    var n = e.dot(this.direction);
                    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: function(t) {
                    var e = Cn.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (Cn.copy(this.direction).multiplyScalar(e).add(this.origin), Cn.distanceToSquared(t))
                },
                distanceSqToSegment: function(t, e, n, i) {
                    On.copy(t).add(e).multiplyScalar(.5), In.copy(e).sub(t).normalize(), Dn.copy(this.origin).sub(On);
                    var r, o, a, s, c = .5 * t.distanceTo(e),
                        l = -this.direction.dot(In),
                        h = Dn.dot(this.direction),
                        u = -Dn.dot(In),
                        p = Dn.lengthSq(),
                        d = Math.abs(1 - l * l);
                    if (d > 0)
                        if (o = l * h - u, s = c * d, (r = l * u - h) >= 0)
                            if (o >= -s)
                                if (o <= s) {
                                    var f = 1 / d;
                                    a = (r *= f) * (r + l * (o *= f) + 2 * h) + o * (l * r + o + 2 * u) + p
                                } else o = c, r = Math.max(0, -(l * o + h)), a = -r * r + o * (o + 2 * u) + p;
                    else o = -c, r = Math.max(0, -(l * o + h)), a = -r * r + o * (o + 2 * u) + p;
                    else o <= -s ? (r = Math.max(0, -(-l * c + h)), o = r > 0 ? -c : Math.min(Math.max(-c, -u), c), a = -r * r + o * (o + 2 * u) + p) : o <= s ? (r = 0, o = Math.min(Math.max(-c, -u), c), a = o * (o + 2 * u) + p) : (r = Math.max(0, -(l * c + h)), o = r > 0 ? c : Math.min(Math.max(-c, -u), c), a = -r * r + o * (o + 2 * u) + p);
                    else o = l > 0 ? -c : c, r = Math.max(0, -(l * o + h)), a = -r * r + o * (o + 2 * u) + p;
                    return n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy(In).multiplyScalar(o).add(On), a
                },
                intersectSphere: function(t, e) {
                    Cn.subVectors(t.center, this.origin);
                    var n = Cn.dot(this.direction),
                        i = Cn.dot(Cn) - n * n,
                        r = t.radius * t.radius;
                    if (i > r) return null;
                    var o = Math.sqrt(r - i),
                        a = n - o,
                        s = n + o;
                    return a < 0 && s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e)
                },
                intersectsSphere: function(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                },
                distanceToPlane: function(t) {
                    var e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null
                },
                intersectPlane: function(t, e) {
                    var n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e)
                },
                intersectsPlane: function(t) {
                    var e = t.distanceToPoint(this.origin);
                    if (0 === e) return !0;
                    var n = t.normal.dot(this.direction);
                    return n * e < 0
                },
                intersectBox: function(t, e) {
                    var n, i, r, o, a, s, c = 1 / this.direction.x,
                        l = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return c >= 0 ? (n = (t.min.x - u.x) * c, i = (t.max.x - u.x) * c) : (n = (t.max.x - u.x) * c, i = (t.min.x - u.x) * c), l >= 0 ? (r = (t.min.y - u.y) * l, o = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, o = (t.min.y - u.y) * l), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), h >= 0 ? (a = (t.min.z - u.z) * h, s = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, s = (t.min.z - u.z) * h), n > s || a > i ? null : ((a > n || n != n) && (n = a), (s < i || i != i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                },
                intersectsBox: function(t) {
                    return null !== this.intersectBox(t, Cn)
                },
                intersectTriangle: function(t, e, n, i, r) {
                    Nn.subVectors(e, t), Bn.subVectors(n, t), Hn.crossVectors(Nn, Bn);
                    var o, a = this.direction.dot(Hn);
                    if (a > 0) {
                        if (i) return null;
                        o = 1
                    } else {
                        if (!(a < 0)) return null;
                        o = -1, a = -a
                    }
                    Dn.subVectors(this.origin, t);
                    var s = o * this.direction.dot(Bn.crossVectors(Dn, Bn));
                    if (s < 0) return null;
                    var c = o * this.direction.dot(Nn.cross(Dn));
                    if (c < 0) return null;
                    if (s + c > a) return null;
                    var l = -o * Dn.dot(Hn);
                    return l < 0 ? null : this.at(l / a, r)
                },
                applyMatrix4: function(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                },
                equals: function(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            });
            var kn = new Ce,
                Un = new Ce,
                zn = new Ce,
                Gn = new Ce,
                jn = new Ce,
                Vn = new Ce,
                Wn = new Ce,
                Xn = new Ce,
                qn = new Ce,
                Yn = new Ce;

            function Zn(t, e, n) {
                this.a = void 0 !== t ? t : new Ce, this.b = void 0 !== e ? e : new Ce, this.c = void 0 !== n ? n : new Ce
            }
            Object.assign(Zn, {
                getNormal: function(t, e, n, i) {
                    void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Ce), i.subVectors(n, e), kn.subVectors(t, e), i.cross(kn);
                    var r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                },
                getBarycoord: function(t, e, n, i, r) {
                    kn.subVectors(i, e), Un.subVectors(n, e), zn.subVectors(t, e);
                    var o = kn.dot(kn),
                        a = kn.dot(Un),
                        s = kn.dot(zn),
                        c = Un.dot(Un),
                        l = Un.dot(zn),
                        h = o * c - a * a;
                    if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Ce), 0 === h) return r.set(-2, -1, -1);
                    var u = 1 / h,
                        p = (c * s - a * l) * u,
                        d = (o * l - a * s) * u;
                    return r.set(1 - p - d, d, p)
                },
                containsPoint: function(t, e, n, i) {
                    return Zn.getBarycoord(t, e, n, i, Gn), Gn.x >= 0 && Gn.y >= 0 && Gn.x + Gn.y <= 1
                },
                getUV: function(t, e, n, i, r, o, a, s) {
                    return this.getBarycoord(t, e, n, i, Gn), s.set(0, 0), s.addScaledVector(r, Gn.x), s.addScaledVector(o, Gn.y), s.addScaledVector(a, Gn.z), s
                },
                isFrontFacing: function(t, e, n, i) {
                    return kn.subVectors(n, e), Un.subVectors(t, e), kn.cross(Un).dot(i) < 0
                }
            }), Object.assign(Zn.prototype, {
                set: function(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                },
                setFromPointsAndIndices: function(t, e, n, i) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                },
                getArea: function() {
                    return kn.subVectors(this.c, this.b), Un.subVectors(this.a, this.b), .5 * kn.cross(Un).length()
                },
                getMidpoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Ce), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function(t) {
                    return Zn.getNormal(this.a, this.b, this.c, t)
                },
                getPlane: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Ce), t.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function(t, e) {
                    return Zn.getBarycoord(t, this.a, this.b, this.c, e)
                },
                getUV: function(t, e, n, i, r) {
                    return Zn.getUV(t, this.a, this.b, this.c, e, n, i, r)
                },
                containsPoint: function(t) {
                    return Zn.containsPoint(t, this.a, this.b, this.c)
                },
                isFrontFacing: function(t) {
                    return Zn.isFrontFacing(this.a, this.b, this.c, t)
                },
                intersectsBox: function(t) {
                    return t.intersectsTriangle(this)
                },
                closestPointToPoint: function(t, e) {
                    void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new Ce);
                    var n, i, r = this.a,
                        o = this.b,
                        a = this.c;
                    jn.subVectors(o, r), Vn.subVectors(a, r), Xn.subVectors(t, r);
                    var s = jn.dot(Xn),
                        c = Vn.dot(Xn);
                    if (s <= 0 && c <= 0) return e.copy(r);
                    qn.subVectors(t, o);
                    var l = jn.dot(qn),
                        h = Vn.dot(qn);
                    if (l >= 0 && h <= l) return e.copy(o);
                    var u = s * h - l * c;
                    if (u <= 0 && s >= 0 && l <= 0) return n = s / (s - l), e.copy(r).addScaledVector(jn, n);
                    Yn.subVectors(t, a);
                    var p = jn.dot(Yn),
                        d = Vn.dot(Yn);
                    if (d >= 0 && p <= d) return e.copy(a);
                    var f = p * c - s * d;
                    if (f <= 0 && c >= 0 && d <= 0) return i = c / (c - d), e.copy(r).addScaledVector(Vn, i);
                    var m = l * d - p * h;
                    if (m <= 0 && h - l >= 0 && p - d >= 0) return Wn.subVectors(a, o), i = (h - l) / (h - l + (p - d)), e.copy(o).addScaledVector(Wn, i);
                    var v = 1 / (m + f + u);
                    return n = f * v, i = u * v, e.copy(r).addScaledVector(jn, n).addScaledVector(Vn, i)
                },
                equals: function(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            });
            var Jn = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                Kn = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                Qn = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function $n(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }

            function ti(t, e, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }

            function ei(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function ni(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }

            function ii(t, e, n, i, r, o) {
                this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new Ce, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new $n, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
            }
            Object.assign($n.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                },
                setScalar: function(t) {
                    return this.r = t, this.g = t, this.b = t, this
                },
                setHex: function(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                },
                setRGB: function(t, e, n) {
                    return this.r = t, this.g = e, this.b = n, this
                },
                setHSL: function(t, e, n) {
                    if (t = Se.euclideanModulo(t, 1), e = Se.clamp(e, 0, 1), n = Se.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                    else {
                        var i = n <= .5 ? n * (1 + e) : n + e - n * e,
                            r = 2 * n - i;
                        this.r = ti(r, i, t + 1 / 3), this.g = ti(r, i, t), this.b = ti(r, i, t - 1 / 3)
                    }
                    return this
                },
                setStyle: function(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var i, r = n[1],
                            o = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                                if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var a = parseFloat(i[1]) / 360,
                                        s = parseInt(i[2], 10) / 100,
                                        c = parseInt(i[3], 10) / 100;
                                    return e(i[5]), this.setHSL(a, s, c)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var l = n[1],
                            h = l.length;
                        if (3 === h) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                        if (6 === h) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
                    }
                    if (t && t.length > 0) {
                        var l = Jn[t];
                        void 0 !== l ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t)
                    }
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                },
                copyGammaToLinear: function(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                },
                copyLinearToGamma: function(t, e) {
                    void 0 === e && (e = 2);
                    var n = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                },
                convertGammaToLinear: function(t) {
                    return this.copyGammaToLinear(this, t), this
                },
                convertLinearToGamma: function(t) {
                    return this.copyLinearToGamma(this, t), this
                },
                copySRGBToLinear: function(t) {
                    return this.r = ei(t.r), this.g = ei(t.g), this.b = ei(t.b), this
                },
                copyLinearToSRGB: function(t) {
                    return this.r = ni(t.r), this.g = ni(t.g), this.b = ni(t.b), this
                },
                convertSRGBToLinear: function() {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function() {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var e, n, i = this.r,
                        r = this.g,
                        o = this.b,
                        a = Math.max(i, r, o),
                        s = Math.min(i, r, o),
                        c = (s + a) / 2;
                    if (s === a) e = 0, n = 0;
                    else {
                        var l = a - s;
                        switch (n = c <= .5 ? l / (a + s) : l / (2 - a - s), a) {
                            case i:
                                e = (r - o) / l + (r < o ? 6 : 0);
                                break;
                            case r:
                                e = (o - i) / l + 2;
                                break;
                            case o:
                                e = (i - r) / l + 4
                        }
                        e /= 6
                    }
                    return t.h = e, t.s = n, t.l = c, t
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function(t, e, n) {
                    return this.getHSL(Kn), Kn.h += t, Kn.s += e, Kn.l += n, this.setHSL(Kn.h, Kn.s, Kn.l), this
                },
                add: function(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                },
                addColors: function(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                },
                addScalar: function(t) {
                    return this.r += t, this.g += t, this.b += t, this
                },
                sub: function(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                },
                multiply: function(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                },
                multiplyScalar: function(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                },
                lerp: function(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                },
                lerpHSL: function(t, e) {
                    this.getHSL(Kn), t.getHSL(Qn);
                    var n = Se.lerp(Kn.h, Qn.h, e),
                        i = Se.lerp(Kn.s, Qn.s, e),
                        r = Se.lerp(Kn.l, Qn.l, e);
                    return this.setHSL(n, i, r), this
                },
                equals: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                },
                toJSON: function() {
                    return this.getHex()
                }
            }), Object.assign(ii.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (var e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            });
            var ri = 0;

            function oi() {
                Object.defineProperty(this, "id", {
                    value: ri++
                }), this.uuid = Se.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = f, this.side = s, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = h, this.opacity = 1, this.transparent = !1, this.blendSrc = P, this.blendDst = L, this.blendEquation = _, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = F, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = we, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = be, this.stencilZFail = be, this.stencilZPass = be, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.needsUpdate = !0
            }

            function ai(t) {
                oi.call(this), this.type = "MeshBasicMaterial", this.color = new $n(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
            }

            function si(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function ci(t, e, n) {
                si.call(this, new Int8Array(t), e, n)
            }

            function li(t, e, n) {
                si.call(this, new Uint8Array(t), e, n)
            }

            function hi(t, e, n) {
                si.call(this, new Uint8ClampedArray(t), e, n)
            }

            function ui(t, e, n) {
                si.call(this, new Int16Array(t), e, n)
            }

            function pi(t, e, n) {
                si.call(this, new Uint16Array(t), e, n)
            }

            function di(t, e, n) {
                si.call(this, new Int32Array(t), e, n)
            }

            function fi(t, e, n) {
                si.call(this, new Uint32Array(t), e, n)
            }

            function mi(t, e, n) {
                si.call(this, new Float32Array(t), e, n)
            }

            function vi(t, e, n) {
                si.call(this, new Float64Array(t), e, n)
            }

            function gi() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function yi(t) {
                if (0 === t.length) return -1 / 0;
                for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
                return e
            }
            oi.prototype = Object.assign(Object.create(Me.prototype), {
                constructor: oi,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var n = t[e];
                            if (void 0 !== n)
                                if ("shading" !== e) {
                                    var i = this[e];
                                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                        }
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function i(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== f && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== s && (n.side = this.side), this.vertexColors !== h && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                        var r = i(t.textures),
                            o = i(t.images);
                        r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWrite = t.stencilWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                    var e = t.clippingPlanes,
                        n = null;
                    if (null !== e) {
                        var i = e.length;
                        n = new Array(i);
                        for (var r = 0; r !== i; ++r) n[r] = e[r].clone()
                    }
                    return this.clippingPlanes = n, this.shadowSide = t.shadowSide, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), ai.prototype = Object.create(oi.prototype), ai.prototype.constructor = ai, ai.prototype.isMeshBasicMaterial = !0, ai.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            }, Object.defineProperty(si.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(si.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize, n *= e.itemSize;
                    for (var i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), o = new $n), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), o = new Ae), e[n++] = o.x, e[n++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), o = new Ce), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), o = new Fe), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w
                    }
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                },
                toJSON: function() {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    }
                }
            }), ci.prototype = Object.create(si.prototype), ci.prototype.constructor = ci, li.prototype = Object.create(si.prototype), li.prototype.constructor = li, hi.prototype = Object.create(si.prototype), hi.prototype.constructor = hi, ui.prototype = Object.create(si.prototype), ui.prototype.constructor = ui, pi.prototype = Object.create(si.prototype), pi.prototype.constructor = pi, di.prototype = Object.create(si.prototype), di.prototype.constructor = di, fi.prototype = Object.create(si.prototype), fi.prototype.constructor = fi, mi.prototype = Object.create(si.prototype), mi.prototype.constructor = mi, vi.prototype = Object.create(si.prototype), vi.prototype.constructor = vi, Object.assign(gi.prototype, {
                computeGroups: function(t) {
                    for (var e, n = [], i = void 0, r = t.faces, o = 0; o < r.length; o++) {
                        var a = r[o];
                        a.materialIndex !== i && (i = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), e = {
                            start: 3 * o,
                            materialIndex: i
                        })
                    }
                    void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), this.groups = n
                },
                fromGeometry: function(t) {
                    var e, n = t.faces,
                        i = t.vertices,
                        r = t.faceVertexUvs,
                        o = r[0] && r[0].length > 0,
                        a = r[1] && r[1].length > 0,
                        s = t.morphTargets,
                        c = s.length;
                    if (c > 0) {
                        e = [];
                        for (var l = 0; l < c; l++) e[l] = {
                            name: s[l].name,
                            data: []
                        };
                        this.morphTargets.position = e
                    }
                    var h, u = t.morphNormals,
                        p = u.length;
                    if (p > 0) {
                        h = [];
                        for (var l = 0; l < p; l++) h[l] = {
                            name: u[l].name,
                            data: []
                        };
                        this.morphTargets.normal = h
                    }
                    var d = t.skinIndices,
                        f = t.skinWeights,
                        m = d.length === i.length,
                        v = f.length === i.length;
                    i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (var l = 0; l < n.length; l++) {
                        var g = n[l];
                        this.vertices.push(i[g.a], i[g.b], i[g.c]);
                        var y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var _ = g.normal;
                            this.normals.push(_, _, _)
                        }
                        var x = g.vertexColors;
                        if (3 === x.length) this.colors.push(x[0], x[1], x[2]);
                        else {
                            var b = g.color;
                            this.colors.push(b, b, b)
                        }
                        if (!0 === o) {
                            var w = r[0][l];
                            void 0 !== w ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new Ae, new Ae, new Ae))
                        }
                        if (!0 === a) {
                            var w = r[1][l];
                            void 0 !== w ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new Ae, new Ae, new Ae))
                        }
                        for (var M = 0; M < c; M++) {
                            var T = s[M].vertices;
                            e[M].data.push(T[g.a], T[g.b], T[g.c])
                        }
                        for (var M = 0; M < p; M++) {
                            var E = u[M].vertexNormals[l];
                            h[M].data.push(E.a, E.b, E.c)
                        }
                        m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                }
            });
            var _i = 1,
                xi = new Ye,
                bi = new dn,
                wi = new Ce,
                Mi = new An,
                Ti = new An,
                Ei = new Ce;

            function Si() {
                Object.defineProperty(this, "id", {
                    value: _i += 2
                }), this.uuid = Se.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            Si.prototype = Object.assign(Object.create(Me.prototype), {
                constructor: Si,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    Array.isArray(t) ? this.index = new(yi(t) > 65535 ? fi : pi)(t, 1) : this.index = t
                },
                addAttribute: function(t, e) {
                    return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new si(arguments[1], arguments[2])))
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                setAttribute: function(t, e) {
                    return this.attributes[t] = e, this
                },
                removeAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, n) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                    var n = this.attributes.normal;
                    if (void 0 !== n) {
                        var i = (new De).getNormalMatrix(t);
                        i.applyToBufferAttribute(n), n.needsUpdate = !0
                    }
                    var r = this.attributes.tangent;
                    if (void 0 !== r) {
                        var i = (new De).getNormalMatrix(t);
                        i.applyToBufferAttribute(r), r.needsUpdate = !0
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function(t) {
                    return xi.makeRotationX(t), this.applyMatrix(xi), this
                },
                rotateY: function(t) {
                    return xi.makeRotationY(t), this.applyMatrix(xi), this
                },
                rotateZ: function(t) {
                    return xi.makeRotationZ(t), this.applyMatrix(xi), this
                },
                translate: function(t, e, n) {
                    return xi.makeTranslation(t, e, n), this.applyMatrix(xi), this
                },
                scale: function(t, e, n) {
                    return xi.makeScale(t, e, n), this.applyMatrix(xi), this
                },
                lookAt: function(t) {
                    return bi.lookAt(t), bi.updateMatrix(), this.applyMatrix(bi.matrix), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(wi).negate(), this.translate(wi.x, wi.y, wi.z), this
                },
                setFromObject: function(t) {
                    var e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        var n = new mi(3 * e.vertices.length, 3),
                            i = new mi(3 * e.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            var r = new mi(e.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    for (var e = [], n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.addAttribute("position", new mi(e, 3)), this
                },
                updateFromObject: function(t) {
                    var e, n = t.geometry;
                    if (t.isMesh) {
                        var i = n.__directGeometry;
                        if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n);
                        i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i
                    }
                    return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new gi).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e = new Float32Array(3 * t.vertices.length);
                    if (this.addAttribute("position", new si(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        var n = new Float32Array(3 * t.normals.length);
                        this.addAttribute("normal", new si(n, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        var i = new Float32Array(3 * t.colors.length);
                        this.addAttribute("color", new si(i, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        var r = new Float32Array(2 * t.uvs.length);
                        this.addAttribute("uv", new si(r, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        var o = new Float32Array(2 * t.uvs2.length);
                        this.addAttribute("uv2", new si(o, 2).copyVector2sArray(t.uvs2))
                    }
                    for (var a in this.groups = t.groups, t.morphTargets) {
                        for (var s = [], c = t.morphTargets[a], l = 0, h = c.length; l < h; l++) {
                            var u = c[l],
                                p = new mi(3 * u.data.length, 3);
                            p.name = u.name, s.push(p.copyVector3sArray(u.data))
                        }
                        this.morphAttributes[a] = s
                    }
                    if (t.skinIndices.length > 0) {
                        var d = new mi(4 * t.skinIndices.length, 4);
                        this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        var f = new mi(4 * t.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new An);
                    var t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (var n = 0, i = e.length; n < i; n++) {
                                var r = e[n];
                                Mi.setFromBufferAttribute(r), this.boundingBox.expandByPoint(Mi.min), this.boundingBox.expandByPoint(Mi.max)
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new Rn);
                    var t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t) {
                        var n = this.boundingSphere.center;
                        if (Mi.setFromBufferAttribute(t), e)
                            for (var i = 0, r = e.length; i < r; i++) {
                                var o = e[i];
                                Ti.setFromBufferAttribute(o), Mi.expandByPoint(Ti.min), Mi.expandByPoint(Ti.max)
                            }
                        Mi.getCenter(n);
                        for (var a = 0, i = 0, r = t.count; i < r; i++) Ei.fromBufferAttribute(t, i), a = Math.max(a, n.distanceToSquared(Ei));
                        if (e)
                            for (var i = 0, r = e.length; i < r; i++)
                                for (var o = e[i], s = 0, c = o.count; s < c; s++) Ei.fromBufferAttribute(o, s), a = Math.max(a, n.distanceToSquared(Ei));
                        this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                },
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index,
                        e = this.attributes;
                    if (e.position) {
                        var n = e.position.array;
                        if (void 0 === e.normal) this.addAttribute("normal", new si(new Float32Array(n.length), 3));
                        else
                            for (var i = e.normal.array, r = 0, o = i.length; r < o; r++) i[r] = 0;
                        var a, s, c, l = e.normal.array,
                            h = new Ce,
                            u = new Ce,
                            p = new Ce,
                            d = new Ce,
                            f = new Ce;
                        if (t)
                            for (var m = t.array, r = 0, o = t.count; r < o; r += 3) a = 3 * m[r + 0], s = 3 * m[r + 1], c = 3 * m[r + 2], h.fromArray(n, a), u.fromArray(n, s), p.fromArray(n, c), d.subVectors(p, u), f.subVectors(h, u), d.cross(f), l[a] += d.x, l[a + 1] += d.y, l[a + 2] += d.z, l[s] += d.x, l[s + 1] += d.y, l[s + 2] += d.z, l[c] += d.x, l[c + 1] += d.y, l[c + 2] += d.z;
                        else
                            for (var r = 0, o = n.length; r < o; r += 9) h.fromArray(n, r), u.fromArray(n, r + 3), p.fromArray(n, r + 6), d.subVectors(p, u), f.subVectors(h, u), d.cross(f), l[r] = d.x, l[r + 1] = d.y, l[r + 2] = d.z, l[r + 3] = d.x, l[r + 4] = d.y, l[r + 5] = d.z, l[r + 6] = d.x, l[r + 7] = d.y, l[r + 8] = d.z;
                        this.normalizeNormals(), e.normal.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (t && t.isBufferGeometry) {
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var n = this.attributes;
                        for (var i in n)
                            if (void 0 !== t.attributes[i])
                                for (var r = n[i], o = r.array, a = t.attributes[i], s = a.array, c = a.itemSize * e, l = Math.min(s.length, o.length - c), h = 0, u = c; h < l; h++, u++) o[u] = s[h];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
                },
                normalizeNormals: function() {
                    for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++) Ei.x = t.getX(e), Ei.y = t.getY(e), Ei.z = t.getZ(e), Ei.normalize(), t.setXYZ(e, Ei.x, Ei.y, Ei.z)
                },
                toNonIndexed: function() {
                    function t(t, e) {
                        for (var n = t.array, i = t.itemSize, r = new n.constructor(e.length * i), o = 0, a = 0, s = 0, c = e.length; s < c; s++) {
                            o = e[s] * i;
                            for (var l = 0; l < i; l++) r[a++] = n[o++]
                        }
                        return new si(r, i)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var e = new Si,
                        n = this.index.array,
                        i = this.attributes;
                    for (var r in i) {
                        var o = i[r],
                            a = t(o, n);
                        e.addAttribute(r, a)
                    }
                    var s = this.morphAttributes;
                    for (r in s) {
                        for (var c = [], l = s[r], h = 0, u = l.length; h < u; h++) {
                            var o = l[h],
                                a = t(o, n);
                            c.push(a)
                        }
                        e.morphAttributes[r] = c
                    }
                    for (var p = this.groups, h = 0, d = p.length; h < d; h++) {
                        var f = p[h];
                        e.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var i = this.index;
                    null !== i && (t.data.index = {
                        type: i.array.constructor.name,
                        array: Array.prototype.slice.call(i.array)
                    });
                    var r = this.attributes;
                    for (var n in r) {
                        var o = r[n],
                            a = o.toJSON();
                        "" !== o.name && (a.name = o.name), t.data.attributes[n] = a
                    }
                    var s = {},
                        c = !1;
                    for (var n in this.morphAttributes) {
                        for (var l = this.morphAttributes[n], h = [], u = 0, p = l.length; u < p; u++) {
                            var o = l[u],
                                a = o.toJSON();
                            "" !== o.name && (a.name = o.name), h.push(a)
                        }
                        h.length > 0 && (s[n] = h, c = !0)
                    }
                    c && (t.data.morphAttributes = s);
                    var d = this.groups;
                    d.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(d)));
                    var f = this.boundingSphere;
                    return null !== f && (t.data.boundingSphere = {
                        center: f.center.toArray(),
                        radius: f.radius
                    }), t
                },
                clone: function() {
                    return (new Si).copy(this)
                },
                copy: function(t) {
                    var e, n, i;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var r = t.index;
                    null !== r && this.setIndex(r.clone());
                    var o = t.attributes;
                    for (e in o) {
                        var a = o[e];
                        this.addAttribute(e, a.clone())
                    }
                    var s = t.morphAttributes;
                    for (e in s) {
                        var c = [],
                            l = s[e];
                        for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
                        this.morphAttributes[e] = c
                    }
                    var h = t.groups;
                    for (n = 0, i = h.length; n < i; n++) {
                        var u = h[n];
                        this.addGroup(u.start, u.count, u.materialIndex)
                    }
                    var p = t.boundingBox;
                    null !== p && (this.boundingBox = p.clone());
                    var d = t.boundingSphere;
                    return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var Ai = new Ye,
                Pi = new Fn,
                Li = new Rn,
                Ri = new Ce,
                Ci = new Ce,
                Oi = new Ce,
                Ii = new Ce,
                Di = new Ce,
                Ni = new Ce,
                Bi = new Ce,
                Hi = new Ce,
                Fi = new Ce,
                ki = new Ae,
                Ui = new Ae,
                zi = new Ae,
                Gi = new Ce,
                ji = new Ce;

            function Vi(t, e) {
                dn.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Si, this.material = void 0 !== e ? e : new ai({
                    color: 16777215 * Math.random()
                }), this.drawMode = ae, this.updateMorphTargets()
            }

            function Wi(t, e, n, i, r, o, a, s) {
                if (null === (e.side === c ? i.intersectTriangle(a, o, r, !0, s) : i.intersectTriangle(r, o, a, e.side !== l, s))) return null;
                ji.copy(s), ji.applyMatrix4(t.matrixWorld);
                var h = n.ray.origin.distanceTo(ji);
                return h < n.near || h > n.far ? null : {
                    distance: h,
                    point: ji.clone(),
                    object: t
                }
            }

            function Xi(t, e, n, i, r, o, a, s, c, l, h) {
                Ri.fromBufferAttribute(r, c), Ci.fromBufferAttribute(r, l), Oi.fromBufferAttribute(r, h);
                var u = t.morphTargetInfluences;
                if (e.morphTargets && o && u) {
                    Bi.set(0, 0, 0), Hi.set(0, 0, 0), Fi.set(0, 0, 0);
                    for (var p = 0, d = o.length; p < d; p++) {
                        var f = u[p],
                            m = o[p];
                        0 !== f && (Ii.fromBufferAttribute(m, c), Di.fromBufferAttribute(m, l), Ni.fromBufferAttribute(m, h), Bi.addScaledVector(Ii.sub(Ri), f), Hi.addScaledVector(Di.sub(Ci), f), Fi.addScaledVector(Ni.sub(Oi), f))
                    }
                    Ri.add(Bi), Ci.add(Hi), Oi.add(Fi)
                }
                var v = Wi(t, e, n, i, Ri, Ci, Oi, Gi);
                if (v) {
                    a && (ki.fromBufferAttribute(a, c), Ui.fromBufferAttribute(a, l), zi.fromBufferAttribute(a, h), v.uv = Zn.getUV(Gi, Ri, Ci, Oi, ki, Ui, zi, new Ae)), s && (ki.fromBufferAttribute(s, c), Ui.fromBufferAttribute(s, l), zi.fromBufferAttribute(s, h), v.uv2 = Zn.getUV(Gi, Ri, Ci, Oi, ki, Ui, zi, new Ae));
                    var g = new ii(c, l, h);
                    Zn.getNormal(Ri, Ci, Oi, g.normal), v.face = g
                }
                return v
            }
            Vi.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: Vi,
                isMesh: !0,
                setDrawMode: function(t) {
                    this.drawMode = t
                },
                copy: function(t) {
                    return dn.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
                },
                updateMorphTargets: function() {
                    var t, e, n, i = this.geometry;
                    if (i.isBufferGeometry) {
                        var r = i.morphAttributes,
                            o = Object.keys(r);
                        if (o.length > 0) {
                            var a = r[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) n = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    } else {
                        var s = i.morphTargets;
                        void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                raycast: function(t, e) {
                    var n, i = this.geometry,
                        r = this.material,
                        o = this.matrixWorld;
                    if (void 0 !== r && (null === i.boundingSphere && i.computeBoundingSphere(), Li.copy(i.boundingSphere), Li.applyMatrix4(o), !1 !== t.ray.intersectsSphere(Li) && (Ai.getInverse(o), Pi.copy(t.ray).applyMatrix4(Ai), null === i.boundingBox || !1 !== Pi.intersectsBox(i.boundingBox))))
                        if (i.isBufferGeometry) {
                            var a, s, c, l, h, u, p, d, f, m, v, g = i.index,
                                y = i.attributes.position,
                                _ = i.morphAttributes.position,
                                x = i.attributes.uv,
                                b = i.attributes.uv2,
                                w = i.groups,
                                M = i.drawRange;
                            if (null !== g)
                                if (Array.isArray(r))
                                    for (l = 0, u = w.length; l < u; l++)
                                        for (d = w[l], f = r[d.materialIndex], m = Math.max(d.start, M.start), v = Math.min(d.start + d.count, M.start + M.count), h = m, p = v; h < p; h += 3) a = g.getX(h), s = g.getX(h + 1), c = g.getX(h + 2), (n = Xi(this, f, t, Pi, y, _, x, b, a, s, c)) && (n.faceIndex = Math.floor(h / 3), n.face.materialIndex = d.materialIndex, e.push(n));
                                else
                                    for (m = Math.max(0, M.start), v = Math.min(g.count, M.start + M.count), l = m, u = v; l < u; l += 3) a = g.getX(l), s = g.getX(l + 1), c = g.getX(l + 2), (n = Xi(this, r, t, Pi, y, _, x, b, a, s, c)) && (n.faceIndex = Math.floor(l / 3), e.push(n));
                            else if (void 0 !== y)
                                if (Array.isArray(r))
                                    for (l = 0, u = w.length; l < u; l++)
                                        for (d = w[l], f = r[d.materialIndex], m = Math.max(d.start, M.start), v = Math.min(d.start + d.count, M.start + M.count), h = m, p = v; h < p; h += 3)(n = Xi(this, f, t, Pi, y, _, x, b, a = h, s = h + 1, c = h + 2)) && (n.faceIndex = Math.floor(h / 3), n.face.materialIndex = d.materialIndex, e.push(n));
                                else
                                    for (m = Math.max(0, M.start), v = Math.min(y.count, M.start + M.count), l = m, u = v; l < u; l += 3)(n = Xi(this, r, t, Pi, y, _, x, b, a = l, s = l + 1, c = l + 2)) && (n.faceIndex = Math.floor(l / 3), e.push(n))
                        } else if (i.isGeometry) {
                        var T, E, S, A, P = Array.isArray(r),
                            L = i.vertices,
                            R = i.faces,
                            C = i.faceVertexUvs[0];
                        C.length > 0 && (A = C);
                        for (var O = 0, I = R.length; O < I; O++) {
                            var D = R[O],
                                N = P ? r[D.materialIndex] : r;
                            if (void 0 !== N && (T = L[D.a], E = L[D.b], S = L[D.c], n = Wi(this, N, t, Pi, T, E, S, Gi))) {
                                if (A && A[O]) {
                                    var B = A[O];
                                    ki.copy(B[0]), Ui.copy(B[1]), zi.copy(B[2]), n.uv = Zn.getUV(Gi, T, E, S, ki, Ui, zi, new Ae)
                                }
                                n.face = D, n.faceIndex = O, e.push(n)
                            }
                        }
                    }
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });
            var qi = 0,
                Yi = new Ye,
                Zi = new dn,
                Ji = new Ce;

            function Ki() {
                Object.defineProperty(this, "id", {
                    value: qi += 2
                }), this.uuid = Se.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
            Ki.prototype = Object.assign(Object.create(Me.prototype), {
                constructor: Ki,
                isGeometry: !0,
                applyMatrix: function(t) {
                    for (var e = (new De).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                        var r = this.vertices[n];
                        r.applyMatrix4(t)
                    }
                    for (var n = 0, i = this.faces.length; n < i; n++) {
                        var o = this.faces[n];
                        o.normal.applyMatrix3(e).normalize();
                        for (var a = 0, s = o.vertexNormals.length; a < s; a++) o.vertexNormals[a].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function(t) {
                    return Yi.makeRotationX(t), this.applyMatrix(Yi), this
                },
                rotateY: function(t) {
                    return Yi.makeRotationY(t), this.applyMatrix(Yi), this
                },
                rotateZ: function(t) {
                    return Yi.makeRotationZ(t), this.applyMatrix(Yi), this
                },
                translate: function(t, e, n) {
                    return Yi.makeTranslation(t, e, n), this.applyMatrix(Yi), this
                },
                scale: function(t, e, n) {
                    return Yi.makeScale(t, e, n), this.applyMatrix(Yi), this
                },
                lookAt: function(t) {
                    return Zi.lookAt(t), Zi.updateMatrix(), this.applyMatrix(Zi.matrix), this
                },
                fromBufferGeometry: function(t) {
                    var e = this,
                        n = null !== t.index ? t.index.array : void 0,
                        i = t.attributes;
                    if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                    var r = i.position.array,
                        o = void 0 !== i.normal ? i.normal.array : void 0,
                        a = void 0 !== i.color ? i.color.array : void 0,
                        s = void 0 !== i.uv ? i.uv.array : void 0,
                        c = void 0 !== i.uv2 ? i.uv2.array : void 0;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (var l = 0; l < r.length; l += 3) e.vertices.push((new Ce).fromArray(r, l)), void 0 !== a && e.colors.push((new $n).fromArray(a, l));

                    function h(t, n, i, r) {
                        var l = void 0 === a ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                            h = void 0 === o ? [] : [(new Ce).fromArray(o, 3 * t), (new Ce).fromArray(o, 3 * n), (new Ce).fromArray(o, 3 * i)],
                            u = new ii(t, n, i, h, l, r);
                        e.faces.push(u), void 0 !== s && e.faceVertexUvs[0].push([(new Ae).fromArray(s, 2 * t), (new Ae).fromArray(s, 2 * n), (new Ae).fromArray(s, 2 * i)]), void 0 !== c && e.faceVertexUvs[1].push([(new Ae).fromArray(c, 2 * t), (new Ae).fromArray(c, 2 * n), (new Ae).fromArray(c, 2 * i)])
                    }
                    var u = t.groups;
                    if (u.length > 0)
                        for (var l = 0; l < u.length; l++)
                            for (var p = u[l], d = p.start, f = p.count, m = d, v = d + f; m < v; m += 3) void 0 !== n ? h(n[m], n[m + 1], n[m + 2], p.materialIndex) : h(m, m + 1, m + 2, p.materialIndex);
                    else if (void 0 !== n)
                        for (var l = 0; l < n.length; l += 3) h(n[l], n[l + 1], n[l + 2]);
                    else
                        for (var l = 0; l < r.length / 3; l += 3) h(l, l + 1, l + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Ji).negate(), this.translate(Ji.x, Ji.y, Ji.z), this
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        n = 0 === e ? 1 : 1 / e,
                        i = new Ye;
                    return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
                },
                computeFaceNormals: function() {
                    for (var t = new Ce, e = new Ce, n = 0, i = this.faces.length; n < i; n++) {
                        var r = this.faces[n],
                            o = this.vertices[r.a],
                            a = this.vertices[r.b],
                            s = this.vertices[r.c];
                        t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), r.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    var e, n, i, r, o, a;
                    for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) a[e] = new Ce;
                    if (t) {
                        var s, c, l, h = new Ce,
                            u = new Ce;
                        for (i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], s = this.vertices[o.a], c = this.vertices[o.b], l = this.vertices[o.c], h.subVectors(l, c), u.subVectors(s, c), h.cross(u), a[o.a].add(h), a[o.b].add(h), a[o.c].add(h)
                    } else
                        for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], a[o.a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                    for (e = 0, n = this.vertices.length; e < n; e++) a[e].normalize();
                    for (i = 0, r = this.faces.length; i < r; i++) {
                        var p = (o = this.faces[i]).vertexNormals;
                        3 === p.length ? (p[0].copy(a[o.a]), p[1].copy(a[o.b]), p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(), p[1] = a[o.b].clone(), p[2] = a[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var t, e, n;
                    for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                        var i = (n = this.faces[t]).vertexNormals;
                        3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var t, e, n, i, r;
                    for (n = 0, i = this.faces.length; n < i; n++)
                        for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                    var o = new Ki;
                    for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                            var a = this.morphNormals[t].faceNormals,
                                s = this.morphNormals[t].vertexNormals;
                            for (n = 0, i = this.faces.length; n < i; n++) c = new Ce, l = {
                                a: new Ce,
                                b: new Ce,
                                c: new Ce
                            }, a.push(c), s.push(l)
                        }
                        var c, l, h = this.morphNormals[t];
                        for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], c = h.faceNormals[n], l = h.vertexNormals[n], c.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2])
                    }
                    for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new An), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new Rn), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, n) {
                    if (t && t.isGeometry) {
                        var i, r = this.vertices.length,
                            o = this.vertices,
                            a = t.vertices,
                            s = this.faces,
                            c = t.faces,
                            l = this.colors,
                            h = t.colors;
                        void 0 === n && (n = 0), void 0 !== e && (i = (new De).getNormalMatrix(e));
                        for (var u = 0, p = a.length; u < p; u++) {
                            var d = a[u],
                                f = d.clone();
                            void 0 !== e && f.applyMatrix4(e), o.push(f)
                        }
                        for (var u = 0, p = h.length; u < p; u++) l.push(h[u].clone());
                        for (u = 0, p = c.length; u < p; u++) {
                            var m, v, g, y = c[u],
                                _ = y.vertexNormals,
                                x = y.vertexColors;
                            (m = new ii(y.a + r, y.b + r, y.c + r)).normal.copy(y.normal), void 0 !== i && m.normal.applyMatrix3(i).normalize();
                            for (var b = 0, w = _.length; b < w; b++) v = _[b].clone(), void 0 !== i && v.applyMatrix3(i).normalize(), m.vertexNormals.push(v);
                            m.color.copy(y.color);
                            for (var b = 0, w = x.length; b < w; b++) g = x[b], m.vertexColors.push(g.clone());
                            m.materialIndex = y.materialIndex + n, s.push(m)
                        }
                        for (var u = 0, p = t.faceVertexUvs.length; u < p; u++) {
                            var M = t.faceVertexUvs[u];
                            void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                            for (var b = 0, w = M.length; b < w; b++) {
                                for (var T = M[b], E = [], S = 0, A = T.length; S < A; S++) E.push(T[S].clone());
                                this.faceVertexUvs[u].push(E)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    var t, e, n, i, r, o, a, s, c = {},
                        l = [],
                        h = [],
                        u = Math.pow(10, 4);
                    for (n = 0, i = this.vertices.length; n < i; n++) t = this.vertices[n], e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u), void 0 === c[e] ? (c[e] = n, l.push(this.vertices[n]), h[n] = l.length - 1) : h[n] = h[c[e]];
                    var p = [];
                    for (n = 0, i = this.faces.length; n < i; n++) {
                        (r = this.faces[n]).a = h[r.a], r.b = h[r.b], r.c = h[r.c], o = [r.a, r.b, r.c];
                        for (var d = 0; d < 3; d++)
                            if (o[d] === o[(d + 1) % 3]) {
                                p.push(n);
                                break
                            }
                    }
                    for (n = p.length - 1; n >= 0; n--) {
                        var f = p[n];
                        for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                    }
                    var m = this.vertices.length - l.length;
                    return this.vertices = l, m
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (var e = 0, n = t.length; e < n; e++) {
                        var i = t[e];
                        this.vertices.push(new Ce(i.x, i.y, i.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
                    t.sort(function(t, e) {
                        return t.materialIndex - e.materialIndex
                    });
                    var i, r, o = this.faceVertexUvs[0],
                        a = this.faceVertexUvs[1];
                    o && o.length === e && (i = []), a && a.length === e && (r = []);
                    for (var n = 0; n < e; n++) {
                        var s = t[n]._id;
                        i && i.push(o[s]), r && r.push(a[s])
                    }
                    i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    for (var i = [], r = 0; r < this.vertices.length; r++) {
                        var o = this.vertices[r];
                        i.push(o.x, o.y, o.z)
                    }
                    for (var a = [], s = [], c = {}, l = [], h = {}, u = [], p = {}, r = 0; r < this.faces.length; r++) {
                        var d = this.faces[r],
                            f = void 0 !== this.faceVertexUvs[0][r],
                            m = d.normal.length() > 0,
                            v = d.vertexNormals.length > 0,
                            g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                            y = d.vertexColors.length > 0,
                            _ = 0;
                        if (_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, v), 6, g), 7, y), a.push(_), a.push(d.a, d.b, d.c), a.push(d.materialIndex), f) {
                            var x = this.faceVertexUvs[0][r];
                            a.push(S(x[0]), S(x[1]), S(x[2]))
                        }
                        if (m && a.push(T(d.normal)), v) {
                            var b = d.vertexNormals;
                            a.push(T(b[0]), T(b[1]), T(b[2]))
                        }
                        if (g && a.push(E(d.color)), y) {
                            var w = d.vertexColors;
                            a.push(E(w[0]), E(w[1]), E(w[2]))
                        }
                    }

                    function M(t, e, n) {
                        return n ? t | 1 << e : t & ~(1 << e)
                    }

                    function T(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e])
                    }

                    function E(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== h[e] ? h[e] : (h[e] = l.length, l.push(t.getHex()), h[e])
                    }

                    function S(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== p[e] ? p[e] : (p[e] = u.length / 2, u.push(t.x, t.y), p[e])
                    }
                    return t.data = {}, t.data.vertices = i, t.data.normals = s, l.length > 0 && (t.data.colors = l), u.length > 0 && (t.data.uvs = [u]), t.data.faces = a, t
                },
                clone: function() {
                    return (new Ki).copy(this)
                },
                copy: function(t) {
                    var e, n, i, r, o, a;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var s = t.vertices;
                    for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
                    var c = t.colors;
                    for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
                    var l = t.faces;
                    for (e = 0, n = l.length; e < n; e++) this.faces.push(l[e].clone());
                    for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                        var h = t.faceVertexUvs[e];
                        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = h.length; i < r; i++) {
                            var u = h[i],
                                p = [];
                            for (o = 0, a = u.length; o < a; o++) {
                                var d = u[o];
                                p.push(d.clone())
                            }
                            this.faceVertexUvs[e].push(p)
                        }
                    }
                    var f = t.morphTargets;
                    for (e = 0, n = f.length; e < n; e++) {
                        var m = {};
                        if (m.name = f[e].name, void 0 !== f[e].vertices)
                            for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++) m.vertices.push(f[e].vertices[i].clone());
                        if (void 0 !== f[e].normals)
                            for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++) m.normals.push(f[e].normals[i].clone());
                        this.morphTargets.push(m)
                    }
                    var v = t.morphNormals;
                    for (e = 0, n = v.length; e < n; e++) {
                        var g = {};
                        if (void 0 !== v[e].vertexNormals)
                            for (g.vertexNormals = [], i = 0, r = v[e].vertexNormals.length; i < r; i++) {
                                var y = v[e].vertexNormals[i],
                                    _ = {};
                                _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), g.vertexNormals.push(_)
                            }
                        if (void 0 !== v[e].faceNormals)
                            for (g.faceNormals = [], i = 0, r = v[e].faceNormals.length; i < r; i++) g.faceNormals.push(v[e].faceNormals[i].clone());
                        this.morphNormals.push(g)
                    }
                    var x = t.skinWeights;
                    for (e = 0, n = x.length; e < n; e++) this.skinWeights.push(x[e].clone());
                    var b = t.skinIndices;
                    for (e = 0, n = b.length; e < n; e++) this.skinIndices.push(b[e].clone());
                    var w = t.lineDistances;
                    for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
                    var M = t.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var T = t.boundingSphere;
                    return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var Qi = function(t) {
                    function e(e, n, i, r, o, a) {
                        t.call(this), this.type = "BoxGeometry", this.parameters = {
                            width: e,
                            height: n,
                            depth: i,
                            widthSegments: r,
                            heightSegments: o,
                            depthSegments: a
                        }, this.fromBufferGeometry(new $i(e, n, i, r, o, a)), this.mergeVertices()
                    }
                    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
                }(Ki),
                $i = function(t) {
                    function e(e, n, i, r, o, a) {
                        t.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                            width: e,
                            height: n,
                            depth: i,
                            widthSegments: r,
                            heightSegments: o,
                            depthSegments: a
                        };
                        var s = this;
                        e = e || 1, n = n || 1, i = i || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1, a = Math.floor(a) || 1;
                        var c = [],
                            l = [],
                            h = [],
                            u = [],
                            p = 0,
                            d = 0;

                        function f(t, e, n, i, r, o, a, f, m, v, g) {
                            var y, _, x = o / m,
                                b = a / v,
                                w = o / 2,
                                M = a / 2,
                                T = f / 2,
                                E = m + 1,
                                S = v + 1,
                                A = 0,
                                P = 0,
                                L = new Ce;
                            for (_ = 0; _ < S; _++) {
                                var R = _ * b - M;
                                for (y = 0; y < E; y++) {
                                    var C = y * x - w;
                                    L[t] = C * i, L[e] = R * r, L[n] = T, l.push(L.x, L.y, L.z), L[t] = 0, L[e] = 0, L[n] = f > 0 ? 1 : -1, h.push(L.x, L.y, L.z), u.push(y / m), u.push(1 - _ / v), A += 1
                                }
                            }
                            for (_ = 0; _ < v; _++)
                                for (y = 0; y < m; y++) {
                                    var O = p + y + E * _,
                                        I = p + y + E * (_ + 1),
                                        D = p + (y + 1) + E * (_ + 1),
                                        N = p + (y + 1) + E * _;
                                    c.push(O, I, N), c.push(I, D, N), P += 6
                                }
                            s.addGroup(d, P, g), d += P, p += A
                        }
                        f("z", "y", "x", -1, -1, i, n, e, a, o, 0), f("z", "y", "x", 1, -1, i, n, -e, a, o, 1), f("x", "z", "y", 1, 1, e, i, n, r, a, 2), f("x", "z", "y", 1, -1, e, i, -n, r, a, 3), f("x", "y", "z", 1, -1, e, n, i, r, o, 4), f("x", "y", "z", -1, -1, e, n, -i, r, o, 5), this.setIndex(c), this.addAttribute("position", new mi(l, 3)), this.addAttribute("normal", new mi(h, 3)), this.addAttribute("uv", new mi(u, 2))
                    }
                    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
                }(Si);

            function tr(t) {
                var e = {};
                for (var n in t)
                    for (var i in e[n] = {}, t[n]) {
                        var r = t[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                    }
                return e
            }

            function er(t) {
                for (var e = {}, n = 0; n < t.length; n++) {
                    var i = tr(t[n]);
                    for (var r in i) e[r] = i[r]
                }
                return e
            }
            var nr = {
                    clone: tr,
                    merge: er
                },
                ir = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                rr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

            function or(t) {
                oi.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = ir, this.fragmentShader = rr, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function ar() {
                dn.call(this), this.type = "Camera", this.matrixWorldInverse = new Ye, this.projectionMatrix = new Ye, this.projectionMatrixInverse = new Ye
            }

            function sr(t, e, n, i) {
                ar.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            or.prototype = Object.create(oi.prototype), or.prototype.constructor = or, or.prototype.isShaderMaterial = !0, or.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = tr(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
            }, or.prototype.toJSON = function(t) {
                var e = oi.prototype.toJSON.call(this, t);
                for (var n in e.uniforms = {}, this.uniforms) {
                    var i = this.uniforms[n],
                        r = i.value;
                    r && r.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(t).uuid
                    } : r && r.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : e.uniforms[n] = {
                        value: r
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                var o = {};
                for (var a in this.extensions) !0 === this.extensions[a] && (o[a] = !0);
                return Object.keys(o).length > 0 && (e.extensions = o), e
            }, ar.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: ar,
                isCamera: !0,
                copy: function(t, e) {
                    return dn.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Ce), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    dn.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), sr.prototype = Object.assign(Object.create(ar.prototype), {
                constructor: sr,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return ar.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    var e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * Se.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var t = Math.tan(.5 * Se.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * Se.RAD2DEG * Math.atan(Math.tan(.5 * Se.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, i, r, o) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = this.near,
                        e = t * Math.tan(.5 * Se.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * e,
                        i = this.aspect * n,
                        r = -.5 * i,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        r += o.offsetX * i / a, e -= o.offsetY * n / s, i *= o.width / a, n *= o.height / s
                    }
                    var c = this.filmOffset;
                    0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = dn.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            });
            var cr = 90,
                lr = 1;

            function hr(t, e, n, i) {
                dn.call(this), this.type = "CubeCamera";
                var r = new sr(cr, lr, t, e);
                r.up.set(0, -1, 0), r.lookAt(new Ce(1, 0, 0)), this.add(r);
                var o = new sr(cr, lr, t, e);
                o.up.set(0, -1, 0), o.lookAt(new Ce(-1, 0, 0)), this.add(o);
                var a = new sr(cr, lr, t, e);
                a.up.set(0, 0, 1), a.lookAt(new Ce(0, 1, 0)), this.add(a);
                var s = new sr(cr, lr, t, e);
                s.up.set(0, 0, -1), s.lookAt(new Ce(0, -1, 0)), this.add(s);
                var c = new sr(cr, lr, t, e);
                c.up.set(0, -1, 0), c.lookAt(new Ce(0, 0, 1)), this.add(c);
                var l = new sr(cr, lr, t, e);
                l.up.set(0, -1, 0), l.lookAt(new Ce(0, 0, -1)), this.add(l), i = i || {
                    format: At,
                    magFilter: ut,
                    minFilter: ut
                }, this.renderTarget = new ur(n, n, i), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = t.getRenderTarget(),
                        i = this.renderTarget,
                        h = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, t.setRenderTarget(i, 0), t.render(e, r), t.setRenderTarget(i, 1), t.render(e, o), t.setRenderTarget(i, 2), t.render(e, a), t.setRenderTarget(i, 3), t.render(e, s), t.setRenderTarget(i, 4), t.render(e, c), i.texture.generateMipmaps = h, t.setRenderTarget(i, 5), t.render(e, l), t.setRenderTarget(n)
                }, this.clear = function(t, e, n, i) {
                    for (var r = t.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++) t.setRenderTarget(o, a), t.clear(e, n, i);
                    t.setRenderTarget(r)
                }
            }

            function ur(t, e, n) {
                ke.call(this, t, e, n)
            }

            function pr(t, e, n, i, r, o, a, s, c, l, h, u) {
                He.call(this, null, o, a, s, c, l, i, r, h, u), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1
                }, this.magFilter = void 0 !== c ? c : ct, this.minFilter = void 0 !== l ? l : ct, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
            hr.prototype = Object.create(dn.prototype), hr.prototype.constructor = hr, ur.prototype = Object.create(ke.prototype), ur.prototype.constructor = ur, ur.prototype.isWebGLRenderTargetCube = !0, ur.prototype.fromEquirectangularTexture = function(t, e) {
                this.texture.type = e.type, this.texture.format = e.format, this.texture.encoding = e.encoding;
                var n = new fn,
                    i = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
                        fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
                    },
                    r = new or({
                        type: "CubemapFromEquirect",
                        uniforms: tr(i.uniforms),
                        vertexShader: i.vertexShader,
                        fragmentShader: i.fragmentShader,
                        side: c,
                        blending: d
                    });
                r.uniforms.tEquirect.value = e;
                var o = new Vi(new $i(5, 5, 5), r);
                n.add(o);
                var a = new hr(1, 10, 1);
                return a.renderTarget = this, a.renderTarget.texture.name = "CubeCameraTexture", a.update(t, n), o.geometry.dispose(), o.material.dispose(), this
            }, pr.prototype = Object.create(He.prototype), pr.prototype.constructor = pr, pr.prototype.isDataTexture = !0;
            var dr = new Ce,
                fr = new Ce,
                mr = new De;

            function vr(t, e) {
                this.normal = void 0 !== t ? t : new Ce(1, 0, 0), this.constant = void 0 !== e ? e : 0
            }
            Object.assign(vr.prototype, {
                isPlane: !0,
                set: function(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                },
                setComponents: function(t, e, n, i) {
                    return this.normal.set(t, e, n), this.constant = i, this
                },
                setFromNormalAndCoplanarPoint: function(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                },
                setFromCoplanarPoints: function(t, e, n) {
                    var i = dr.subVectors(n, e).cross(fr.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, t), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                },
                normalize: function() {
                    var t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(t) {
                    return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function(t) {
                    return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Ce), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                },
                intersectLine: function(t, e) {
                    void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new Ce);
                    var n = t.delta(dr),
                        i = this.normal.dot(n);
                    if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                    var r = -(t.start.dot(this.normal) + this.constant) / i;
                    return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
                },
                intersectsLine: function(t) {
                    var e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return e < 0 && n > 0 || n < 0 && e > 0
                },
                intersectsBox: function(t) {
                    return t.intersectsPlane(this)
                },
                intersectsSphere: function(t) {
                    return t.intersectsPlane(this)
                },
                coplanarPoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Ce), t.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function(t, e) {
                    var n = e || mr.getNormalMatrix(t),
                        i = this.coplanarPoint(dr).applyMatrix4(t),
                        r = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -i.dot(r), this
                },
                translate: function(t) {
                    return this.constant -= t.dot(this.normal), this
                },
                equals: function(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            });
            var gr = new Rn,
                yr = new Ce;

            function _r(t, e, n, i, r, o) {
                this.planes = [void 0 !== t ? t : new vr, void 0 !== e ? e : new vr, void 0 !== n ? n : new vr, void 0 !== i ? i : new vr, void 0 !== r ? r : new vr, void 0 !== o ? o : new vr]
            }
            Object.assign(_r.prototype, {
                set: function(t, e, n, i, r, o) {
                    var a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this
                },
                setFromMatrix: function(t) {
                    var e = this.planes,
                        n = t.elements,
                        i = n[0],
                        r = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        c = n[5],
                        l = n[6],
                        h = n[7],
                        u = n[8],
                        p = n[9],
                        d = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return e[0].setComponents(a - i, h - s, f - u, y - m).normalize(), e[1].setComponents(a + i, h + s, f + u, y + m).normalize(), e[2].setComponents(a + r, h + c, f + p, y + v).normalize(), e[3].setComponents(a - r, h - c, f - p, y - v).normalize(), e[4].setComponents(a - o, h - l, f - d, y - g).normalize(), e[5].setComponents(a + o, h + l, f + d, y + g).normalize(), this
                },
                intersectsObject: function(t) {
                    var e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(), gr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(gr)
                },
                intersectsSprite: function(t) {
                    return gr.center.set(0, 0, 0), gr.radius = .7071067811865476, gr.applyMatrix4(t.matrixWorld), this.intersectsSphere(gr)
                },
                intersectsSphere: function(t) {
                    for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                        var o = e[r].distanceToPoint(n);
                        if (o < i) return !1
                    }
                    return !0
                },
                intersectsBox: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++) {
                        var i = e[n];
                        if (yr.x = i.normal.x > 0 ? t.max.x : t.min.x, yr.y = i.normal.y > 0 ? t.max.y : t.min.y, yr.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(yr) < 0) return !1
                    }
                    return !0
                },
                containsPoint: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++)
                        if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            });
            var xr = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                    common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
                    map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
                    clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                    uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                },
                br = {
                    common: {
                        diffuse: {
                            value: new $n(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new De
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Ae(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new $n(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new $n(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new De
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new $n(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Ae(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new De
                        }
                    }
                },
                wr = {
                    basic: {
                        uniforms: er([br.common, br.specularmap, br.envmap, br.aomap, br.lightmap, br.fog]),
                        vertexShader: xr.meshbasic_vert,
                        fragmentShader: xr.meshbasic_frag
                    },
                    lambert: {
                        uniforms: er([br.common, br.specularmap, br.envmap, br.aomap, br.lightmap, br.emissivemap, br.fog, br.lights, {
                            emissive: {
                                value: new $n(0)
                            }
                        }]),
                        vertexShader: xr.meshlambert_vert,
                        fragmentShader: xr.meshlambert_frag
                    },
                    phong: {
                        uniforms: er([br.common, br.specularmap, br.envmap, br.aomap, br.lightmap, br.emissivemap, br.bumpmap, br.normalmap, br.displacementmap, br.gradientmap, br.fog, br.lights, {
                            emissive: {
                                value: new $n(0)
                            },
                            specular: {
                                value: new $n(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: xr.meshphong_vert,
                        fragmentShader: xr.meshphong_frag
                    },
                    standard: {
                        uniforms: er([br.common, br.envmap, br.aomap, br.lightmap, br.emissivemap, br.bumpmap, br.normalmap, br.displacementmap, br.roughnessmap, br.metalnessmap, br.fog, br.lights, {
                            emissive: {
                                value: new $n(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: xr.meshphysical_vert,
                        fragmentShader: xr.meshphysical_frag
                    },
                    matcap: {
                        uniforms: er([br.common, br.bumpmap, br.normalmap, br.displacementmap, br.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: xr.meshmatcap_vert,
                        fragmentShader: xr.meshmatcap_frag
                    },
                    points: {
                        uniforms: er([br.points, br.fog]),
                        vertexShader: xr.points_vert,
                        fragmentShader: xr.points_frag
                    },
                    dashed: {
                        uniforms: er([br.common, br.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: xr.linedashed_vert,
                        fragmentShader: xr.linedashed_frag
                    },
                    depth: {
                        uniforms: er([br.common, br.displacementmap]),
                        vertexShader: xr.depth_vert,
                        fragmentShader: xr.depth_frag
                    },
                    normal: {
                        uniforms: er([br.common, br.bumpmap, br.normalmap, br.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: xr.normal_vert,
                        fragmentShader: xr.normal_frag
                    },
                    sprite: {
                        uniforms: er([br.sprite, br.fog]),
                        vertexShader: xr.sprite_vert,
                        fragmentShader: xr.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new De
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: xr.background_vert,
                        fragmentShader: xr.background_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: xr.cube_vert,
                        fragmentShader: xr.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: xr.equirect_vert,
                        fragmentShader: xr.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: er([br.common, br.displacementmap, {
                            referencePosition: {
                                value: new Ce
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: xr.distanceRGBA_vert,
                        fragmentShader: xr.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: er([br.lights, br.fog, {
                            color: {
                                value: new $n(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: xr.shadow_vert,
                        fragmentShader: xr.shadow_frag
                    }
                };

            function Mr() {
                var t = null,
                    e = !1,
                    n = null;

                function i(r, o) {
                    !1 !== e && (n(r, o), t.requestAnimationFrame(i))
                }
                return {
                    start: function() {
                        !0 !== e && null !== n && (t.requestAnimationFrame(i), e = !0)
                    },
                    stop: function() {
                        e = !1
                    },
                    setAnimationLoop: function(t) {
                        n = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function Tr(t) {
                var e = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var i = e.get(n);
                        i && (t.deleteBuffer(i.buffer), e.delete(n))
                    },
                    update: function(n, i) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var r = e.get(n);
                        void 0 === r ? e.set(n, function(e, n) {
                            var i = e.array,
                                r = e.dynamic ? 35048 : 35044,
                                o = t.createBuffer();
                            t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback();
                            var a = 5126;
                            return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), {
                                buffer: o,
                                type: a,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(n, i)) : r.version < n.version && (function(e, n, i) {
                            var r = n.array,
                                o = n.updateRange;
                            t.bindBuffer(i, e), !1 === n.dynamic ? t.bufferData(i, r, 35044) : -1 === o.count ? t.bufferSubData(i, 0, r) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(i, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(r.buffer, n, i), r.version = n.version)
                    }
                }
            }

            function Er(t, e, n, i) {
                Ki.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                }, this.fromBufferGeometry(new Sr(t, e, n, i)), this.mergeVertices()
            }

            function Sr(t, e, n, i) {
                Si.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                var r, o, a = (t = t || 1) / 2,
                    s = (e = e || 1) / 2,
                    c = Math.floor(n) || 1,
                    l = Math.floor(i) || 1,
                    h = c + 1,
                    u = l + 1,
                    p = t / c,
                    d = e / l,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (o = 0; o < u; o++) {
                    var y = o * d - s;
                    for (r = 0; r < h; r++) {
                        var _ = r * p - a;
                        m.push(_, -y, 0), v.push(0, 0, 1), g.push(r / c), g.push(1 - o / l)
                    }
                }
                for (o = 0; o < l; o++)
                    for (r = 0; r < c; r++) {
                        var x = r + h * o,
                            b = r + h * (o + 1),
                            w = r + 1 + h * (o + 1),
                            M = r + 1 + h * o;
                        f.push(x, b, M), f.push(b, w, M)
                    }
                this.setIndex(f), this.addAttribute("position", new mi(m, 3)), this.addAttribute("normal", new mi(v, 3)), this.addAttribute("uv", new mi(g, 2))
            }

            function Ar(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function Pr(t, e, n, i, r, o, a, s, c, l) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : Q, a = void 0 !== a ? a : At, He.call(this, t, e, n, i, r, o, a, s, c, l), this.flipY = !1
            }

            function Lr(t, e, n, i) {
                He.call(this, null), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                    depth: i || 1
                }, this.magFilter = ct, this.minFilter = ct, this.wrapR = at, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }

            function Rr(t, e, n, i) {
                He.call(this, null), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                    depth: i || 1
                }, this.magFilter = ct, this.minFilter = ct, this.wrapR = at, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }
            wr.physical = {
                uniforms: er([wr.standard.uniforms, {
                    transparency: {
                        value: 0
                    },
                    clearcoat: {
                        value: 0
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    sheen: {
                        value: new $n(0)
                    },
                    clearcoatNormalScale: {
                        value: new Ae(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    }
                }]),
                vertexShader: xr.meshphysical_vert,
                fragmentShader: xr.meshphysical_frag
            }, Er.prototype = Object.create(Ki.prototype), Er.prototype.constructor = Er, Sr.prototype = Object.create(Si.prototype), Sr.prototype.constructor = Sr, Pr.prototype = Object.create(He.prototype), Pr.prototype.constructor = Pr, Pr.prototype.isCubeTexture = !0, Object.defineProperty(Pr.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), Lr.prototype = Object.create(He.prototype), Lr.prototype.constructor = Lr, Lr.prototype.isDataTexture2DArray = !0, Rr.prototype = Object.create(He.prototype), Rr.prototype.constructor = Rr, Rr.prototype.isDataTexture3D = !0;
            var Cr = new He,
                Or = new Lr,
                Ir = new Rr,
                Dr = new Pr,
                Nr = [],
                Br = [],
                Hr = new Float32Array(16),
                Fr = new Float32Array(9),
                kr = new Float32Array(4);

            function Ur(t, e, n) {
                var i = t[0];
                if (i <= 0 || i > 0) return t;
                var r = e * n,
                    o = Nr[r];
                if (void 0 === o && (o = new Float32Array(r), Nr[r] = o), 0 !== e) {
                    i.toArray(o, 0);
                    for (var a = 1, s = 0; a !== e; ++a) s += n, t[a].toArray(o, s)
                }
                return o
            }

            function zr(t, e) {
                if (t.length !== e.length) return !1;
                for (var n = 0, i = t.length; n < i; n++)
                    if (t[n] !== e[n]) return !1;
                return !0
            }

            function Gr(t, e) {
                for (var n = 0, i = e.length; n < i; n++) t[n] = e[n]
            }

            function jr(t, e) {
                var n = Br[e];
                void 0 === n && (n = new Int32Array(e), Br[e] = n);
                for (var i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                return n
            }

            function Vr(t, e) {
                var n = this.cache;
                n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
            }

            function Wr(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                else {
                    if (zr(n, e)) return;
                    t.uniform2fv(this.addr, e), Gr(n, e)
                }
            }

            function Xr(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                else {
                    if (zr(n, e)) return;
                    t.uniform3fv(this.addr, e), Gr(n, e)
                }
            }

            function qr(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                else {
                    if (zr(n, e)) return;
                    t.uniform4fv(this.addr, e), Gr(n, e)
                }
            }

            function Yr(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (zr(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), Gr(n, e)
                } else {
                    if (zr(n, i)) return;
                    kr.set(i), t.uniformMatrix2fv(this.addr, !1, kr), Gr(n, i)
                }
            }

            function Zr(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (zr(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), Gr(n, e)
                } else {
                    if (zr(n, i)) return;
                    Fr.set(i), t.uniformMatrix3fv(this.addr, !1, Fr), Gr(n, i)
                }
            }

            function Jr(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (zr(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), Gr(n, e)
                } else {
                    if (zr(n, i)) return;
                    Hr.set(i), t.uniformMatrix4fv(this.addr, !1, Hr), Gr(n, i)
                }
            }

            function Kr(t, e, n) {
                var i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || Cr, r)
            }

            function Qr(t, e, n) {
                var i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Or, r)
            }

            function $r(t, e, n) {
                var i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Ir, r)
            }

            function to(t, e, n) {
                var i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Dr, r)
            }

            function eo(t, e) {
                var n = this.cache;
                n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
            }

            function no(t, e) {
                var n = this.cache;
                zr(n, e) || (t.uniform2iv(this.addr, e), Gr(n, e))
            }

            function io(t, e) {
                var n = this.cache;
                zr(n, e) || (t.uniform3iv(this.addr, e), Gr(n, e))
            }

            function ro(t, e) {
                var n = this.cache;
                zr(n, e) || (t.uniform4iv(this.addr, e), Gr(n, e))
            }

            function oo(t, e) {
                t.uniform1fv(this.addr, e)
            }

            function ao(t, e) {
                t.uniform1iv(this.addr, e)
            }

            function so(t, e) {
                t.uniform2iv(this.addr, e)
            }

            function co(t, e) {
                t.uniform3iv(this.addr, e)
            }

            function lo(t, e) {
                t.uniform4iv(this.addr, e)
            }

            function ho(t, e) {
                var n = Ur(e, this.size, 2);
                t.uniform2fv(this.addr, n)
            }

            function uo(t, e) {
                var n = Ur(e, this.size, 3);
                t.uniform3fv(this.addr, n)
            }

            function po(t, e) {
                var n = Ur(e, this.size, 4);
                t.uniform4fv(this.addr, n)
            }

            function fo(t, e) {
                var n = Ur(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, n)
            }

            function mo(t, e) {
                var n = Ur(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, n)
            }

            function vo(t, e) {
                var n = Ur(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, n)
            }

            function go(t, e, n) {
                var i = e.length,
                    r = jr(n, i);
                t.uniform1iv(this.addr, r);
                for (var o = 0; o !== i; ++o) n.safeSetTexture2D(e[o] || Cr, r[o])
            }

            function yo(t, e, n) {
                var i = e.length,
                    r = jr(n, i);
                t.uniform1iv(this.addr, r);
                for (var o = 0; o !== i; ++o) n.safeSetTextureCube(e[o] || Dr, r[o])
            }

            function _o(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Vr;
                        case 35664:
                            return Wr;
                        case 35665:
                            return Xr;
                        case 35666:
                            return qr;
                        case 35674:
                            return Yr;
                        case 35675:
                            return Zr;
                        case 35676:
                            return Jr;
                        case 35678:
                        case 36198:
                            return Kr;
                        case 35679:
                            return $r;
                        case 35680:
                            return to;
                        case 36289:
                            return Qr;
                        case 5124:
                        case 35670:
                            return eo;
                        case 35667:
                        case 35671:
                            return no;
                        case 35668:
                        case 35672:
                            return io;
                        case 35669:
                        case 35673:
                            return ro
                    }
                }(e.type)
            }

            function xo(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return oo;
                        case 35664:
                            return ho;
                        case 35665:
                            return uo;
                        case 35666:
                            return po;
                        case 35674:
                            return fo;
                        case 35675:
                            return mo;
                        case 35676:
                            return vo;
                        case 35678:
                            return go;
                        case 35680:
                            return yo;
                        case 5124:
                        case 35670:
                            return ao;
                        case 35667:
                        case 35671:
                            return so;
                        case 35668:
                        case 35672:
                            return co;
                        case 35669:
                        case 35673:
                            return lo
                    }
                }(e.type)
            }

            function bo(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            xo.prototype.updateCache = function(t) {
                var e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Gr(e, t)
            }, bo.prototype.setValue = function(t, e, n) {
                for (var i = this.seq, r = 0, o = i.length; r !== o; ++r) {
                    var a = i[r];
                    a.setValue(t, e[a.id], n)
                }
            };
            var wo = /([\w\d_]+)(\])?(\[|\.)?/g;

            function Mo(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function To(t, e, n) {
                var i = t.name,
                    r = i.length;
                for (wo.lastIndex = 0;;) {
                    var o = wo.exec(i),
                        a = wo.lastIndex,
                        s = o[1],
                        c = "]" === o[2],
                        l = o[3];
                    if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === r) {
                        Mo(n, void 0 === l ? new _o(s, t, e) : new xo(s, t, e));
                        break
                    }
                    var h = n.map,
                        u = h[s];
                    void 0 === u && (u = new bo(s), Mo(n, u)), n = u
                }
            }

            function Eo(t, e) {
                this.seq = [], this.map = {};
                for (var n = t.getProgramParameter(e, 35718), i = 0; i < n; ++i) {
                    var r = t.getActiveUniform(e, i),
                        o = t.getUniformLocation(e, r.name);
                    To(r, o, this)
                }
            }

            function So(t, e, n) {
                var i = t.createShader(e);
                return t.shaderSource(i, n), t.compileShader(i), i
            }
            Eo.prototype.setValue = function(t, e, n, i) {
                var r = this.map[e];
                void 0 !== r && r.setValue(t, n, i)
            }, Eo.prototype.setOptional = function(t, e, n) {
                var i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }, Eo.upload = function(t, e, n, i) {
                for (var r = 0, o = e.length; r !== o; ++r) {
                    var a = e[r],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(t, s.value, i)
                }
            }, Eo.seqWithValue = function(t, e) {
                for (var n = [], i = 0, r = t.length; i !== r; ++i) {
                    var o = t[i];
                    o.id in e && n.push(o)
                }
                return n
            };
            var Ao = 0;

            function Po(t) {
                switch (t) {
                    case le:
                        return ["Linear", "( value )"];
                    case he:
                        return ["sRGB", "( value )"];
                    case pe:
                        return ["RGBE", "( value )"];
                    case fe:
                        return ["RGBM", "( value, 7.0 )"];
                    case me:
                        return ["RGBM", "( value, 16.0 )"];
                    case ve:
                        return ["RGBD", "( value, 256.0 )"];
                    case ue:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case de:
                        return ["LogLuv", "( value )"];
                    default:
                        throw new Error("unsupported encoding: " + t)
                }
            }

            function Lo(t, e, n) {
                var i = t.getShaderParameter(e, 35713),
                    r = t.getShaderInfoLog(e).trim();
                if (i && "" === r) return "";
                var o = t.getShaderSource(e);
                return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) {
                    for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                    return e.join("\n")
                }(o)
            }

            function Ro(t, e) {
                var n = Po(e);
                return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function Co(t) {
                return "" !== t
            }

            function Oo(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
            }

            function Io(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }
            var Do = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function No(t) {
                return t.replace(Do, Bo)
            }

            function Bo(t, e) {
                var n = xr[e];
                if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                return No(n)
            }
            var Ho = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

            function Fo(t) {
                return t.replace(Ho, ko)
            }

            function ko(t, e, n, i) {
                for (var r = "", o = parseInt(e); o < parseInt(n); o++) r += i.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
                return r
            }

            function Uo(t) {
                var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
            }

            function zo(t, e, n, i, s, c) {
                var l, h, u = t.getContext(),
                    p = i.defines,
                    d = s.vertexShader,
                    f = s.fragmentShader,
                    m = function(t) {
                        var e = "SHADOWMAP_TYPE_BASIC";
                        return t.shadowMapType === r ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === o ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === a && (e = "SHADOWMAP_TYPE_VSM"), e
                    }(c),
                    v = function(t, e) {
                        var n = "ENVMAP_TYPE_CUBE";
                        if (t.envMap) switch (e.envMap.mapping) {
                            case Q:
                            case $:
                                n = "ENVMAP_TYPE_CUBE";
                                break;
                            case it:
                            case rt:
                                n = "ENVMAP_TYPE_CUBE_UV";
                                break;
                            case tt:
                            case et:
                                n = "ENVMAP_TYPE_EQUIREC";
                                break;
                            case nt:
                                n = "ENVMAP_TYPE_SPHERE"
                        }
                        return n
                    }(c, i),
                    g = function(t, e) {
                        var n = "ENVMAP_MODE_REFLECTION";
                        if (t.envMap) switch (e.envMap.mapping) {
                            case $:
                            case et:
                                n = "ENVMAP_MODE_REFRACTION"
                        }
                        return n
                    }(c, i),
                    y = function(t, e) {
                        var n = "ENVMAP_BLENDING_MULTIPLY";
                        if (t.envMap) switch (e.combine) {
                            case j:
                                n = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case V:
                                n = "ENVMAP_BLENDING_MIX";
                                break;
                            case W:
                                n = "ENVMAP_BLENDING_ADD"
                        }
                        return n
                    }(c, i),
                    _ = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    x = c.isWebGL2 ? "" : function(t, e, n) {
                        return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Co).join("\n")
                    }(i.extensions, c, e),
                    b = function(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            !1 !== i && e.push("#define " + n + " " + i)
                        }
                        return e.join("\n")
                    }(p),
                    w = u.createProgram(),
                    M = t.getRenderTarget(),
                    T = M && M.isWebGLMultiviewRenderTarget ? M.numViews : 0;
                if (i.isRawShaderMaterial ? ((l = [b].filter(Co).join("\n")).length > 0 && (l += "\n"), (h = [x, b].filter(Co).join("\n")).length > 0 && (h += "\n")) : (l = [Uo(c), "#define SHADER_NAME " + s.name, b, c.instancing ? "#define USE_INSTANCING" : "", c.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + c.maxBones, c.useFog && c.fog ? "#define USE_FOG" : "", c.useFog && c.fogExp2 ? "#define FOG_EXP2" : "", c.map ? "#define USE_MAP" : "", c.envMap ? "#define USE_ENVMAP" : "", c.envMap ? "#define " + g : "", c.lightMap ? "#define USE_LIGHTMAP" : "", c.aoMap ? "#define USE_AOMAP" : "", c.emissiveMap ? "#define USE_EMISSIVEMAP" : "", c.bumpMap ? "#define USE_BUMPMAP" : "", c.normalMap ? "#define USE_NORMALMAP" : "", c.normalMap && c.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", c.normalMap && c.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", c.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", c.displacementMap && c.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", c.specularMap ? "#define USE_SPECULARMAP" : "", c.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", c.metalnessMap ? "#define USE_METALNESSMAP" : "", c.alphaMap ? "#define USE_ALPHAMAP" : "", c.vertexTangents ? "#define USE_TANGENT" : "", c.vertexColors ? "#define USE_COLOR" : "", c.vertexUvs ? "#define USE_UV" : "", c.flatShading ? "#define FLAT_SHADED" : "", c.skinning ? "#define USE_SKINNING" : "", c.useVertexTexture ? "#define BONE_TEXTURE" : "", c.morphTargets ? "#define USE_MORPHTARGETS" : "", c.morphNormals && !1 === c.flatShading ? "#define USE_MORPHNORMALS" : "", c.doubleSided ? "#define DOUBLE_SIDED" : "", c.flipSided ? "#define FLIP_SIDED" : "", c.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", c.shadowMapEnabled ? "#define " + m : "", c.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", c.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", c.logarithmicDepthBuffer && (c.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Co).join("\n"), h = [x, Uo(c), "#define SHADER_NAME " + s.name, b, c.alphaTest ? "#define ALPHATEST " + c.alphaTest + (c.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + _, c.useFog && c.fog ? "#define USE_FOG" : "", c.useFog && c.fogExp2 ? "#define FOG_EXP2" : "", c.map ? "#define USE_MAP" : "", c.matcap ? "#define USE_MATCAP" : "", c.envMap ? "#define USE_ENVMAP" : "", c.envMap ? "#define " + v : "", c.envMap ? "#define " + g : "", c.envMap ? "#define " + y : "", c.lightMap ? "#define USE_LIGHTMAP" : "", c.aoMap ? "#define USE_AOMAP" : "", c.emissiveMap ? "#define USE_EMISSIVEMAP" : "", c.bumpMap ? "#define USE_BUMPMAP" : "", c.normalMap ? "#define USE_NORMALMAP" : "", c.normalMap && c.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", c.normalMap && c.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", c.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", c.specularMap ? "#define USE_SPECULARMAP" : "", c.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", c.metalnessMap ? "#define USE_METALNESSMAP" : "", c.alphaMap ? "#define USE_ALPHAMAP" : "", c.sheen ? "#define USE_SHEEN" : "", c.vertexTangents ? "#define USE_TANGENT" : "", c.vertexColors ? "#define USE_COLOR" : "", c.vertexUvs ? "#define USE_UV" : "", c.gradientMap ? "#define USE_GRADIENTMAP" : "", c.flatShading ? "#define FLAT_SHADED" : "", c.doubleSided ? "#define DOUBLE_SIDED" : "", c.flipSided ? "#define FLIP_SIDED" : "", c.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", c.shadowMapEnabled ? "#define " + m : "", c.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", c.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", c.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", c.logarithmicDepthBuffer && (c.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensions && i.extensions.shaderTextureLOD || c.envMap) && (c.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", c.toneMapping !== X ? "#define TONE_MAPPING" : "", c.toneMapping !== X ? xr.tonemapping_pars_fragment : "", c.toneMapping !== X ? function(t, e) {
                        var n;
                        switch (e) {
                            case q:
                                n = "Linear";
                                break;
                            case Y:
                                n = "Reinhard";
                                break;
                            case Z:
                                n = "Uncharted2";
                                break;
                            case J:
                                n = "OptimizedCineon";
                                break;
                            case K:
                                n = "ACESFilmic";
                                break;
                            default:
                                throw new Error("unsupported toneMapping: " + e)
                        }
                        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                    }("toneMapping", c.toneMapping) : "", c.dithering ? "#define DITHERING" : "", c.outputEncoding || c.mapEncoding || c.matcapEncoding || c.envMapEncoding || c.emissiveMapEncoding ? xr.encodings_pars_fragment : "", c.mapEncoding ? Ro("mapTexelToLinear", c.mapEncoding) : "", c.matcapEncoding ? Ro("matcapTexelToLinear", c.matcapEncoding) : "", c.envMapEncoding ? Ro("envMapTexelToLinear", c.envMapEncoding) : "", c.emissiveMapEncoding ? Ro("emissiveMapTexelToLinear", c.emissiveMapEncoding) : "", c.outputEncoding ? function(t, e) {
                        var n = Po(e);
                        return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                    }("linearToOutputTexel", c.outputEncoding) : "", c.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Co).join("\n")), d = Io(d = Oo(d = No(d), c), c), f = Io(f = Oo(f = No(f), c), c), d = Fo(d), f = Fo(f), c.isWebGL2 && !i.isRawShaderMaterial) {
                    var E = !1,
                        S = /^\s*#version\s+300\s+es\s*\n/;
                    i.isShaderMaterial && null !== d.match(S) && null !== f.match(S) && (E = !0, d = d.replace(S, ""), f = f.replace(S, "")), l = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + l, h = ["#version 300 es\n", "#define varying in", E ? "" : "out highp vec4 pc_fragColor;", E ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + h, T > 0 && (l = (l = l.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "layout(num_views = " + T + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join("\n"), ["uniform mat4 modelViewMatrices[" + T + "];", "uniform mat4 projectionMatrices[" + T + "];", "uniform mat4 viewMatrices[" + T + "];", "uniform mat3 normalMatrices[" + T + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), h = (h = h.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + T + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n")))
                }
                var A, P, L = l + d,
                    R = h + f,
                    C = So(u, 35633, L),
                    O = So(u, 35632, R);
                if (u.attachShader(w, C), u.attachShader(w, O), void 0 !== i.index0AttributeName ? u.bindAttribLocation(w, 0, i.index0AttributeName) : !0 === c.morphTargets && u.bindAttribLocation(w, 0, "position"), u.linkProgram(w), t.debug.checkShaderErrors) {
                    var I = u.getProgramInfoLog(w).trim(),
                        D = u.getShaderInfoLog(C).trim(),
                        N = u.getShaderInfoLog(O).trim(),
                        B = !0,
                        H = !0;
                    if (!1 === u.getProgramParameter(w, 35714)) {
                        B = !1;
                        var F = Lo(u, C, "vertex"),
                            k = Lo(u, O, "fragment");
                        console.error("THREE.WebGLProgram: shader error: ", u.getError(), "35715", u.getProgramParameter(w, 35715), "gl.getProgramInfoLog", I, F, k)
                    } else "" !== I ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", I) : "" !== D && "" !== N || (H = !1);
                    H && (this.diagnostics = {
                        runnable: B,
                        material: i,
                        programLog: I,
                        vertexShader: {
                            log: D,
                            prefix: l
                        },
                        fragmentShader: {
                            log: N,
                            prefix: h
                        }
                    })
                }
                return u.deleteShader(C), u.deleteShader(O), this.getUniforms = function() {
                    return void 0 === A && (A = new Eo(u, w)), A
                }, this.getAttributes = function() {
                    return void 0 === P && (P = function(t, e) {
                        for (var n = {}, i = t.getProgramParameter(e, 35721), r = 0; r < i; r++) {
                            var o = t.getActiveAttrib(e, r),
                                a = o.name;
                            n[a] = t.getAttribLocation(e, a)
                        }
                        return n
                    }(u, w)), P
                }, this.destroy = function() {
                    u.deleteProgram(w), this.program = void 0
                }, this.name = s.name, this.id = Ao++, this.code = n, this.usedTimes = 1, this.program = w, this.vertexShader = C, this.fragmentShader = O, this.numMultiviewViews = T, this
            }

            function Go(t, e, n) {
                var i = [],
                    r = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    o = ["precision", "supportsVertexTextures", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

                function a(t, e) {
                    var n;
                    return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = le, n === le && e && (n = ue), n
                }
                this.getParameters = function(e, i, o, s, h, u, p) {
                    var d = r[e.type],
                        f = p.isSkinnedMesh ? function(t) {
                            var e = t.skeleton.bones;
                            if (n.floatVertexTextures) return 1024;
                            var i = n.maxVertexUniforms,
                                r = Math.floor((i - 20) / 4),
                                o = Math.min(r, e.length);
                            return o < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + o + "."), 0) : o
                        }(p) : 0,
                        m = n.precision;
                    null !== e.precision && (m = n.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", m, "instead.");
                    var v = t.getRenderTarget(),
                        g = {
                            isWebGL2: n.isWebGL2,
                            shaderID: d,
                            precision: m,
                            instancing: !0 === p.isInstancedMesh,
                            supportsVertexTextures: n.vertexTextures,
                            outputEncoding: a(v ? v.texture : null, t.gammaOutput),
                            map: !!e.map,
                            mapEncoding: a(e.map, t.gammaInput),
                            matcap: !!e.matcap,
                            matcapEncoding: a(e.matcap, t.gammaInput),
                            envMap: !!e.envMap,
                            envMapMode: e.envMap && e.envMap.mapping,
                            envMapEncoding: a(e.envMap, t.gammaInput),
                            envMapCubeUV: !!e.envMap && (e.envMap.mapping === it || e.envMap.mapping === rt),
                            lightMap: !!e.lightMap,
                            aoMap: !!e.aoMap,
                            emissiveMap: !!e.emissiveMap,
                            emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
                            bumpMap: !!e.bumpMap,
                            normalMap: !!e.normalMap,
                            objectSpaceNormalMap: e.normalMapType === xe,
                            tangentSpaceNormalMap: e.normalMapType === _e,
                            clearcoatNormalMap: !!e.clearcoatNormalMap,
                            displacementMap: !!e.displacementMap,
                            roughnessMap: !!e.roughnessMap,
                            metalnessMap: !!e.metalnessMap,
                            specularMap: !!e.specularMap,
                            alphaMap: !!e.alphaMap,
                            gradientMap: !!e.gradientMap,
                            sheen: !!e.sheen,
                            combine: e.combine,
                            vertexTangents: e.normalMap && e.vertexTangents,
                            vertexColors: e.vertexColors,
                            vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap),
                            fog: !!s,
                            useFog: e.fog,
                            fogExp2: s && s.isFogExp2,
                            flatShading: e.flatShading,
                            sizeAttenuation: e.sizeAttenuation,
                            logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                            skinning: e.skinning && f > 0,
                            maxBones: f,
                            useVertexTexture: n.floatVertexTextures,
                            morphTargets: e.morphTargets,
                            morphNormals: e.morphNormals,
                            maxMorphTargets: t.maxMorphTargets,
                            maxMorphNormals: t.maxMorphNormals,
                            numDirLights: i.directional.length,
                            numPointLights: i.point.length,
                            numSpotLights: i.spot.length,
                            numRectAreaLights: i.rectArea.length,
                            numHemiLights: i.hemi.length,
                            numDirLightShadows: i.directionalShadowMap.length,
                            numPointLightShadows: i.pointShadowMap.length,
                            numSpotLightShadows: i.spotShadowMap.length,
                            numClippingPlanes: h,
                            numClipIntersection: u,
                            dithering: e.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && o.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: e.toneMapped ? t.toneMapping : X,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: e.premultipliedAlpha,
                            alphaTest: e.alphaTest,
                            doubleSided: e.side === l,
                            flipSided: e.side === c,
                            depthPacking: void 0 !== e.depthPacking && e.depthPacking
                        };
                    return g
                }, this.getProgramCode = function(e, n) {
                    var i = [];
                    if (n.shaderID ? i.push(n.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) i.push(r), i.push(e.defines[r]);
                    for (var a = 0; a < o.length; a++) i.push(n[o[a]]);
                    return i.push(e.onBeforeCompile.toString()), i.push(t.gammaOutput), i.push(t.gammaFactor), i.join()
                }, this.acquireProgram = function(n, r, o, a) {
                    for (var s, c = 0, l = i.length; c < l; c++) {
                        var h = i[c];
                        if (h.code === a) {
                            ++(s = h).usedTimes;
                            break
                        }
                    }
                    return void 0 === s && (s = new zo(t, e, a, n, r, o), i.push(s)), s
                }, this.releaseProgram = function(t) {
                    if (0 == --t.usedTimes) {
                        var e = i.indexOf(t);
                        i[e] = i[i.length - 1], i.pop(), t.destroy()
                    }
                }, this.programs = i
            }

            function jo(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function Vo(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Wo() {
                var t = [],
                    e = 0,
                    n = [],
                    i = [],
                    r = {
                        id: -1
                    };

                function o(n, i, o, a, s, c) {
                    var l = t[e];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: i,
                        material: o,
                        program: o.program || r,
                        groupOrder: a,
                        renderOrder: n.renderOrder,
                        z: s,
                        group: c
                    }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = o, l.program = o.program || r, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = s, l.group = c), e++, l
                }
                return {
                    opaque: n,
                    transparent: i,
                    init: function() {
                        e = 0, n.length = 0, i.length = 0
                    },
                    push: function(t, e, r, a, s, c) {
                        var l = o(t, e, r, a, s, c);
                        (!0 === r.transparent ? i : n).push(l)
                    },
                    unshift: function(t, e, r, a, s, c) {
                        var l = o(t, e, r, a, s, c);
                        (!0 === r.transparent ? i : n).unshift(l)
                    },
                    sort: function() {
                        n.length > 1 && n.sort(jo), i.length > 1 && i.sort(Vo)
                    }
                }
            }
            var Xo = 0;

            function qo(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
            }

            function Yo() {
                for (var t = new function() {
                        var t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                var n;
                                switch (e.type) {
                                    case "DirectionalLight":
                                        n = {
                                            direction: new Ce,
                                            color: new $n,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ae
                                        };
                                        break;
                                    case "SpotLight":
                                        n = {
                                            position: new Ce,
                                            direction: new Ce,
                                            color: new $n,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ae
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            position: new Ce,
                                            color: new $n,
                                            distance: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ae,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        };
                                        break;
                                    case "HemisphereLight":
                                        n = {
                                            direction: new Ce,
                                            skyColor: new $n,
                                            groundColor: new $n
                                        };
                                        break;
                                    case "RectAreaLight":
                                        n = {
                                            color: new $n,
                                            position: new Ce,
                                            halfWidth: new Ce,
                                            halfHeight: new Ce
                                        }
                                }
                                return t[e.id] = n, n
                            }
                        }
                    }, e = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    }, n = 0; n < 9; n++) e.probe.push(new Ce);
                var i = new Ce,
                    r = new Ye,
                    o = new Ye;
                return {
                    setup: function(n, a, s) {
                        for (var c = 0, l = 0, h = 0, u = 0; u < 9; u++) e.probe[u].set(0, 0, 0);
                        var p = 0,
                            d = 0,
                            f = 0,
                            m = 0,
                            v = 0,
                            g = 0,
                            y = 0,
                            _ = 0,
                            x = s.matrixWorldInverse;
                        n.sort(qo);
                        for (var u = 0, b = n.length; u < b; u++) {
                            var w = n[u],
                                M = w.color,
                                T = w.intensity,
                                E = w.distance,
                                S = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
                            if (w.isAmbientLight) c += M.r * T, l += M.g * T, h += M.b * T;
                            else if (w.isLightProbe)
                                for (var A = 0; A < 9; A++) e.probe[A].addScaledVector(w.sh.coefficients[A], T);
                            else if (w.isDirectionalLight) {
                                var P = t.get(w);
                                if (P.color.copy(w.color).multiplyScalar(w.intensity), P.direction.setFromMatrixPosition(w.matrixWorld), i.setFromMatrixPosition(w.target.matrixWorld), P.direction.sub(i), P.direction.transformDirection(x), P.shadow = w.castShadow, w.castShadow) {
                                    var L = w.shadow;
                                    P.shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, e.directionalShadowMap[p] = S, e.directionalShadowMatrix[p] = w.shadow.matrix, g++
                                }
                                e.directional[p] = P, p++
                            } else if (w.isSpotLight) {
                                var P = t.get(w);
                                if (P.position.setFromMatrixPosition(w.matrixWorld), P.position.applyMatrix4(x), P.color.copy(M).multiplyScalar(T), P.distance = E, P.direction.setFromMatrixPosition(w.matrixWorld), i.setFromMatrixPosition(w.target.matrixWorld), P.direction.sub(i), P.direction.transformDirection(x), P.coneCos = Math.cos(w.angle), P.penumbraCos = Math.cos(w.angle * (1 - w.penumbra)), P.decay = w.decay, P.shadow = w.castShadow, w.castShadow) {
                                    var L = w.shadow;
                                    P.shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, e.spotShadowMap[f] = S, e.spotShadowMatrix[f] = w.shadow.matrix, _++
                                }
                                e.spot[f] = P, f++
                            } else if (w.isRectAreaLight) {
                                var P = t.get(w);
                                P.color.copy(M).multiplyScalar(T), P.position.setFromMatrixPosition(w.matrixWorld), P.position.applyMatrix4(x), o.identity(), r.copy(w.matrixWorld), r.premultiply(x), o.extractRotation(r), P.halfWidth.set(.5 * w.width, 0, 0), P.halfHeight.set(0, .5 * w.height, 0), P.halfWidth.applyMatrix4(o), P.halfHeight.applyMatrix4(o), e.rectArea[m] = P, m++
                            } else if (w.isPointLight) {
                                var P = t.get(w);
                                if (P.position.setFromMatrixPosition(w.matrixWorld), P.position.applyMatrix4(x), P.color.copy(w.color).multiplyScalar(w.intensity), P.distance = w.distance, P.decay = w.decay, P.shadow = w.castShadow, w.castShadow) {
                                    var L = w.shadow;
                                    P.shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, P.shadowCameraNear = L.camera.near, P.shadowCameraFar = L.camera.far, e.pointShadowMap[d] = S, e.pointShadowMatrix[d] = w.shadow.matrix, y++
                                }
                                e.point[d] = P, d++
                            } else if (w.isHemisphereLight) {
                                var P = t.get(w);
                                P.direction.setFromMatrixPosition(w.matrixWorld), P.direction.transformDirection(x), P.direction.normalize(), P.skyColor.copy(w.color).multiplyScalar(T), P.groundColor.copy(w.groundColor).multiplyScalar(T), e.hemi[v] = P, v++
                            }
                        }
                        e.ambient[0] = c, e.ambient[1] = l, e.ambient[2] = h;
                        var R = e.hash;
                        R.directionalLength === p && R.pointLength === d && R.spotLength === f && R.rectAreaLength === m && R.hemiLength === v && R.numDirectionalShadows === g && R.numPointShadows === y && R.numSpotShadows === _ || (e.directional.length = p, e.spot.length = f, e.rectArea.length = m, e.point.length = d, e.hemi.length = v, e.directionalShadowMap.length = g, e.pointShadowMap.length = y, e.spotShadowMap.length = _, e.directionalShadowMatrix.length = g, e.pointShadowMatrix.length = y, e.spotShadowMatrix.length = _, R.directionalLength = p, R.pointLength = d, R.spotLength = f, R.rectAreaLength = m, R.hemiLength = v, R.numDirectionalShadows = g, R.numPointShadows = y, R.numSpotShadows = _, e.version = Xo++)
                    },
                    state: e
                }
            }

            function Zo() {
                var t = new Yo,
                    e = [],
                    n = [],
                    i = {
                        lightsArray: e,
                        shadowsArray: n,
                        lights: t
                    };
                return {
                    init: function() {
                        e.length = 0, n.length = 0
                    },
                    state: i,
                    setupLights: function(i) {
                        t.setup(e, n, i)
                    },
                    pushLight: function(t) {
                        e.push(t)
                    },
                    pushShadow: function(t) {
                        n.push(t)
                    }
                }
            }

            function Jo(t) {
                oi.call(this), this.type = "MeshDepthMaterial", this.depthPacking = ge, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
            }

            function Ko(t) {
                oi.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Ce, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
            }
            Jo.prototype = Object.create(oi.prototype), Jo.prototype.constructor = Jo, Jo.prototype.isMeshDepthMaterial = !0, Jo.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, Ko.prototype = Object.create(oi.prototype), Ko.prototype.constructor = Ko, Ko.prototype.isMeshDistanceMaterial = !0, Ko.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            };
            var Qo = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}",
                $o = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

            function ta(t, e, n) {
                var i = new _r,
                    o = new Ae,
                    h = new Ae,
                    u = new Fe,
                    p = 1,
                    f = 2,
                    m = 1 + (p | f),
                    v = new Array(m),
                    g = new Array(m),
                    y = {},
                    _ = {
                        0: c,
                        1: s,
                        2: l
                    },
                    x = new or({
                        defines: {
                            SAMPLE_RATE: .25,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Ae
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: $o,
                        fragmentShader: Qo
                    }),
                    b = x.clone();
                b.defines.HORIZONAL_PASS = 1;
                var w = new Si;
                w.addAttribute("position", new si(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                for (var M = new Vi(w, x), T = 0; T !== m; ++T) {
                    var E = 0 != (T & p),
                        S = 0 != (T & f),
                        A = new Jo({
                            depthPacking: ye,
                            morphTargets: E,
                            skinning: S
                        });
                    v[T] = A;
                    var P = new Ko({
                        morphTargets: E,
                        skinning: S
                    });
                    g[T] = P
                }
                var L = this;

                function R(n, i) {
                    var r = e.update(M);
                    x.uniforms.shadow_pass.value = n.map.texture, x.uniforms.resolution.value = n.mapSize, x.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, x, M, null), b.uniforms.shadow_pass.value = n.mapPass.texture, b.uniforms.resolution.value = n.mapSize, b.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, b, M, null)
                }

                function C(e, n, i, r, o, s) {
                    var c = e.geometry,
                        l = null,
                        h = v,
                        u = e.customDepthMaterial;
                    if (i.isPointLight && (h = g, u = e.customDistanceMaterial), u) l = u;
                    else {
                        var d = !1;
                        n.morphTargets && (c && c.isBufferGeometry ? d = c.morphAttributes && c.morphAttributes.position && c.morphAttributes.position.length > 0 : c && c.isGeometry && (d = c.morphTargets && c.morphTargets.length > 0)), e.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                        var m = e.isSkinnedMesh && n.skinning,
                            x = 0;
                        d && (x |= p), m && (x |= f), l = h[x]
                    }
                    if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                        var b = l.uuid,
                            w = n.uuid,
                            M = y[b];
                        void 0 === M && (M = {}, y[b] = M);
                        var T = M[w];
                        void 0 === T && (T = l.clone(), M[w] = T), l = T
                    }
                    return l.visible = n.visible, l.wireframe = n.wireframe, l.side = s === a ? null != n.shadowSide ? n.shadowSide : n.side : null != n.shadowSide ? n.shadowSide : _[n.side], l.clipShadows = n.clipShadows, l.clippingPlanes = n.clippingPlanes, l.clipIntersection = n.clipIntersection, l.wireframeLinewidth = n.wireframeLinewidth, l.linewidth = n.linewidth, i.isPointLight && l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(i.matrixWorld), l.nearDistance = r, l.farDistance = o), l
                }

                function O(n, r, o, s, c) {
                    if (!1 !== n.visible) {
                        var l = n.layers.test(r.layers);
                        if (l && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && c === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                            var h = e.update(n),
                                u = n.material;
                            if (Array.isArray(u))
                                for (var p = h.groups, d = 0, f = p.length; d < f; d++) {
                                    var m = p[d],
                                        v = u[m.materialIndex];
                                    if (v && v.visible) {
                                        var g = C(n, v, s, o.near, o.far, c);
                                        t.renderBufferDirect(o, null, h, g, n, m)
                                    }
                                } else if (u.visible) {
                                    var g = C(n, u, s, o.near, o.far, c);
                                    t.renderBufferDirect(o, null, h, g, n, null)
                                }
                        }
                        for (var y = n.children, _ = 0, x = y.length; _ < x; _++) O(y[_], r, o, s, c)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = r, this.render = function(e, r, s) {
                    if (!1 !== L.enabled && (!1 !== L.autoUpdate || !1 !== L.needsUpdate) && 0 !== e.length) {
                        var c = t.getRenderTarget(),
                            l = t.getActiveCubeFace(),
                            p = t.getActiveMipmapLevel(),
                            f = t.state;
                        f.setBlending(d), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1);
                        for (var m = 0, v = e.length; m < v; m++) {
                            var g = e[m],
                                y = g.shadow;
                            if (void 0 !== y) {
                                o.copy(y.mapSize);
                                var _ = y.getFrameExtents();
                                if (o.multiply(_), h.copy(y.mapSize), (o.x > n || o.y > n) && (console.warn("THREE.WebGLShadowMap:", g, "has shadow exceeding max texture size, reducing"), o.x > n && (h.x = Math.floor(n / _.x), o.x = h.x * _.x, y.mapSize.x = h.x), o.y > n && (h.y = Math.floor(n / _.y), o.y = h.y * _.y, y.mapSize.y = h.y)), null === y.map && !y.isPointLightShadow && this.type === a) {
                                    var x = {
                                        minFilter: ut,
                                        magFilter: ut,
                                        format: Pt
                                    };
                                    y.map = new ke(o.x, o.y, x), y.map.texture.name = g.name + ".shadowMap", y.mapPass = new ke(o.x, o.y, x), y.camera.updateProjectionMatrix()
                                }
                                if (null === y.map) {
                                    var x = {
                                        minFilter: ct,
                                        magFilter: ct,
                                        format: Pt
                                    };
                                    y.map = new ke(o.x, o.y, x), y.map.texture.name = g.name + ".shadowMap", y.camera.updateProjectionMatrix()
                                }
                                t.setRenderTarget(y.map), t.clear();
                                for (var b = y.getViewportCount(), w = 0; w < b; w++) {
                                    var M = y.getViewport(w);
                                    u.set(h.x * M.x, h.y * M.y, h.x * M.z, h.y * M.w), f.viewport(u), y.updateMatrices(g, s, w), i = y.getFrustum(), O(r, s, y.camera, g, this.type)
                                }
                                y.isPointLightShadow || this.type !== a || R(y, s)
                            } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.")
                        }
                        L.needsUpdate = !1, t.setRenderTarget(c, l, p)
                    }
                }
            }

            function ea(t, e, n, i, r, o, a) {
                var s, c = new WeakMap,
                    l = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");

                function h(t, e) {
                    return l ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function u(t, e, n, i) {
                    var r = 1;
                    if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                            var o = e ? Se.floorPowerOfTwo : Math.floor,
                                a = o(r * t.width),
                                c = o(r * t.height);
                            void 0 === s && (s = h(a, c));
                            var l = n ? h(a, c) : s;
                            l.width = a, l.height = c;
                            var u = l.getContext("2d");
                            return u.drawImage(t, 0, 0, a, c), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a + "x" + c + ")."), l
                        }
                        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                    }
                    return t
                }

                function p(t) {
                    return Se.isPowerOfTwo(t.width) && Se.isPowerOfTwo(t.height)
                }

                function d(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== ct && t.minFilter !== ut
                }

                function f(e, n, r, o) {
                    t.generateMipmap(e);
                    var a = i.get(n);
                    a.__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
                }

                function m(t, n) {
                    if (!r.isWebGL2) return t;
                    var i = t;
                    return 6403 === t && (5126 === n && (i = 33326), 5131 === n && (i = 33325), 5121 === n && (i = 33321)), 6407 === t && (5126 === n && (i = 34837), 5131 === n && (i = 34843), 5121 === n && (i = 32849)), 6408 === t && (5126 === n && (i = 34836), 5131 === n && (i = 34842), 5121 === n && (i = 32856)), 33325 === i || 33326 === i || 34842 === i || 34836 === i ? e.get("EXT_color_buffer_float") : 34843 !== i && 34837 !== i || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), i
                }

                function v(t) {
                    return t === ct || t === lt || t === ht ? 9728 : 9729
                }

                function g(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", g),
                        function(e) {
                            var n = i.get(e);
                            void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
                        }(n), n.isVideoTexture && c.delete(n), a.memory.textures--
                }

                function y(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", y),
                        function(e) {
                            var n = i.get(e),
                                r = i.get(e.texture);
                            if (e) {
                                if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
                                    for (var o = 0; o < 6; o++) t.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                                else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                                if (e.isWebGLMultiviewRenderTarget) {
                                    t.deleteTexture(n.__webglColorTexture), t.deleteTexture(n.__webglDepthStencilTexture), a.memory.textures -= 2;
                                    for (var o = 0, s = n.__webglViewFramebuffers.length; o < s; o++) t.deleteFramebuffer(n.__webglViewFramebuffers[o])
                                }
                                i.remove(e.texture), i.remove(e)
                            }
                        }(n), a.memory.textures--
                }
                var _ = 0;

                function x(t, e) {
                    var r = i.get(t);
                    if (t.isVideoTexture && function(t) {
                            var e = a.render.frame;
                            c.get(t) !== e && (c.set(t, e), t.update())
                        }(t), t.version > 0 && r.__version !== t.version) {
                        var o = t.image;
                        if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== o.complete) return void E(r, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                }

                function b(e, a) {
                    if (6 === e.image.length) {
                        var s = i.get(e);
                        if (e.version > 0 && s.__version !== e.version) {
                            T(s, e), n.activeTexture(33984 + a), n.bindTexture(34067, s.__webglTexture), t.pixelStorei(37440, e.flipY);
                            for (var c = e && e.isCompressedTexture, l = e.image[0] && e.image[0].isDataTexture, h = [], v = 0; v < 6; v++) h[v] = c || l ? l ? e.image[v].image : e.image[v] : u(e.image[v], !1, !0, r.maxCubemapSize);
                            var g, y = h[0],
                                _ = p(y) || r.isWebGL2,
                                x = o.convert(e.format),
                                b = o.convert(e.type),
                                w = m(x, b);
                            if (M(34067, e, _), c) {
                                for (var v = 0; v < 6; v++) {
                                    g = h[v].mipmaps;
                                    for (var E = 0; E < g.length; E++) {
                                        var S = g[E];
                                        e.format !== Pt && e.format !== At ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(34069 + v, E, w, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + v, E, w, S.width, S.height, 0, x, b, S.data)
                                    }
                                }
                                s.__maxMipLevel = g.length - 1
                            } else {
                                g = e.mipmaps;
                                for (var v = 0; v < 6; v++)
                                    if (l) {
                                        n.texImage2D(34069 + v, 0, w, h[v].width, h[v].height, 0, x, b, h[v].data);
                                        for (var E = 0; E < g.length; E++) {
                                            var S = g[E],
                                                A = S.image[v].image;
                                            n.texImage2D(34069 + v, E + 1, w, A.width, A.height, 0, x, b, A.data)
                                        }
                                    } else {
                                        n.texImage2D(34069 + v, 0, w, x, b, h[v]);
                                        for (var E = 0; E < g.length; E++) {
                                            var S = g[E];
                                            n.texImage2D(34069 + v, E + 1, w, x, b, S.image[v])
                                        }
                                    }
                                s.__maxMipLevel = g.length
                            }
                            d(e, _) && f(34067, e, y.width, y.height), s.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else n.activeTexture(33984 + a), n.bindTexture(34067, s.__webglTexture)
                    }
                }

                function w(t, e) {
                    n.activeTexture(33984 + e), n.bindTexture(34067, i.get(t).__webglTexture)
                }

                function M(n, a, s) {
                    var c;
                    if (s ? (t.texParameteri(n, 10242, o.convert(a.wrapS)), t.texParameteri(n, 10243, o.convert(a.wrapT)), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, o.convert(a.wrapR)), t.texParameteri(n, 10240, o.convert(a.magFilter)), t.texParameteri(n, 10241, o.convert(a.minFilter))) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), a.wrapS === at && a.wrapT === at || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, v(a.magFilter)), t.texParameteri(n, 10241, v(a.minFilter)), a.minFilter !== ct && a.minFilter !== ut && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c = e.get("EXT_texture_filter_anisotropic")) {
                        if (a.type === xt && null === e.get("OES_texture_float_linear")) return;
                        if (a.type === bt && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear"))) return;
                        (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function T(e, n) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", g), e.__webglTexture = t.createTexture(), a.memory.textures++)
                }

                function E(e, i, a) {
                    var s = 3553;
                    i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), T(e, i), n.activeTexture(33984 + a), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment);
                    var c = function(t) {
                            return !r.isWebGL2 && (t.wrapS !== at || t.wrapT !== at || t.minFilter !== ct && t.minFilter !== ut)
                        }(i) && !1 === p(i.image),
                        l = u(i.image, c, !1, r.maxTextureSize),
                        h = p(l) || r.isWebGL2,
                        v = o.convert(i.format),
                        g = o.convert(i.type),
                        y = m(v, g);
                    M(s, i, h);
                    var _, x = i.mipmaps;
                    if (i.isDepthTexture) {
                        if (y = 6402, i.type === xt) {
                            if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            y = 36012
                        } else r.isWebGL2 && (y = 33189);
                        i.format === Ot && 6402 === y && i.type !== gt && i.type !== _t && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = gt, g = o.convert(i.type)), i.format === It && (y = 34041, i.type !== Et && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Et, g = o.convert(i.type))), n.texImage2D(3553, 0, y, l.width, l.height, 0, v, g, null)
                    } else if (i.isDataTexture)
                        if (x.length > 0 && h) {
                            for (var b = 0, w = x.length; b < w; b++) _ = x[b], n.texImage2D(3553, b, y, _.width, _.height, 0, v, g, _.data);
                            i.generateMipmaps = !1, e.__maxMipLevel = x.length - 1
                        } else n.texImage2D(3553, 0, y, l.width, l.height, 0, v, g, l.data), e.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) {
                        for (var b = 0, w = x.length; b < w; b++) _ = x[b], i.format !== Pt && i.format !== At ? n.getCompressedTextureFormats().indexOf(v) > -1 ? n.compressedTexImage2D(3553, b, y, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, b, y, _.width, _.height, 0, v, g, _.data);
                        e.__maxMipLevel = x.length - 1
                    } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, y, l.width, l.height, l.depth, 0, v, g, l.data), e.__maxMipLevel = 0;
                    else if (i.isDataTexture3D) n.texImage3D(32879, 0, y, l.width, l.height, l.depth, 0, v, g, l.data), e.__maxMipLevel = 0;
                    else if (x.length > 0 && h) {
                        for (var b = 0, w = x.length; b < w; b++) _ = x[b], n.texImage2D(3553, b, y, v, g, _);
                        i.generateMipmaps = !1, e.__maxMipLevel = x.length - 1
                    } else n.texImage2D(3553, 0, y, v, g, l), e.__maxMipLevel = 0;
                    d(i, h) && f(3553, i, l.width, l.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                }

                function S(e, r, a, s) {
                    var c = o.convert(r.texture.format),
                        l = o.convert(r.texture.type),
                        h = m(c, l);
                    n.texImage2D(s, 0, h, r.width, r.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, s, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
                }

                function A(e, n, i) {
                    if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                        if (i) {
                            var r = L(n);
                            t.renderbufferStorageMultisample(36161, r, 33189, n.width, n.height)
                        } else t.renderbufferStorage(36161, 33189, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        if (i) {
                            var r = L(n);
                            t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height)
                        } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 33306, 36161, e)
                    } else {
                        var a = o.convert(n.texture.format),
                            s = o.convert(n.texture.type),
                            c = m(a, s);
                        if (i) {
                            var r = L(n);
                            t.renderbufferStorageMultisample(36161, r, c, n.width, n.height)
                        } else t.renderbufferStorage(36161, c, n.width, n.height)
                    }
                    t.bindRenderbuffer(36161, null)
                }

                function P(e) {
                    var n = i.get(e),
                        r = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, n) {
                            if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), x(n.depthTexture, 0);
                            var r = i.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === Ot) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else {
                                if (n.depthTexture.format !== It) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                            }
                        }(n.__webglFramebuffer, e)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (var o = 0; o < 6; o++) t.bindFramebuffer(36160, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = t.createRenderbuffer(), A(n.__webglDepthbuffer[o], e)
                    } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), A(n.__webglDepthbuffer, e);
                    t.bindFramebuffer(36160, null)
                }

                function L(t) {
                    return r.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, t.samples) : 0
                }
                var R = !1,
                    C = !1;
                this.allocateTextureUnit = function() {
                    var t = _;
                    return t >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + r.maxTextures), _ += 1, t
                }, this.resetTextureUnits = function() {
                    _ = 0
                }, this.setTexture2D = x, this.setTexture2DArray = function(t, e) {
                    var r = i.get(t);
                    t.version > 0 && r.__version !== t.version ? E(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                }, this.setTexture3D = function(t, e) {
                    var r = i.get(t);
                    t.version > 0 && r.__version !== t.version ? E(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = b, this.setTextureCubeDynamic = w, this.setupRenderTarget = function(s) {
                    var c = i.get(s),
                        l = i.get(s.texture);
                    s.addEventListener("dispose", y), l.__webglTexture = t.createTexture(), a.memory.textures++;
                    var h = !0 === s.isWebGLRenderTargetCube,
                        u = !0 === s.isWebGLMultisampleRenderTarget,
                        v = !0 === s.isWebGLMultiviewRenderTarget,
                        g = p(s) || r.isWebGL2;
                    if (h) {
                        c.__webglFramebuffer = [];
                        for (var _ = 0; _ < 6; _++) c.__webglFramebuffer[_] = t.createFramebuffer()
                    } else if (c.__webglFramebuffer = t.createFramebuffer(), u)
                        if (r.isWebGL2) {
                            c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                            var x = o.convert(s.texture.format),
                                b = o.convert(s.texture.type),
                                w = m(x, b),
                                T = L(s);
                            t.renderbufferStorageMultisample(36161, T, w, s.width, s.height), t.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), s.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), A(c.__webglDepthRenderbuffer, s, !0)), t.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    else if (v) {
                        var E = s.width,
                            R = s.height,
                            C = s.numViews;
                        t.bindFramebuffer(36160, c.__webglFramebuffer);
                        var O = e.get("OVR_multiview2");
                        a.memory.textures += 2;
                        var I = t.createTexture();
                        t.bindTexture(35866, I), t.texParameteri(35866, 10240, 9728), t.texParameteri(35866, 10241, 9728), t.texImage3D(35866, 0, 32856, E, R, C, 0, 6408, 5121, null), O.framebufferTextureMultiviewOVR(36160, 36064, I, 0, 0, C);
                        var D = t.createTexture();
                        t.bindTexture(35866, D), t.texParameteri(35866, 10240, 9728), t.texParameteri(35866, 10241, 9728), t.texImage3D(35866, 0, 35056, E, R, C, 0, 34041, 34042, null), O.framebufferTextureMultiviewOVR(36160, 33306, D, 0, 0, C);
                        for (var N = new Array(C), _ = 0; _ < C; ++_) N[_] = t.createFramebuffer(), t.bindFramebuffer(36160, N[_]), t.framebufferTextureLayer(36160, 36064, I, 0, _);
                        c.__webglColorTexture = I, c.__webglDepthStencilTexture = D, c.__webglViewFramebuffers = N, t.bindFramebuffer(36160, null), t.bindTexture(35866, null)
                    }
                    if (h) {
                        n.bindTexture(34067, l.__webglTexture), M(34067, s.texture, g);
                        for (var _ = 0; _ < 6; _++) S(c.__webglFramebuffer[_], s, 36064, 34069 + _);
                        d(s.texture, g) && f(34067, s.texture, s.width, s.height), n.bindTexture(34067, null)
                    } else v || (n.bindTexture(3553, l.__webglTexture), M(3553, s.texture, g), S(c.__webglFramebuffer, s, 36064, 3553), d(s.texture, g) && f(3553, s.texture, s.width, s.height), n.bindTexture(3553, null));
                    s.depthBuffer && P(s)
                }, this.updateRenderTargetMipmap = function(t) {
                    var e = t.texture,
                        o = p(t) || r.isWebGL2;
                    if (d(e, o)) {
                        var a = t.isWebGLRenderTargetCube ? 34067 : 3553,
                            s = i.get(e).__webglTexture;
                        n.bindTexture(a, s), f(a, e, t.width, t.height), n.bindTexture(a, null)
                    }
                }, this.updateMultisampleRenderTarget = function(e) {
                    if (e.isWebGLMultisampleRenderTarget)
                        if (r.isWebGL2) {
                            var n = i.get(e);
                            t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                            var o = e.width,
                                a = e.height,
                                s = 16384;
                            e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, 9728)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }, this.safeSetTexture2D = function(t, e) {
                    t && t.isWebGLRenderTarget && (!1 === R && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), R = !0), t = t.texture), x(t, e)
                }, this.safeSetTextureCube = function(t, e) {
                    t && t.isWebGLRenderTargetCube && (!1 === C && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), C = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? b(t, e) : w(t, e)
                }
            }

            function na(t, e, n) {
                return {
                    convert: function(t) {
                        var i;
                        if (t === ot) return 10497;
                        if (t === at) return 33071;
                        if (t === st) return 33648;
                        if (t === ct) return 9728;
                        if (t === lt) return 9984;
                        if (t === ht) return 9986;
                        if (t === ut) return 9729;
                        if (t === pt) return 9985;
                        if (t === dt) return 9987;
                        if (t === ft) return 5121;
                        if (t === wt) return 32819;
                        if (t === Mt) return 32820;
                        if (t === Tt) return 33635;
                        if (t === mt) return 5120;
                        if (t === vt) return 5122;
                        if (t === gt) return 5123;
                        if (t === yt) return 5124;
                        if (t === _t) return 5125;
                        if (t === xt) return 5126;
                        if (t === bt) {
                            if (n.isWebGL2) return 5131;
                            if (null !== (i = e.get("OES_texture_half_float"))) return i.HALF_FLOAT_OES
                        }
                        if (t === St) return 6406;
                        if (t === At) return 6407;
                        if (t === Pt) return 6408;
                        if (t === Lt) return 6409;
                        if (t === Rt) return 6410;
                        if (t === Ot) return 6402;
                        if (t === It) return 34041;
                        if (t === Dt) return 6403;
                        if (t === _) return 32774;
                        if (t === x) return 32778;
                        if (t === b) return 32779;
                        if (t === T) return 0;
                        if (t === E) return 1;
                        if (t === S) return 768;
                        if (t === A) return 769;
                        if (t === P) return 770;
                        if (t === L) return 771;
                        if (t === R) return 772;
                        if (t === C) return 773;
                        if (t === O) return 774;
                        if (t === I) return 775;
                        if (t === D) return 776;
                        if ((t === Nt || t === Bt || t === Ht || t === Ft) && null !== (i = e.get("WEBGL_compressed_texture_s3tc"))) {
                            if (t === Nt) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === Bt) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === Ht) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === Ft) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if ((t === kt || t === Ut || t === zt || t === Gt) && null !== (i = e.get("WEBGL_compressed_texture_pvrtc"))) {
                            if (t === kt) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (t === Ut) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (t === zt) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (t === Gt) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (t === jt && null !== (i = e.get("WEBGL_compressed_texture_etc1"))) return i.COMPRESSED_RGB_ETC1_WEBGL;
                        if ((t === Vt || t === Wt || t === Xt || t === qt || t === Yt || t === Zt || t === Jt || t === Kt || t === Qt || t === $t || t === te || t === ee || t === ne || t === ie) && null !== (i = e.get("WEBGL_compressed_texture_astc"))) return t;
                        if (t === w || t === M) {
                            if (n.isWebGL2) {
                                if (t === w) return 32775;
                                if (t === M) return 32776
                            }
                            if (null !== (i = e.get("EXT_blend_minmax"))) {
                                if (t === w) return i.MIN_EXT;
                                if (t === M) return i.MAX_EXT
                            }
                        }
                        if (t === Et) {
                            if (n.isWebGL2) return 34042;
                            if (null !== (i = e.get("WEBGL_depth_texture"))) return i.UNSIGNED_INT_24_8_WEBGL
                        }
                        return 0
                    }
                }
            }

            function ia(t, e, n, i) {
                ke.call(this, t, e, i), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = n
            }

            function ra(t, e) {
                var n, i, r, o, a, s, c, l = 2,
                    h = t.extensions,
                    u = t.properties,
                    p = 0;

                function d(t) {
                    return t.isArrayCamera ? t.cameras : (a[0] = t, a)
                }
                this.isAvailable = function() {
                    if (void 0 === c) {
                        var t = h.get("OVR_multiview2");
                        if (c = null !== t && !1 === e.getContextAttributes().antialias) {
                            p = e.getParameter(t.MAX_VIEWS_OVR), n = new ia(0, 0, l), s = new Ae, o = [], r = [], a = [];
                            for (var i = 0; i < p; i++) o[i] = new Ye, r[i] = new De
                        }
                    }
                    return c
                }, this.attachCamera = function(e) {
                    !1 !== function(t) {
                        if (void 0 === t.isArrayCamera) return !0;
                        var e = t.cameras;
                        if (e.length > p) return !1;
                        for (var n = 1, i = e.length; n < i; n++)
                            if (e[0].viewport.z !== e[n].viewport.z || e[0].viewport.w !== e[n].viewport.w) return !1;
                        return !0
                    }(e) && (i = t.getRenderTarget(), function(e) {
                        if (i ? s.set(i.width, i.height) : t.getDrawingBufferSize(s), e.isArrayCamera) {
                            var r = e.cameras[0].viewport;
                            n.setSize(r.z, r.w), n.setNumViews(e.cameras.length)
                        } else n.setSize(s.x, s.y), n.setNumViews(l)
                    }(e), t.setRenderTarget(n))
                }, this.detachCamera = function(r) {
                    n === t.getRenderTarget() && (t.setRenderTarget(i), function(t) {
                        var i = n,
                            r = i.numViews,
                            o = u.get(i).__webglViewFramebuffers,
                            a = i.width,
                            c = i.height;
                        if (t.isArrayCamera)
                            for (var l = 0; l < r; l++) {
                                var h = t.cameras[l].viewport,
                                    p = h.x,
                                    d = h.y,
                                    f = p + h.z,
                                    m = d + h.w;
                                e.bindFramebuffer(36008, o[l]), e.blitFramebuffer(0, 0, a, c, p, d, f, m, 16384, 9728)
                            } else e.bindFramebuffer(36008, o[0]), e.blitFramebuffer(0, 0, a, c, 0, 0, s.x, s.y, 16384, 9728)
                    }(r))
                }, this.updateCameraProjectionMatricesUniform = function(t, n) {
                    for (var i = d(t), r = 0; r < i.length; r++) o[r].copy(i[r].projectionMatrix);
                    n.setValue(e, "projectionMatrices", o)
                }, this.updateCameraViewMatricesUniform = function(t, n) {
                    for (var i = d(t), r = 0; r < i.length; r++) o[r].copy(i[r].matrixWorldInverse);
                    n.setValue(e, "viewMatrices", o)
                }, this.updateObjectMatricesUniforms = function(t, n, i) {
                    for (var a = d(n), s = 0; s < a.length; s++) o[s].multiplyMatrices(a[s].matrixWorldInverse, t.matrixWorld), r[s].getNormalMatrix(o[s]);
                    i.setValue(e, "modelViewMatrices", o), i.setValue(e, "normalMatrices", r)
                }
            }

            function oa() {
                dn.call(this), this.type = "Group"
            }

            function aa(t) {
                sr.call(this), this.cameras = t || []
            }
            ia.prototype = Object.assign(Object.create(ke.prototype), {
                constructor: ia,
                isWebGLMultiviewRenderTarget: !0,
                copy: function(t) {
                    return ke.prototype.copy.call(this, t), this.numViews = t.numViews, this
                },
                setNumViews: function(t) {
                    return this.numViews !== t && (this.numViews = t, this.dispose()), this
                }
            }), oa.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: oa,
                isGroup: !0
            }), aa.prototype = Object.assign(Object.create(sr.prototype), {
                constructor: aa,
                isArrayCamera: !0
            });
            var sa, ca = new Ce,
                la = new Ce;

            function ha(t, e, n) {
                ca.setFromMatrixPosition(e.matrixWorld), la.setFromMatrixPosition(n.matrixWorld);
                var i = ca.distanceTo(la),
                    r = e.projectionMatrix.elements,
                    o = n.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    c = (r[9] + 1) / r[5],
                    l = (r[9] - 1) / r[5],
                    h = (r[8] - 1) / r[0],
                    u = (o[8] + 1) / o[0],
                    p = a * h,
                    d = a * u,
                    f = i / (-h + u),
                    m = f * -h;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                var v = a + f,
                    g = s + f,
                    y = p - m,
                    _ = d + (i - m),
                    x = c * s / g * v,
                    b = l * s / g * v;
                t.projectionMatrix.makePerspective(y, _, x, b, v, g)
            }

            function ua(t) {
                var e, n, i = this,
                    r = null,
                    o = null,
                    a = null,
                    s = [],
                    c = new Ye,
                    l = new Ye,
                    h = 1,
                    u = "local-floor";
                "undefined" != typeof window && "VRFrameData" in window && (o = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", b, !1));
                var p = new Ye,
                    d = new Pe,
                    f = new Ce,
                    m = new sr;
                m.viewport = new Fe, m.layers.enable(1);
                var v = new sr;
                v.viewport = new Fe, v.layers.enable(2);
                var g = new aa([m, v]);

                function y() {
                    return null !== r && !0 === r.isPresenting
                }
                g.layers.enable(1), g.layers.enable(2);
                var _, x = new Ae;

                function b() {
                    if (y()) {
                        var o = r.getEyeParameters("left");
                        e = 2 * o.renderWidth * h, n = o.renderHeight * h, _ = t.getPixelRatio(), t.getSize(x), t.setDrawingBufferSize(e, n, 1), m.viewport.set(0, 0, e / 2, n), v.viewport.set(e / 2, 0, e / 2, n), E.start(), i.dispatchEvent({
                            type: "sessionstart"
                        })
                    } else i.enabled && t.setDrawingBufferSize(x.width, x.height, _), E.stop(), i.dispatchEvent({
                        type: "sessionend"
                    })
                }
                var w = [];

                function M(t) {
                    for (var e = navigator.getGamepads && navigator.getGamepads(), n = 0, i = 0, r = e.length; n < r; n++) {
                        var o = e[n];
                        if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("HTC Vive Focus") || o.id.startsWith("Spatial Controller"))) {
                            if (i === t) return o;
                            i++
                        }
                    }
                }

                function T(t, i) {
                    null !== i && 4 === i.length && t.set(i[0] * e, i[1] * n, i[2] * e, i[3] * n)
                }
                this.enabled = !1, this.getController = function(t) {
                    var e = s[t];
                    return void 0 === e && ((e = new oa).matrixAutoUpdate = !1, e.visible = !1, s[t] = e), e
                }, this.getDevice = function() {
                    return r
                }, this.setDevice = function(t) {
                    void 0 !== t && (r = t), E.setContext(t)
                }, this.setFramebufferScaleFactor = function(t) {
                    h = t
                }, this.setReferenceSpaceType = function(t) {
                    u = t
                }, this.setPoseTarget = function(t) {
                    void 0 !== t && (a = t)
                }, this.getCamera = function(t) {
                    var e = "local-floor" === u ? 1.6 : 0;
                    if (!1 === y()) return t.position.set(0, e, 0), t.rotation.set(0, 0, 0), t;
                    if (r.depthNear = t.near, r.depthFar = t.far, r.getFrameData(o), "local-floor" === u) {
                        var n = r.stageParameters;
                        n ? c.fromArray(n.sittingToStandingTransform) : c.makeTranslation(0, e, 0)
                    }
                    var i = o.pose,
                        h = null !== a ? a : t;
                    h.matrix.copy(c), h.matrix.decompose(h.position, h.quaternion, h.scale), null !== i.orientation && (d.fromArray(i.orientation), h.quaternion.multiply(d)), null !== i.position && (d.setFromRotationMatrix(c), f.fromArray(i.position), f.applyQuaternion(d), h.position.add(f)), h.updateMatrixWorld(), m.near = t.near, v.near = t.near, m.far = t.far, v.far = t.far, m.matrixWorldInverse.fromArray(o.leftViewMatrix), v.matrixWorldInverse.fromArray(o.rightViewMatrix), l.getInverse(c), "local-floor" === u && (m.matrixWorldInverse.multiply(l), v.matrixWorldInverse.multiply(l));
                    var _ = h.parent;
                    null !== _ && (p.getInverse(_.matrixWorld), m.matrixWorldInverse.multiply(p), v.matrixWorldInverse.multiply(p)), m.matrixWorld.getInverse(m.matrixWorldInverse), v.matrixWorld.getInverse(v.matrixWorldInverse), m.projectionMatrix.fromArray(o.leftProjectionMatrix), v.projectionMatrix.fromArray(o.rightProjectionMatrix), ha(g, m, v);
                    var x = r.getLayers();
                    if (x.length) {
                        var b = x[0];
                        T(m.viewport, b.leftBounds), T(v.viewport, b.rightBounds)
                    }
                    return function() {
                        for (var t = 0; t < s.length; t++) {
                            var e = s[t],
                                n = M(t);
                            if (void 0 !== n && void 0 !== n.pose) {
                                if (null === n.pose) return;
                                var i = n.pose;
                                !1 === i.hasPosition && e.position.set(.2, -.6, -.05), null !== i.position && e.position.fromArray(i.position), null !== i.orientation && e.quaternion.fromArray(i.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(c), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
                                var r = "Daydream Controller" === n.id ? 0 : 1;
                                void 0 === w[t] && (w[t] = !1), w[t] !== n.buttons[r].pressed && (w[t] = n.buttons[r].pressed, !0 === w[t] ? e.dispatchEvent({
                                    type: "selectstart"
                                }) : (e.dispatchEvent({
                                    type: "selectend"
                                }), e.dispatchEvent({
                                    type: "select"
                                })))
                            } else e.visible = !1
                        }
                    }(), g
                }, this.getStandingMatrix = function() {
                    return c
                }, this.isPresenting = y;
                var E = new Mr;
                this.setAnimationLoop = function(t) {
                    E.setAnimationLoop(t), y() && E.start()
                }, this.submitFrame = function() {
                    y() && r.submitFrame()
                }, this.dispose = function() {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", b)
                }, this.setFrameOfReferenceType = function() {
                    console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
                }
            }

            function pa(t, e) {
                var n = this,
                    i = null,
                    r = null,
                    o = "local-floor",
                    a = null,
                    s = [],
                    c = [];

                function l() {
                    return null !== i && null !== r
                }
                var h = new sr;
                h.layers.enable(1), h.viewport = new Fe;
                var u = new sr;
                u.layers.enable(2), u.viewport = new Fe;
                var p = new aa([h, u]);

                function d(t) {
                    for (var e = 0; e < s.length; e++) c[e] === t.inputSource && s[e].dispatchEvent({
                        type: t.type
                    })
                }

                function f() {
                    t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), y.stop(), n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function m(t) {
                    r = t, y.setContext(i), y.start(), n.dispatchEvent({
                        type: "sessionstart"
                    })
                }

                function v(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                }
                p.layers.enable(1), p.layers.enable(2), this.enabled = !1, this.getController = function(t) {
                    var e = s[t];
                    return void 0 === e && ((e = new oa).matrixAutoUpdate = !1, e.visible = !1, s[t] = e), e
                }, this.setFramebufferScaleFactor = function() {}, this.setReferenceSpaceType = function(t) {
                    o = t
                }, this.getSession = function() {
                    return i
                }, this.setSession = function(t) {
                    null !== (i = t) && (i.addEventListener("select", d), i.addEventListener("selectstart", d), i.addEventListener("selectend", d), i.addEventListener("end", f), i.updateRenderState({
                        baseLayer: new XRWebGLLayer(i, e)
                    }), i.requestReferenceSpace(o).then(m), c = i.inputSources, i.addEventListener("inputsourceschange", function() {
                        c = i.inputSources, console.log(c);
                        for (var t = 0; t < s.length; t++) {
                            var e = s[t];
                            e.userData.inputSource = c[t]
                        }
                    }))
                }, this.getCamera = function(t) {
                    if (l()) {
                        var e = t.parent,
                            n = p.cameras;
                        v(p, e);
                        for (var i = 0; i < n.length; i++) v(n[i], e);
                        t.matrixWorld.copy(p.matrixWorld);
                        for (var r = t.children, i = 0, o = r.length; i < o; i++) r[i].updateMatrixWorld(!0);
                        return ha(p, h, u), p
                    }
                    return t
                }, this.isPresenting = l;
                var g = null,
                    y = new Mr;
                y.setAnimationLoop(function(e, n) {
                    if (null !== (a = n.getViewerPose(r))) {
                        var o = a.views,
                            l = i.renderState.baseLayer;
                        t.setFramebuffer(l.framebuffer);
                        for (var h = 0; h < o.length; h++) {
                            var u = o[h],
                                d = l.getViewport(u),
                                f = u.transform.inverse.matrix,
                                m = p.cameras[h];
                            m.matrix.fromArray(f).getInverse(m.matrix), m.projectionMatrix.fromArray(u.projectionMatrix), m.viewport.set(d.x, d.y, d.width, d.height), 0 === h && p.matrix.copy(m.matrix)
                        }
                    }
                    for (var h = 0; h < s.length; h++) {
                        var v = s[h],
                            y = c[h];
                        if (y) {
                            var _ = n.getPose(y.targetRaySpace, r);
                            if (null !== _) {
                                v.matrix.fromArray(_.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.visible = !0;
                                continue
                            }
                        }
                        v.visible = !1
                    }
                    g && g(e)
                }), this.setAnimationLoop = function(t) {
                    g = t
                }, this.dispose = function() {}, this.getStandingMatrix = function() {
                    return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new Ye
                }, this.getDevice = function() {
                    console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
                }, this.setDevice = function() {
                    console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
                }, this.setFrameOfReferenceType = function() {
                    console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
                }, this.submitFrame = function() {}
            }

            function da(t) {
                var r = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    o = void 0 !== t.context ? t.context : null,
                    a = void 0 !== t.alpha && t.alpha,
                    h = void 0 === t.depth || t.depth,
                    u = void 0 === t.stencil || t.stencil,
                    p = void 0 !== t.antialias && t.antialias,
                    x = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    b = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    w = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    M = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
                    T = null,
                    E = null;
                this.domElement = r, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = q, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var S, A, P, L, R, C, O, I, D, j, V, W, X, Y, Z, J, K, Q, $ = this,
                    tt = !1,
                    et = null,
                    nt = 0,
                    it = 0,
                    rt = null,
                    ot = null,
                    at = -1,
                    st = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    ct = null,
                    lt = null,
                    ht = new Fe,
                    ut = new Fe,
                    pt = null,
                    dt = r.width,
                    mt = r.height,
                    vt = 1,
                    gt = new Fe(0, 0, dt, mt),
                    yt = new Fe(0, 0, dt, mt),
                    _t = !1,
                    wt = new _r,
                    Mt = new function() {
                        var t = this,
                            e = null,
                            n = 0,
                            i = !1,
                            r = !1,
                            o = new vr,
                            a = new De,
                            s = {
                                value: null,
                                needsUpdate: !1
                            };

                        function c() {
                            s.value !== e && (s.value = e, s.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
                        }

                        function l(e, n, i, r) {
                            var c = null !== e ? e.length : 0,
                                l = null;
                            if (0 !== c) {
                                if (l = s.value, !0 !== r || null === l) {
                                    var h = i + 4 * c,
                                        u = n.matrixWorldInverse;
                                    a.getNormalMatrix(u), (null === l || l.length < h) && (l = new Float32Array(h));
                                    for (var p = 0, d = i; p !== c; ++p, d += 4) o.copy(e[p]).applyMatrix4(u, a), o.normal.toArray(l, d), l[d + 3] = o.constant
                                }
                                s.value = l, s.needsUpdate = !0
                            }
                            return t.numPlanes = c, l
                        }
                        this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, o) {
                            var a = 0 !== t.length || r || 0 !== n || i;
                            return i = r, e = l(t, o, 0), n = t.length, a
                        }, this.beginShadows = function() {
                            r = !0, l(null)
                        }, this.endShadows = function() {
                            r = !1, c()
                        }, this.setState = function(t, o, a, h, u, p) {
                            if (!i || null === t || 0 === t.length || r && !a) r ? l(null) : c();
                            else {
                                var d = r ? 0 : n,
                                    f = 4 * d,
                                    m = u.clippingState || null;
                                s.value = m, m = l(t, h, f, p);
                                for (var v = 0; v !== f; ++v) m[v] = e[v];
                                u.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += d
                            }
                        }
                    },
                    Tt = !1,
                    Et = !1,
                    St = new Ye,
                    At = new Ce;

                function Lt() {
                    return null === rt ? vt : 1
                }
                try {
                    var Rt = {
                        alpha: a,
                        depth: h,
                        stencil: u,
                        antialias: p,
                        premultipliedAlpha: x,
                        preserveDrawingBuffer: b,
                        powerPreference: w,
                        failIfMajorPerformanceCaveat: M,
                        xrCompatible: !0
                    };
                    if (r.addEventListener("webglcontextlost", Nt, !1), r.addEventListener("webglcontextrestored", Bt, !1), null === (S = o || r.getContext("webgl", Rt) || r.getContext("experimental-webgl", Rt))) throw null !== r.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === S.getShaderPrecisionFormat && (S.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    throw console.error("THREE.WebGLRenderer: " + t.message), t
                }

                function Ct() {
                    A = new function(t) {
                        var e = {};
                        return {
                            get: function(n) {
                                if (void 0 !== e[n]) return e[n];
                                var i;
                                switch (n) {
                                    case "WEBGL_depth_texture":
                                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                        break;
                                    case "EXT_texture_filter_anisotropic":
                                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                        break;
                                    case "WEBGL_compressed_texture_s3tc":
                                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                        break;
                                    case "WEBGL_compressed_texture_pvrtc":
                                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                        break;
                                    default:
                                        i = t.getExtension(n)
                                }
                                return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
                            }
                        }
                    }(S), !1 === (P = new function(t, e, n) {
                        var i;

                        function r(e) {
                            if ("highp" === e) {
                                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                                e = "mediump"
                            }
                            return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                        }
                        var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                            a = void 0 !== n.precision ? n.precision : "highp",
                            s = r(a);
                        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
                        var c = !0 === n.logarithmicDepthBuffer,
                            l = t.getParameter(34930),
                            h = t.getParameter(35660),
                            u = t.getParameter(3379),
                            p = t.getParameter(34076),
                            d = t.getParameter(34921),
                            f = t.getParameter(36347),
                            m = t.getParameter(36348),
                            v = t.getParameter(36349),
                            g = h > 0,
                            y = o || !!e.get("OES_texture_float"),
                            _ = g && y,
                            x = o ? t.getParameter(36183) : 0;
                        return {
                            isWebGL2: o,
                            getMaxAnisotropy: function() {
                                if (void 0 !== i) return i;
                                var n = e.get("EXT_texture_filter_anisotropic");
                                return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                            },
                            getMaxPrecision: r,
                            precision: a,
                            logarithmicDepthBuffer: c,
                            maxTextures: l,
                            maxVertexTextures: h,
                            maxTextureSize: u,
                            maxCubemapSize: p,
                            maxAttributes: d,
                            maxVertexUniforms: f,
                            maxVaryings: m,
                            maxFragmentUniforms: v,
                            vertexTextures: g,
                            floatFragmentTextures: y,
                            floatVertexTextures: _,
                            maxSamples: x
                        }
                    }(S, A, t)).isWebGL2 && (A.get("WEBGL_depth_texture"), A.get("OES_texture_float"), A.get("OES_texture_half_float"), A.get("OES_texture_half_float_linear"), A.get("OES_standard_derivatives"), A.get("OES_element_index_uint"), A.get("ANGLE_instanced_arrays")), A.get("OES_texture_float_linear"), Q = new na(S, A, P), (L = new function(t, r, o, a) {
                        var s = new function() {
                                var e = !1,
                                    n = new Fe,
                                    i = null,
                                    r = new Fe(0, 0, 0, 0);
                                return {
                                    setMask: function(n) {
                                        i === n || e || (t.colorMask(n, n, n, n), i = n)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e, i, o, a, s) {
                                        !0 === s && (e *= a, i *= a, o *= a), n.set(e, i, o, a), !1 === r.equals(n) && (t.clearColor(e, i, o, a), r.copy(n))
                                    },
                                    reset: function() {
                                        e = !1, i = null, r.set(-1, 0, 0, 0)
                                    }
                                }
                            },
                            h = new function() {
                                var e = !1,
                                    n = null,
                                    i = null,
                                    r = null;
                                return {
                                    setTest: function(t) {
                                        t ? ot(2929) : at(2929)
                                    },
                                    setMask: function(i) {
                                        n === i || e || (t.depthMask(i), n = i)
                                    },
                                    setFunc: function(e) {
                                        if (i !== e) {
                                            if (e) switch (e) {
                                                case N:
                                                    t.depthFunc(512);
                                                    break;
                                                case B:
                                                    t.depthFunc(519);
                                                    break;
                                                case H:
                                                    t.depthFunc(513);
                                                    break;
                                                case F:
                                                    t.depthFunc(515);
                                                    break;
                                                case k:
                                                    t.depthFunc(514);
                                                    break;
                                                case U:
                                                    t.depthFunc(518);
                                                    break;
                                                case z:
                                                    t.depthFunc(516);
                                                    break;
                                                case G:
                                                    t.depthFunc(517);
                                                    break;
                                                default:
                                                    t.depthFunc(515)
                                            } else t.depthFunc(515);
                                            i = e
                                        }
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        r !== e && (t.clearDepth(e), r = e)
                                    },
                                    reset: function() {
                                        e = !1, n = null, i = null, r = null
                                    }
                                }
                            },
                            u = new function() {
                                var e = !1,
                                    n = null,
                                    i = null,
                                    r = null,
                                    o = null,
                                    a = null,
                                    s = null,
                                    c = null,
                                    l = null;
                                return {
                                    setTest: function(t) {
                                        e || (t ? ot(2960) : at(2960))
                                    },
                                    setMask: function(i) {
                                        n === i || e || (t.stencilMask(i), n = i)
                                    },
                                    setFunc: function(e, n, a) {
                                        i === e && r === n && o === a || (t.stencilFunc(e, n, a), i = e, r = n, o = a)
                                    },
                                    setOp: function(e, n, i) {
                                        a === e && s === n && c === i || (t.stencilOp(e, n, i), a = e, s = n, c = i)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        l !== e && (t.clearStencil(e), l = e)
                                    },
                                    reset: function() {
                                        e = !1, n = null, i = null, r = null, o = null, a = null, s = null, c = null, l = null
                                    }
                                }
                            },
                            p = t.getParameter(34921),
                            x = new Uint8Array(p),
                            b = new Uint8Array(p),
                            w = new Uint8Array(p),
                            M = {},
                            T = null,
                            E = null,
                            S = null,
                            A = null,
                            P = null,
                            L = null,
                            R = null,
                            C = null,
                            O = null,
                            I = null,
                            D = !1,
                            j = null,
                            V = null,
                            W = null,
                            X = null,
                            q = null,
                            Y = t.getParameter(35661),
                            Z = !1,
                            J = 0,
                            K = t.getParameter(7938); - 1 !== K.indexOf("WebGL") ? (J = parseFloat(/^WebGL\ ([0-9])/.exec(K)[1]), Z = J >= 1) : -1 !== K.indexOf("OpenGL ES") && (J = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(K)[1]), Z = J >= 2);
                        var Q = null,
                            $ = {},
                            tt = new Fe,
                            et = new Fe;

                        function nt(e, n, i) {
                            var r = new Uint8Array(4),
                                o = t.createTexture();
                            t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                            for (var a = 0; a < i; a++) t.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
                            return o
                        }
                        var it = {};

                        function rt(e, n) {
                            if (x[e] = 1, 0 === b[e] && (t.enableVertexAttribArray(e), b[e] = 1), w[e] !== n) {
                                var i = a.isWebGL2 ? t : r.get("ANGLE_instanced_arrays");
                                i[a.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, n), w[e] = n
                            }
                        }

                        function ot(e) {
                            !0 !== M[e] && (t.enable(e), M[e] = !0)
                        }

                        function at(e) {
                            !1 !== M[e] && (t.disable(e), M[e] = !1)
                        }

                        function st(e, n, i, r, a, s, c, l) {
                            if (e !== d) {
                                if (S || (ot(3042), S = !0), e === y) a = a || n, s = s || i, c = c || r, n === P && a === C || (t.blendEquationSeparate(o.convert(n), o.convert(a)), P = n, C = a), i === L && r === R && s === O && c === I || (t.blendFuncSeparate(o.convert(i), o.convert(r), o.convert(s), o.convert(c)), L = i, R = r, O = s, I = c), A = e, D = null;
                                else if (e !== A || l !== D) {
                                    if (P === _ && C === _ || (t.blendEquation(32774), P = _, C = _), l) switch (e) {
                                        case f:
                                            t.blendFuncSeparate(1, 771, 1, 771);
                                            break;
                                        case m:
                                            t.blendFunc(1, 1);
                                            break;
                                        case v:
                                            t.blendFuncSeparate(0, 0, 769, 771);
                                            break;
                                        case g:
                                            t.blendFuncSeparate(0, 768, 0, 770);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    } else switch (e) {
                                        case f:
                                            t.blendFuncSeparate(770, 771, 1, 771);
                                            break;
                                        case m:
                                            t.blendFunc(770, 1);
                                            break;
                                        case v:
                                            t.blendFunc(0, 769);
                                            break;
                                        case g:
                                            t.blendFunc(0, 768);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    }
                                    L = null, R = null, O = null, I = null, A = e, D = l
                                }
                            } else S && (at(3042), S = !1)
                        }

                        function ct(e) {
                            j !== e && (e ? t.frontFace(2304) : t.frontFace(2305), j = e)
                        }

                        function lt(r) {
                            r !== e ? (ot(2884), r !== V && (r === n ? t.cullFace(1029) : r === i ? t.cullFace(1028) : t.cullFace(1032))) : at(2884), V = r
                        }

                        function ht(e, n, i) {
                            e ? (ot(32823), X === n && q === i || (t.polygonOffset(n, i), X = n, q = i)) : at(32823)
                        }

                        function ut(e) {
                            void 0 === e && (e = 33984 + Y - 1), Q !== e && (t.activeTexture(e), Q = e)
                        }
                        return it[3553] = nt(3553, 3553, 1), it[34067] = nt(34067, 34069, 6), s.setClear(0, 0, 0, 1), h.setClear(1), u.setClear(0), ot(2929), h.setFunc(F), ct(!1), lt(n), ot(2884), st(d), {
                            buffers: {
                                color: s,
                                depth: h,
                                stencil: u
                            },
                            initAttributes: function() {
                                for (var t = 0, e = x.length; t < e; t++) x[t] = 0
                            },
                            enableAttribute: function(t) {
                                rt(t, 0)
                            },
                            enableAttributeAndDivisor: rt,
                            disableUnusedAttributes: function() {
                                for (var e = 0, n = b.length; e !== n; ++e) b[e] !== x[e] && (t.disableVertexAttribArray(e), b[e] = 0)
                            },
                            enable: ot,
                            disable: at,
                            getCompressedTextureFormats: function() {
                                if (null === T && (T = [], r.get("WEBGL_compressed_texture_pvrtc") || r.get("WEBGL_compressed_texture_s3tc") || r.get("WEBGL_compressed_texture_etc1") || r.get("WEBGL_compressed_texture_astc")))
                                    for (var e = t.getParameter(34467), n = 0; n < e.length; n++) T.push(e[n]);
                                return T
                            },
                            useProgram: function(e) {
                                return E !== e && (t.useProgram(e), E = e, !0)
                            },
                            setBlending: st,
                            setMaterial: function(t, e) {
                                t.side === l ? at(2884) : ot(2884);
                                var n = t.side === c;
                                e && (n = !n), ct(n), t.blending === f && !1 === t.transparent ? st(d) : st(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), h.setFunc(t.depthFunc), h.setTest(t.depthTest), h.setMask(t.depthWrite), s.setMask(t.colorWrite);
                                var i = t.stencilWrite;
                                u.setTest(i), i && (u.setMask(t.stencilWriteMask), u.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), u.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), ht(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                            },
                            setFlipSided: ct,
                            setCullFace: lt,
                            setLineWidth: function(e) {
                                e !== W && (Z && t.lineWidth(e), W = e)
                            },
                            setPolygonOffset: ht,
                            setScissorTest: function(t) {
                                t ? ot(3089) : at(3089)
                            },
                            activeTexture: ut,
                            bindTexture: function(e, n) {
                                null === Q && ut();
                                var i = $[Q];
                                void 0 === i && (i = {
                                    type: void 0,
                                    texture: void 0
                                }, $[Q] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || it[e]), i.type = e, i.texture = n)
                            },
                            compressedTexImage2D: function() {
                                try {
                                    t.compressedTexImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage2D: function() {
                                try {
                                    t.texImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage3D: function() {
                                try {
                                    t.texImage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            scissor: function(e) {
                                !1 === tt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), tt.copy(e))
                            },
                            viewport: function(e) {
                                !1 === et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), et.copy(e))
                            },
                            reset: function() {
                                for (var e = 0; e < b.length; e++) 1 === b[e] && (t.disableVertexAttribArray(e), b[e] = 0);
                                M = {}, T = null, Q = null, $ = {}, E = null, A = null, j = null, V = null, s.reset(), h.reset(), u.reset()
                            }
                        }
                    }(S, A, Q, P)).scissor(ut.copy(yt).multiplyScalar(vt).floor()), L.viewport(ht.copy(gt).multiplyScalar(vt).floor()), R = new function(t) {
                        var e = {
                            frame: 0,
                            calls: 0,
                            triangles: 0,
                            points: 0,
                            lines: 0
                        };
                        return {
                            memory: {
                                geometries: 0,
                                textures: 0
                            },
                            render: e,
                            programs: null,
                            autoReset: !0,
                            reset: function() {
                                e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                            },
                            update: function(t, n, i) {
                                switch (i = i || 1, e.calls++, n) {
                                    case 4:
                                        e.triangles += i * (t / 3);
                                        break;
                                    case 5:
                                    case 6:
                                        e.triangles += i * (t - 2);
                                        break;
                                    case 1:
                                        e.lines += i * (t / 2);
                                        break;
                                    case 3:
                                        e.lines += i * (t - 1);
                                        break;
                                    case 2:
                                        e.lines += i * t;
                                        break;
                                    case 0:
                                        e.points += i * t;
                                        break;
                                    default:
                                        console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                                }
                            }
                        }
                    }(S), C = new function() {
                        var t = new WeakMap;
                        return {
                            get: function(e) {
                                var n = t.get(e);
                                return void 0 === n && (n = {}, t.set(e, n)), n
                            },
                            remove: function(e) {
                                t.delete(e)
                            },
                            update: function(e, n, i) {
                                t.get(e)[n] = i
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }, O = new ea(S, A, L, C, P, Q, R), I = new Tr(S), D = new function(t, e, n) {
                        var i = new WeakMap,
                            r = new WeakMap;

                        function o(t) {
                            var a = t.target,
                                s = i.get(a);
                            for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]);
                            a.removeEventListener("dispose", o), i.delete(a);
                            var l = r.get(s);
                            l && (e.remove(l), r.delete(s)), n.memory.geometries--
                        }

                        function a(t) {
                            var n = [],
                                i = t.index,
                                o = t.attributes.position,
                                a = 0;
                            if (null !== i) {
                                var s = i.array;
                                a = i.version;
                                for (var c = 0, l = s.length; c < l; c += 3) {
                                    var h = s[c + 0],
                                        u = s[c + 1],
                                        p = s[c + 2];
                                    n.push(h, u, u, p, p, h)
                                }
                            } else {
                                var s = o.array;
                                a = o.version;
                                for (var c = 0, l = s.length / 3 - 1; c < l; c += 3) {
                                    var h = c + 0,
                                        u = c + 1,
                                        p = c + 2;
                                    n.push(h, u, u, p, p, h)
                                }
                            }
                            var d = new(yi(n) > 65535 ? fi : pi)(n, 1);
                            d.version = a, e.update(d, 34963);
                            var f = r.get(t);
                            f && e.remove(f), r.set(t, d)
                        }
                        return {
                            get: function(t, e) {
                                var r = i.get(e);
                                return r || (e.addEventListener("dispose", o), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Si).setFromObject(t)), r = e._bufferGeometry), i.set(e, r), n.memory.geometries++, r)
                            },
                            update: function(t) {
                                var n = t.index,
                                    i = t.attributes;
                                for (var r in null !== n && e.update(n, 34963), i) e.update(i[r], 34962);
                                var o = t.morphAttributes;
                                for (var r in o)
                                    for (var a = o[r], s = 0, c = a.length; s < c; s++) e.update(a[s], 34962)
                            },
                            getWireframeAttribute: function(t) {
                                var e = r.get(t);
                                if (e) {
                                    var n = t.index;
                                    null !== n && e.version < n.version && a(t)
                                } else a(t);
                                return r.get(t)
                            }
                        }
                    }(S, I, R), j = new function(t, e, n, i) {
                        var r = {};
                        return {
                            update: function(t) {
                                var o = i.render.frame,
                                    a = t.geometry,
                                    s = e.get(t, a);
                                return r[s.id] !== o && (a.isGeometry && s.updateFromObject(t), e.update(s), r[s.id] = o), t.isInstancedMesh && n.update(t.instanceMatrix, 34962), s
                            },
                            dispose: function() {
                                r = {}
                            }
                        }
                    }(S, D, I, R), Z = new function(t) {
                        var e = {},
                            n = new Float32Array(8);
                        return {
                            update: function(i, r, o, a) {
                                var s = i.morphTargetInfluences,
                                    c = s.length,
                                    l = e[r.id];
                                if (void 0 === l) {
                                    l = [];
                                    for (var h = 0; h < c; h++) l[h] = [h, 0];
                                    e[r.id] = l
                                }
                                for (var u = o.morphTargets && r.morphAttributes.position, p = o.morphNormals && r.morphAttributes.normal, h = 0; h < c; h++) {
                                    var d = l[h];
                                    0 !== d[1] && (u && r.removeAttribute("morphTarget" + h), p && r.removeAttribute("morphNormal" + h))
                                }
                                for (var h = 0; h < c; h++) {
                                    var d = l[h];
                                    d[0] = h, d[1] = s[h]
                                }
                                l.sort(Ar);
                                for (var h = 0; h < 8; h++) {
                                    var d = l[h];
                                    if (d) {
                                        var f = d[0],
                                            m = d[1];
                                        if (m) {
                                            u && r.addAttribute("morphTarget" + h, u[f]), p && r.addAttribute("morphNormal" + h, p[f]), n[h] = m;
                                            continue
                                        }
                                    }
                                    n[h] = 0
                                }
                                a.getUniforms().setValue(t, "morphTargetInfluences", n)
                            }
                        }
                    }(S), V = new Go($, A, P), W = new function() {
                        var t = new WeakMap;

                        function e(n) {
                            var i = n.target;
                            i.removeEventListener("dispose", e), t.delete(i)
                        }
                        return {
                            get: function(n, i) {
                                var r, o = t.get(n);
                                return void 0 === o ? (r = new Wo, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : void 0 === (r = o.get(i)) && (r = new Wo, o.set(i, r)), r
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }, X = new function() {
                        var t = new WeakMap;

                        function e(n) {
                            var i = n.target;
                            i.removeEventListener("dispose", e), t.delete(i)
                        }
                        return {
                            get: function(n, i) {
                                var r;
                                return !1 === t.has(n) ? (r = new Zo, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : !1 === t.get(n).has(i) ? (r = new Zo, t.get(n).set(i, r)) : r = t.get(n).get(i), r
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }, Y = new function(t, e, n, i) {
                        var r, o, a = new $n(0),
                            l = 0,
                            h = null,
                            u = 0;

                        function p(t, n) {
                            e.buffers.color.setClear(t.r, t.g, t.b, n, i)
                        }
                        return {
                            getClearColor: function() {
                                return a
                            },
                            setClearColor: function(t, e) {
                                a.set(t), p(a, l = void 0 !== e ? e : 1)
                            },
                            getClearAlpha: function() {
                                return l
                            },
                            setClearAlpha: function(t) {
                                p(a, l = t)
                            },
                            render: function(e, i, d, f) {
                                var m = i.background,
                                    v = t.vr,
                                    g = v.getSession && v.getSession();
                                if (g && "additive" === g.environmentBlendMode && (m = null), null === m ? (p(a, l), h = null, u = 0) : m && m.isColor && (p(m, 1), f = !0, h = null, u = 0), (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.isWebGLRenderTargetCube)) {
                                    void 0 === o && ((o = new Vi(new $i(1, 1, 1), new or({
                                        type: "BackgroundCubeMaterial",
                                        uniforms: tr(wr.cube.uniforms),
                                        vertexShader: wr.cube.vertexShader,
                                        fragmentShader: wr.cube.fragmentShader,
                                        side: c,
                                        depthTest: !1,
                                        depthWrite: !1,
                                        fog: !1
                                    }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(t, e, n) {
                                        this.matrixWorld.copyPosition(n.matrixWorld)
                                    }, Object.defineProperty(o.material, "map", {
                                        get: function() {
                                            return this.uniforms.tCube.value
                                        }
                                    }), n.update(o));
                                    var y = m.isWebGLRenderTargetCube ? m.texture : m;
                                    o.material.uniforms.tCube.value = y, o.material.uniforms.tFlip.value = m.isWebGLRenderTargetCube ? 1 : -1, h === m && u === y.version || (o.material.needsUpdate = !0, h = m, u = y.version), e.unshift(o, o.geometry, o.material, 0, 0, null)
                                } else m && m.isTexture && (void 0 === r && ((r = new Vi(new Sr(2, 2), new or({
                                    type: "BackgroundMaterial",
                                    uniforms: tr(wr.background.uniforms),
                                    vertexShader: wr.background.vertexShader,
                                    fragmentShader: wr.background.fragmentShader,
                                    side: s,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                }))).geometry.removeAttribute("normal"), Object.defineProperty(r.material, "map", {
                                    get: function() {
                                        return this.uniforms.t2D.value
                                    }
                                }), n.update(r)), r.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), r.material.uniforms.uvTransform.value.copy(m.matrix), h === m && u === m.version || (r.material.needsUpdate = !0, h = m, u = m.version), e.unshift(r, r.geometry, r.material, 0, 0, null))
                            }
                        }
                    }($, L, j, x), J = new function(t, e, n, i) {
                        var r;
                        this.setMode = function(t) {
                            r = t
                        }, this.render = function(e, i) {
                            t.drawArrays(r, e, i), n.update(i, r)
                        }, this.renderInstances = function(o, a, s, c) {
                            if (0 !== c) {
                                var l, h;
                                if (i.isWebGL2) l = t, h = "drawArraysInstanced";
                                else if (l = e.get("ANGLE_instanced_arrays"), h = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                                l[h](r, a, s, c), n.update(s, r, c)
                            }
                        }
                    }(S, A, R, P), K = new function(t, e, n, i) {
                        var r, o, a;
                        this.setMode = function(t) {
                            r = t
                        }, this.setIndex = function(t) {
                            o = t.type, a = t.bytesPerElement
                        }, this.render = function(e, i) {
                            t.drawElements(r, i, o, e * a), n.update(i, r)
                        }, this.renderInstances = function(s, c, l, h) {
                            if (0 !== h) {
                                var u, p;
                                if (i.isWebGL2) u = t, p = "drawElementsInstanced";
                                else if (u = e.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                                u[p](r, l, o, c * a, h), n.update(l, r, h)
                            }
                        }
                    }(S, A, R, P), R.programs = V.programs, $.capabilities = P, $.extensions = A, $.properties = C, $.renderLists = W, $.state = L, $.info = R
                }
                Ct();
                var Ot = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new pa($, S) : new ua($);
                this.vr = Ot;
                var It = new ra($, S),
                    Dt = new ta($, j, P.maxTextureSize);

                function Nt(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), tt = !0
                }

                function Bt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), tt = !1, Ct()
                }

                function Ht(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", Ht),
                        function(t) {
                            Ft(t), C.remove(t)
                        }(e)
                }

                function Ft(t) {
                    var e = C.get(t).program;
                    t.program = void 0, void 0 !== e && V.releaseProgram(e)
                }
                this.shadowMap = Dt, this.getContext = function() {
                    return S
                }, this.getContextAttributes = function() {
                    return S.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var t = A.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    var t = A.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return vt
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (vt = t, this.setSize(dt, mt, !1))
                }, this.getSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new Ae), t.set(dt, mt)
                }, this.setSize = function(t, e, n) {
                    Ot.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (dt = t, mt = e, r.width = Math.floor(t * vt), r.height = Math.floor(e * vt), !1 !== n && (r.style.width = t + "px", r.style.height = e + "px"), this.setViewport(0, 0, t, e))
                }, this.getDrawingBufferSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new Ae), t.set(dt * vt, mt * vt).floor()
                }, this.setDrawingBufferSize = function(t, e, n) {
                    dt = t, mt = e, vt = n, r.width = Math.floor(t * n), r.height = Math.floor(e * n), this.setViewport(0, 0, t, e)
                }, this.getCurrentViewport = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Fe), t.copy(ht)
                }, this.getViewport = function(t) {
                    return t.copy(gt)
                }, this.setViewport = function(t, e, n, i) {
                    t.isVector4 ? gt.set(t.x, t.y, t.z, t.w) : gt.set(t, e, n, i), L.viewport(ht.copy(gt).multiplyScalar(vt).floor())
                }, this.getScissor = function(t) {
                    return t.copy(yt)
                }, this.setScissor = function(t, e, n, i) {
                    t.isVector4 ? yt.set(t.x, t.y, t.z, t.w) : yt.set(t, e, n, i), L.scissor(ut.copy(yt).multiplyScalar(vt).floor())
                }, this.getScissorTest = function() {
                    return _t
                }, this.setScissorTest = function(t) {
                    L.setScissorTest(_t = t)
                }, this.getClearColor = function() {
                    return Y.getClearColor()
                }, this.setClearColor = function() {
                    Y.setClearColor.apply(Y, arguments)
                }, this.getClearAlpha = function() {
                    return Y.getClearAlpha()
                }, this.setClearAlpha = function() {
                    Y.setClearAlpha.apply(Y, arguments)
                }, this.clear = function(t, e, n) {
                    var i = 0;
                    (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), S.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    r.removeEventListener("webglcontextlost", Nt, !1), r.removeEventListener("webglcontextrestored", Bt, !1), W.dispose(), X.dispose(), C.dispose(), j.dispose(), Ot.dispose(), Ut.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    L.initAttributes();
                    var n = C.get(t);
                    t.hasPositions && !n.position && (n.position = S.createBuffer()), t.hasNormals && !n.normal && (n.normal = S.createBuffer()), t.hasUvs && !n.uv && (n.uv = S.createBuffer()), t.hasColors && !n.color && (n.color = S.createBuffer());
                    var i = e.getAttributes();
                    t.hasPositions && (S.bindBuffer(34962, n.position), S.bufferData(34962, t.positionArray, 35048), L.enableAttribute(i.position), S.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (S.bindBuffer(34962, n.normal), S.bufferData(34962, t.normalArray, 35048), L.enableAttribute(i.normal), S.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (S.bindBuffer(34962, n.uv), S.bufferData(34962, t.uvArray, 35048), L.enableAttribute(i.uv), S.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (S.bindBuffer(34962, n.color), S.bufferData(34962, t.colorArray, 35048), L.enableAttribute(i.color), S.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), L.disableUnusedAttributes(), S.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, n, i, r, o) {
                    var a = r.isMesh && r.matrixWorld.determinant() < 0;
                    L.setMaterial(i, a);
                    var s = Vt(t, e, i, r),
                        c = !1;
                    st.geometry === n.id && st.program === s.id && st.wireframe === (!0 === i.wireframe) || (st.geometry = n.id, st.program = s.id, st.wireframe = !0 === i.wireframe, c = !0), r.morphTargetInfluences && (Z.update(r, n, i, s), c = !0);
                    var l, h = n.index,
                        u = n.attributes.position,
                        p = 1;
                    !0 === i.wireframe && (h = D.getWireframeAttribute(n), p = 2);
                    var d = J;
                    null !== h && (l = I.get(h), (d = K).setIndex(l)), c && (function(t, e, n, i) {
                        if (!1 !== P.isWebGL2 || !t.isInstancedMesh && !e.isInstancedBufferGeometry || null !== A.get("ANGLE_instanced_arrays")) {
                            L.initAttributes();
                            var r = e.attributes,
                                o = i.getAttributes(),
                                a = n.defaultAttributeValues;
                            for (var s in o) {
                                var c = o[s];
                                if (c >= 0) {
                                    var l = r[s];
                                    if (void 0 !== l) {
                                        var h = l.normalized,
                                            u = l.itemSize,
                                            p = I.get(l);
                                        if (void 0 === p) continue;
                                        var d = p.buffer,
                                            f = p.type,
                                            m = p.bytesPerElement;
                                        if (l.isInterleavedBufferAttribute) {
                                            var v = l.data,
                                                g = v.stride,
                                                y = l.offset;
                                            v && v.isInstancedInterleavedBuffer ? (L.enableAttributeAndDivisor(c, v.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = v.meshPerAttribute * v.count)) : L.enableAttribute(c), S.bindBuffer(34962, d), S.vertexAttribPointer(c, u, f, h, g * m, y * m)
                                        } else l.isInstancedBufferAttribute ? (L.enableAttributeAndDivisor(c, l.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = l.meshPerAttribute * l.count)) : L.enableAttribute(c), S.bindBuffer(34962, d), S.vertexAttribPointer(c, u, f, h, 0, 0)
                                    } else if ("instanceMatrix" === s) {
                                        var p = I.get(t.instanceMatrix);
                                        if (void 0 === p) continue;
                                        var d = p.buffer,
                                            f = p.type;
                                        L.enableAttributeAndDivisor(c + 0, 1), L.enableAttributeAndDivisor(c + 1, 1), L.enableAttributeAndDivisor(c + 2, 1), L.enableAttributeAndDivisor(c + 3, 1), S.bindBuffer(34962, d), S.vertexAttribPointer(c + 0, 4, f, !1, 64, 0), S.vertexAttribPointer(c + 1, 4, f, !1, 64, 16), S.vertexAttribPointer(c + 2, 4, f, !1, 64, 32), S.vertexAttribPointer(c + 3, 4, f, !1, 64, 48)
                                    } else if (void 0 !== a) {
                                        var _ = a[s];
                                        if (void 0 !== _) switch (_.length) {
                                            case 2:
                                                S.vertexAttrib2fv(c, _);
                                                break;
                                            case 3:
                                                S.vertexAttrib3fv(c, _);
                                                break;
                                            case 4:
                                                S.vertexAttrib4fv(c, _);
                                                break;
                                            default:
                                                S.vertexAttrib1fv(c, _)
                                        }
                                    }
                                }
                            }
                            L.disableUnusedAttributes()
                        }
                    }(r, n, i, s), null !== h && S.bindBuffer(34963, l.buffer));
                    var f = 1 / 0;
                    null !== h ? f = h.count : void 0 !== u && (f = u.count);
                    var m = n.drawRange.start * p,
                        v = n.drawRange.count * p,
                        g = null !== o ? o.start * p : 0,
                        y = null !== o ? o.count * p : 1 / 0,
                        _ = Math.max(m, g),
                        x = Math.min(f, m + v, g + y) - 1,
                        b = Math.max(0, x - _ + 1);
                    if (0 !== b) {
                        if (r.isMesh)
                            if (!0 === i.wireframe) L.setLineWidth(i.wireframeLinewidth * Lt()), d.setMode(1);
                            else switch (r.drawMode) {
                                case ae:
                                    d.setMode(4);
                                    break;
                                case se:
                                    d.setMode(5);
                                    break;
                                case ce:
                                    d.setMode(6)
                            } else if (r.isLine) {
                                var w = i.linewidth;
                                void 0 === w && (w = 1), L.setLineWidth(w * Lt()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                            } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                        r.isInstancedMesh ? d.renderInstances(n, _, b, r.count) : n.isInstancedBufferGeometry ? d.renderInstances(n, _, b, n.maxInstancedCount) : d.render(_, b)
                    }
                }, this.compile = function(t, e) {
                    (E = X.get(t, e)).init(), t.traverse(function(t) {
                        t.isLight && (E.pushLight(t), t.castShadow && E.pushShadow(t))
                    }), E.setupLights(e), t.traverse(function(e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var n = 0; n < e.material.length; n++) jt(e.material[n], t.fog, e);
                            else jt(e.material, t.fog, e)
                    })
                };
                var kt = null,
                    Ut = new Mr;

                function zt(t, e, n, i) {
                    for (var r = 0, o = t.length; r < o; r++) {
                        var a = t[r],
                            s = a.object,
                            c = a.geometry,
                            l = void 0 === i ? a.material : i,
                            h = a.group;
                        if (n.isArrayCamera)
                            if (lt = n, Ot.enabled && It.isAvailable()) Gt(s, e, n, c, l, h);
                            else
                                for (var u = n.cameras, p = 0, d = u.length; p < d; p++) {
                                    var f = u[p];
                                    s.layers.test(f.layers) && (L.viewport(ht.copy(f.viewport)), E.setupLights(f), Gt(s, e, f, c, l, h))
                                } else lt = null, Gt(s, e, n, c, l, h)
                    }
                }

                function Gt(t, e, n, i, r, o) {
                    if (t.onBeforeRender($, e, n, i, r, o), E = X.get(e, lt || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        L.setMaterial(r);
                        var a = Vt(n, e.fog, r, t);
                        st.geometry = null, st.program = null, st.wireframe = !1,
                            function(t, e) {
                                t.render(function(t) {
                                    $.renderBufferImmediate(t, e)
                                })
                            }(t, a)
                    } else $.renderBufferDirect(n, e.fog, i, r, t, o);
                    t.onAfterRender($, e, n, i, r, o), E = X.get(e, lt || n)
                }

                function jt(t, e, n) {
                    var i = C.get(t),
                        r = E.state.lights,
                        o = E.state.shadowsArray,
                        a = r.state.version,
                        s = V.getParameters(t, r.state, o, e, Mt.numPlanes, Mt.numIntersection, n),
                        c = V.getProgramCode(t, s),
                        l = i.program,
                        h = !0;
                    if (void 0 === l) t.addEventListener("dispose", Ht);
                    else if (l.code !== c) Ft(t);
                    else if (i.lightsStateVersion !== a) i.lightsStateVersion = a, h = !1;
                    else {
                        if (void 0 !== s.shaderID) return;
                        h = !1
                    }
                    if (h) {
                        if (s.shaderID) {
                            var u = wr[s.shaderID];
                            i.shader = {
                                name: t.type,
                                uniforms: tr(u.uniforms),
                                vertexShader: u.vertexShader,
                                fragmentShader: u.fragmentShader
                            }
                        } else i.shader = {
                            name: t.type,
                            uniforms: t.uniforms,
                            vertexShader: t.vertexShader,
                            fragmentShader: t.fragmentShader
                        };
                        t.onBeforeCompile(i.shader, $), c = V.getProgramCode(t, s), l = V.acquireProgram(t, i.shader, s, c), i.program = l, t.program = l
                    }
                    var p = l.getAttributes();
                    if (t.morphTargets) {
                        t.numSupportedMorphTargets = 0;
                        for (var d = 0; d < $.maxMorphTargets; d++) p["morphTarget" + d] >= 0 && t.numSupportedMorphTargets++
                    }
                    if (t.morphNormals) {
                        t.numSupportedMorphNormals = 0;
                        for (var d = 0; d < $.maxMorphNormals; d++) p["morphNormal" + d] >= 0 && t.numSupportedMorphNormals++
                    }
                    var f = i.shader.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = Mt.numPlanes, i.numIntersection = Mt.numIntersection, f.clippingPlanes = Mt.uniform), i.fog = e, i.needsLights = function(t) {
                        return t.isMeshLambertMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t), i.lightsStateVersion = a, i.needsLights && (f.ambientLightColor.value = r.state.ambient, f.lightProbe.value = r.state.probe, f.directionalLights.value = r.state.directional, f.spotLights.value = r.state.spot, f.rectAreaLights.value = r.state.rectArea, f.pointLights.value = r.state.point, f.hemisphereLights.value = r.state.hemi, f.directionalShadowMap.value = r.state.directionalShadowMap, f.directionalShadowMatrix.value = r.state.directionalShadowMatrix, f.spotShadowMap.value = r.state.spotShadowMap, f.spotShadowMatrix.value = r.state.spotShadowMatrix, f.pointShadowMap.value = r.state.pointShadowMap, f.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    var m = i.program.getUniforms(),
                        v = Eo.seqWithValue(m.seq, f);
                    i.uniformsList = v
                }

                function Vt(t, e, n, i) {
                    O.resetTextureUnits();
                    var r = C.get(n),
                        o = E.state.lights;
                    if (Tt && (Et || t !== ct)) {
                        var a = t === ct && n.id === at;
                        Mt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, a)
                    }!1 === n.needsUpdate && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== e ? n.needsUpdate = !0 : r.needsLights && r.lightsStateVersion !== o.state.version ? n.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === Mt.numPlanes && r.numIntersection === Mt.numIntersection || (n.needsUpdate = !0)), n.needsUpdate && (jt(n, e, i), n.needsUpdate = !1);
                    var s = !1,
                        l = !1,
                        h = !1,
                        u = r.program,
                        p = u.getUniforms(),
                        d = r.shader.uniforms;
                    if (L.useProgram(u.program) && (s = !0, l = !0, h = !0), n.id !== at && (at = n.id, l = !0), s || ct !== t) {
                        if (u.numMultiviewViews > 0 ? It.updateCameraProjectionMatricesUniform(t, p) : p.setValue(S, "projectionMatrix", t.projectionMatrix), P.logarithmicDepthBuffer && p.setValue(S, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), ct !== t && (ct = t, l = !0, h = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var f = p.map.cameraPosition;
                            void 0 !== f && f.setValue(S, At.setFromMatrixPosition(t.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && (u.numMultiviewViews > 0 ? It.updateCameraViewMatricesUniform(t, p) : p.setValue(S, "viewMatrix", t.matrixWorldInverse))
                    }
                    if (n.skinning) {
                        p.setOptional(S, i, "bindMatrix"), p.setOptional(S, i, "bindMatrixInverse");
                        var m = i.skeleton;
                        if (m) {
                            var v = m.bones;
                            if (P.floatVertexTextures) {
                                if (void 0 === m.boneTexture) {
                                    var g = Math.sqrt(4 * v.length);
                                    g = Se.ceilPowerOfTwo(g), g = Math.max(g, 4);
                                    var y = new Float32Array(g * g * 4);
                                    y.set(m.boneMatrices);
                                    var _ = new pr(y, g, g, Pt, xt);
                                    m.boneMatrices = y, m.boneTexture = _, m.boneTextureSize = g
                                }
                                p.setValue(S, "boneTexture", m.boneTexture, O), p.setValue(S, "boneTextureSize", m.boneTextureSize)
                            } else p.setOptional(S, m, "boneMatrices")
                        }
                    }
                    return (l || r.receiveShadow !== i.receiveShadow) && (r.receiveShadow = i.receiveShadow, p.setValue(S, "receiveShadow", i.receiveShadow)), l && (p.setValue(S, "toneMappingExposure", $.toneMappingExposure), p.setValue(S, "toneMappingWhitePoint", $.toneMappingWhitePoint), r.needsLights && function(t, e) {
                        t.ambientLightColor.needsUpdate = e, t.lightProbe.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                    }(d, h), e && n.fog && function(t, e) {
                        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    }(d, e), n.isMeshBasicMaterial ? Wt(d, n) : n.isMeshLambertMaterial ? (Wt(d, n), function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(d, n)) : n.isMeshPhongMaterial ? (Wt(d, n), n.isMeshToonMaterial ? function(t, e) {
                        Xt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(d, n) : Xt(d, n)) : n.isMeshStandardMaterial ? (Wt(d, n), n.isMeshPhysicalMaterial ? function(t, e) {
                        qt(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === c && t.clearcoatNormalScale.value.negate()), t.transparency.value = e.transparency
                    }(d, n) : qt(d, n)) : n.isMeshMatcapMaterial ? (Wt(d, n), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === c && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === c && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(d, n)) : n.isMeshDepthMaterial ? (Wt(d, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(d, n)) : n.isMeshDistanceMaterial ? (Wt(d, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(d, n)) : n.isMeshNormalMaterial ? (Wt(d, n), function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === c && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === c && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(d, n)) : n.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                    }(d, n), n.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(d, n)) : n.isPointsMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * vt, t.scale.value = .5 * mt, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(d, n) : n.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(d, n) : n.isShadowMaterial && (d.color.value.copy(n.color), d.opacity.value = n.opacity), void 0 !== d.ltc_1 && (d.ltc_1.value = br.LTC_1), void 0 !== d.ltc_2 && (d.ltc_2.value = br.LTC_2), Eo.upload(S, r.uniformsList, d, O)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Eo.upload(S, r.uniformsList, d, O), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && p.setValue(S, "center", i.center), u.numMultiviewViews > 0 ? It.updateObjectMatricesUniforms(i, t, p) : (p.setValue(S, "modelViewMatrix", i.modelViewMatrix), p.setValue(S, "normalMatrix", i.normalMatrix)), p.setValue(S, "modelMatrix", i.matrixWorld), u
                }

                function Wt(t, e) {
                    var n;
                    t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = C.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }

                function Xt(t, e) {
                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === c && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === c && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function qt(t, e) {
                    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === c && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === c && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }
                Ut.setAnimationLoop(function(t) {
                    Ot.isPresenting() || kt && kt(t)
                }), "undefined" != typeof window && Ut.setContext(window), this.setAnimationLoop = function(t) {
                    kt = t, Ot.setAnimationLoop(t), Ut.start()
                }, this.render = function(t, e) {
                    var n, i;
                    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), e && e.isCamera) {
                        if (!tt) {
                            st.geometry = null, st.program = null, st.wireframe = !1, at = -1, ct = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Ot.enabled && (e = Ot.getCamera(e)), (E = X.get(t, e)).init(), t.onBeforeRender($, t, e, n || rt), St.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), wt.setFromMatrix(St), Et = this.localClippingEnabled, Tt = Mt.init(this.clippingPlanes, Et, e), (T = W.get(t, e)).init(),
                                function t(e, n, i, r) {
                                    if (!1 !== e.visible) {
                                        var o = e.layers.test(n.layers);
                                        if (o)
                                            if (e.isGroup) i = e.renderOrder;
                                            else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
                                        else if (e.isLight) E.pushLight(e), e.castShadow && E.pushShadow(e);
                                        else if (e.isSprite) {
                                            if (!e.frustumCulled || wt.intersectsSprite(e)) {
                                                r && At.setFromMatrixPosition(e.matrixWorld).applyMatrix4(St);
                                                var a = j.update(e),
                                                    s = e.material;
                                                s.visible && T.push(e, a, s, i, At.z, null)
                                            }
                                        } else if (e.isImmediateRenderObject) r && At.setFromMatrixPosition(e.matrixWorld).applyMatrix4(St), T.push(e, null, e.material, i, At.z, null);
                                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== R.render.frame && (e.skeleton.update(), e.skeleton.frame = R.render.frame), !e.frustumCulled || wt.intersectsObject(e))) {
                                            r && At.setFromMatrixPosition(e.matrixWorld).applyMatrix4(St);
                                            var a = j.update(e),
                                                s = e.material;
                                            if (Array.isArray(s))
                                                for (var c = a.groups, l = 0, h = c.length; l < h; l++) {
                                                    var u = c[l],
                                                        p = s[u.materialIndex];
                                                    p && p.visible && T.push(e, a, p, i, At.z, u)
                                                } else s.visible && T.push(e, a, s, i, At.z, null)
                                        }
                                        for (var d = e.children, l = 0, h = d.length; l < h; l++) t(d[l], n, i, r)
                                    }
                                }(t, e, 0, $.sortObjects), !0 === $.sortObjects && T.sort(), Tt && Mt.beginShadows();
                            var r = E.state.shadowsArray;
                            Dt.render(r, t, e), E.setupLights(e), Tt && Mt.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), Ot.enabled && It.isAvailable() && It.attachCamera(e), Y.render(T, t, e, i);
                            var o = T.opaque,
                                a = T.transparent;
                            if (t.overrideMaterial) {
                                var s = t.overrideMaterial;
                                o.length && zt(o, t, e, s), a.length && zt(a, t, e, s)
                            } else o.length && zt(o, t, e), a.length && zt(a, t, e);
                            t.onAfterRender($, t, e), null !== rt && (O.updateRenderTargetMipmap(rt), O.updateMultisampleRenderTarget(rt)), L.buffers.depth.setTest(!0), L.buffers.depth.setMask(!0), L.buffers.color.setMask(!0), L.setPolygonOffset(!1), Ot.enabled && (It.isAvailable() && It.detachCamera(e), Ot.submitFrame()), T = null, E = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.setFramebuffer = function(t) {
                    et !== t && S.bindFramebuffer(36160, t), et = t
                }, this.getActiveCubeFace = function() {
                    return nt
                }, this.getActiveMipmapLevel = function() {
                    return it
                }, this.getRenderTarget = function() {
                    return rt
                }, this.setRenderTarget = function(t, e, n) {
                    rt = t, nt = e, it = n, t && void 0 === C.get(t).__webglFramebuffer && O.setupRenderTarget(t);
                    var i = et,
                        r = !1;
                    if (t) {
                        var o = C.get(t).__webglFramebuffer;
                        t.isWebGLRenderTargetCube ? (i = o[e || 0], r = !0) : i = t.isWebGLMultisampleRenderTarget ? C.get(t).__webglMultisampledFramebuffer : o, ht.copy(t.viewport), ut.copy(t.scissor), pt = t.scissorTest
                    } else ht.copy(gt).multiplyScalar(vt).floor(), ut.copy(yt).multiplyScalar(vt).floor(), pt = _t;
                    if (ot !== i && (S.bindFramebuffer(36160, i), ot = i), L.viewport(ht), L.scissor(ut), L.setScissorTest(pt), r) {
                        var a = C.get(t.texture);
                        S.framebufferTexture2D(36160, 36064, 34069 + (e || 0), a.__webglTexture, n || 0)
                    }
                }, this.readRenderTargetPixels = function(t, e, n, i, r, o, a) {
                    if (t && t.isWebGLRenderTarget) {
                        var s = C.get(t).__webglFramebuffer;
                        if (t.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s) {
                            var c = !1;
                            s !== ot && (S.bindFramebuffer(36160, s), c = !0);
                            try {
                                var l = t.texture,
                                    h = l.format,
                                    u = l.type;
                                if (h !== Pt && Q.convert(h) !== S.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(u === ft || Q.convert(u) === S.getParameter(35738) || u === xt && (P.isWebGL2 || A.get("OES_texture_float") || A.get("WEBGL_color_buffer_float")) || u === bt && (P.isWebGL2 ? A.get("EXT_color_buffer_float") : A.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === S.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && S.readPixels(e, n, i, r, Q.convert(h), Q.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                c && S.bindFramebuffer(36160, ot)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function(t, e, n) {
                    var i = e.image.width,
                        r = e.image.height,
                        o = Q.convert(e.format);
                    O.setTexture2D(e, 0), S.copyTexImage2D(3553, n || 0, o, t.x, t.y, i, r, 0)
                }, this.copyTextureToTexture = function(t, e, n, i) {
                    var r = e.image.width,
                        o = e.image.height,
                        a = Q.convert(n.format),
                        s = Q.convert(n.type);
                    O.setTexture2D(n, 0), e.isDataTexture ? S.texSubImage2D(3553, i || 0, t.x, t.y, r, o, a, s, e.image.data) : S.texSubImage2D(3553, i || 0, t.x, t.y, a, s, e.image)
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function fa(t, e) {
                this.name = "", this.color = new $n(t), this.density = void 0 !== e ? e : 25e-5
            }

            function ma(t, e, n) {
                this.name = "", this.color = new $n(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
            }

            function va(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function ga(t, e, n, i) {
                this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
            }

            function ya(t) {
                oi.call(this), this.type = "SpriteMaterial", this.color = new $n(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
            }
            Object.assign(ua.prototype, Me.prototype), Object.assign(pa.prototype, Me.prototype), Object.assign(fa.prototype, {
                isFogExp2: !0,
                clone: function() {
                    return new fa(this.color, this.density)
                },
                toJSON: function() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }), Object.assign(ma.prototype, {
                isFog: !0,
                clone: function() {
                    return new ma(this.color, this.near, this.far)
                },
                toJSON: function() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }), Object.defineProperty(va.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(va.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride, n *= e.stride;
                    for (var i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                }
            }), Object.defineProperties(ga.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(ga.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
                }
            }), ya.prototype = Object.create(oi.prototype), ya.prototype.constructor = ya, ya.prototype.isSpriteMaterial = !0, ya.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            };
            var _a = new Ce,
                xa = new Ce,
                ba = new Ce,
                wa = new Ae,
                Ma = new Ae,
                Ta = new Ye,
                Ea = new Ce,
                Sa = new Ce,
                Aa = new Ce,
                Pa = new Ae,
                La = new Ae,
                Ra = new Ae;

            function Ca(t) {
                if (dn.call(this), this.type = "Sprite", void 0 === sa) {
                    sa = new Si;
                    var e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        n = new va(e, 5);
                    sa.setIndex([0, 1, 2, 0, 2, 3]), sa.addAttribute("position", new ga(n, 3, 0, !1)), sa.addAttribute("uv", new ga(n, 2, 3, !1))
                }
                this.geometry = sa, this.material = void 0 !== t ? t : new ya, this.center = new Ae(.5, .5)
            }

            function Oa(t, e, n, i, r, o) {
                wa.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Ma.x = o * wa.x - r * wa.y, Ma.y = r * wa.x + o * wa.y) : Ma.copy(wa), t.copy(e), t.x += Ma.x, t.y += Ma.y, t.applyMatrix4(Ta)
            }
            Ca.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: Ca,
                isSprite: !0,
                raycast: function(t, e) {
                    null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), xa.setFromMatrixScale(this.matrixWorld), Ta.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ba.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && xa.multiplyScalar(-ba.z);
                    var n, i, r = this.material.rotation;
                    0 !== r && (i = Math.cos(r), n = Math.sin(r));
                    var o = this.center;
                    Oa(Ea.set(-.5, -.5, 0), ba, o, xa, n, i), Oa(Sa.set(.5, -.5, 0), ba, o, xa, n, i), Oa(Aa.set(.5, .5, 0), ba, o, xa, n, i), Pa.set(0, 0), La.set(1, 0), Ra.set(1, 1);
                    var a = t.ray.intersectTriangle(Ea, Sa, Aa, !1, _a);
                    if (null !== a || (Oa(Sa.set(-.5, .5, 0), ba, o, xa, n, i), La.set(0, 1), null !== (a = t.ray.intersectTriangle(Ea, Aa, Sa, !1, _a)))) {
                        var s = t.ray.origin.distanceTo(_a);
                        s < t.near || s > t.far || e.push({
                            distance: s,
                            point: _a.clone(),
                            uv: Zn.getUV(_a, Ea, Sa, Aa, Pa, La, Ra, new Ae),
                            face: null,
                            object: this
                        })
                    }
                },
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function(t) {
                    return dn.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
                }
            });
            var Ia = new Ce,
                Da = new Ce;

            function Na() {
                dn.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                }), this.autoUpdate = !0
            }

            function Ba(t, e) {
                t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Vi.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ye, this.bindMatrixInverse = new Ye
            }
            Na.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: Na,
                isLOD: !0,
                copy: function(t) {
                    dn.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++);
                    return n.splice(i, 0, {
                        distance: e,
                        object: t
                    }), this.add(t), this
                },
                getObjectForDistance: function(t) {
                    for (var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                    return e[n - 1].object
                },
                raycast: function(t, e) {
                    Ia.setFromMatrixPosition(this.matrixWorld);
                    var n = t.ray.origin.distanceTo(Ia);
                    this.getObjectForDistance(n).raycast(t, e)
                },
                update: function(t) {
                    var e = this.levels;
                    if (e.length > 1) {
                        Ia.setFromMatrixPosition(t.matrixWorld), Da.setFromMatrixPosition(this.matrixWorld);
                        var n = Ia.distanceTo(Da);
                        e[0].object.visible = !0;
                        for (var i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                        for (; i < r; i++) e[i].object.visible = !1
                    }
                },
                toJSON: function(t) {
                    var e = dn.prototype.toJSON.call(this, t);
                    e.object.levels = [];
                    for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                        var o = n[i];
                        e.object.levels.push({
                            object: o.object.uuid,
                            distance: o.distance
                        })
                    }
                    return e
                }
            }), Ba.prototype = Object.assign(Object.create(Vi.prototype), {
                constructor: Ba,
                isSkinnedMesh: !0,
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    for (var t = new Fe, e = this.geometry.attributes.skinWeight, n = 0, i = e.count; n < i; n++) {
                        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                        var r = 1 / t.manhattanLength();
                        r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    Vi.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });
            var Ha = new Ye,
                Fa = new Ye;

            function ka(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Ye)
                }
            }

            function Ua() {
                dn.call(this), this.type = "Bone"
            }

            function za(t, e, n) {
                Vi.call(this, t, e), this.instanceMatrix = new si(new Float32Array(16 * n), 16), this.count = n
            }

            function Ga(t) {
                oi.call(this), this.type = "LineBasicMaterial", this.color = new $n(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
            }
            Object.assign(ka.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var n = new Ye;
                        this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function() {
                    var t, e, n;
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                },
                update: function() {
                    for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, o = t.length; r < o; r++) {
                        var a = t[r] ? t[r].matrixWorld : Fa;
                        Ha.multiplyMatrices(a, e[r]), Ha.toArray(n, 16 * r)
                    }
                    void 0 !== i && (i.needsUpdate = !0)
                },
                clone: function() {
                    return new ka(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (var e = 0, n = this.bones.length; e < n; e++) {
                        var i = this.bones[e];
                        if (i.name === t) return i
                    }
                }
            }), Ua.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: Ua,
                isBone: !0
            }), za.prototype = Object.assign(Object.create(Vi.prototype), {
                constructor: za,
                isInstancedMesh: !0,
                raycast: function() {},
                setMatrixAt: function(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t)
                },
                updateMorphTargets: function() {}
            }), Ga.prototype = Object.create(oi.prototype), Ga.prototype.constructor = Ga, Ga.prototype.isLineBasicMaterial = !0, Ga.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            };
            var ja = new Ce,
                Va = new Ce,
                Wa = new Ye,
                Xa = new Fn,
                qa = new Rn;

            function Ya(t, e, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), dn.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Si, this.material = void 0 !== e ? e : new Ga({
                    color: 16777215 * Math.random()
                })
            }
            Ya.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: Ya,
                isLine: !0,
                computeLineDistances: function() {
                    var t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            for (var e = t.attributes.position, n = [0], i = 1, r = e.count; i < r; i++) ja.fromBufferAttribute(e, i - 1), Va.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += ja.distanceTo(Va);
                            t.addAttribute("lineDistance", new mi(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (t.isGeometry) {
                        var o = t.vertices,
                            n = t.lineDistances;
                        n[0] = 0;
                        for (var i = 1, r = o.length; i < r; i++) n[i] = n[i - 1], n[i] += o[i - 1].distanceTo(o[i])
                    }
                    return this
                },
                raycast: function(t, e) {
                    var n = t.linePrecision,
                        i = this.geometry,
                        r = this.matrixWorld;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), qa.copy(i.boundingSphere), qa.applyMatrix4(r), qa.radius += n, !1 !== t.ray.intersectsSphere(qa)) {
                        Wa.getInverse(r), Xa.copy(t.ray).applyMatrix4(Wa);
                        var o = n / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o,
                            s = new Ce,
                            c = new Ce,
                            l = new Ce,
                            h = new Ce,
                            u = this && this.isLineSegments ? 2 : 1;
                        if (i.isBufferGeometry) {
                            var p = i.index,
                                d = i.attributes,
                                f = d.position.array;
                            if (null !== p)
                                for (var m = p.array, v = 0, g = m.length - 1; v < g; v += u) {
                                    var y = m[v],
                                        _ = m[v + 1];
                                    s.fromArray(f, 3 * y), c.fromArray(f, 3 * _);
                                    var x = Xa.distanceSqToSegment(s, c, h, l);
                                    if (!(x > a)) {
                                        h.applyMatrix4(this.matrixWorld);
                                        var b = t.ray.origin.distanceTo(h);
                                        b < t.near || b > t.far || e.push({
                                            distance: b,
                                            point: l.clone().applyMatrix4(this.matrixWorld),
                                            index: v,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                } else
                                    for (var v = 0, g = f.length / 3 - 1; v < g; v += u) {
                                        s.fromArray(f, 3 * v), c.fromArray(f, 3 * v + 3);
                                        var x = Xa.distanceSqToSegment(s, c, h, l);
                                        if (!(x > a)) {
                                            h.applyMatrix4(this.matrixWorld);
                                            var b = t.ray.origin.distanceTo(h);
                                            b < t.near || b > t.far || e.push({
                                                distance: b,
                                                point: l.clone().applyMatrix4(this.matrixWorld),
                                                index: v,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    }
                        } else if (i.isGeometry)
                            for (var w = i.vertices, M = w.length, v = 0; v < M - 1; v += u) {
                                var x = Xa.distanceSqToSegment(w[v], w[v + 1], h, l);
                                if (!(x > a)) {
                                    h.applyMatrix4(this.matrixWorld);
                                    var b = t.ray.origin.distanceTo(h);
                                    b < t.near || b > t.far || e.push({
                                        distance: b,
                                        point: l.clone().applyMatrix4(this.matrixWorld),
                                        index: v,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                    }
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });
            var Za = new Ce,
                Ja = new Ce;

            function Ka(t, e) {
                Ya.call(this, t, e), this.type = "LineSegments"
            }

            function Qa(t, e) {
                Ya.call(this, t, e), this.type = "LineLoop"
            }

            function $a(t) {
                oi.call(this), this.type = "PointsMaterial", this.color = new $n(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
            }
            Ka.prototype = Object.assign(Object.create(Ya.prototype), {
                constructor: Ka,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            for (var e = t.attributes.position, n = [], i = 0, r = e.count; i < r; i += 2) Za.fromBufferAttribute(e, i), Ja.fromBufferAttribute(e, i + 1), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + Za.distanceTo(Ja);
                            t.addAttribute("lineDistance", new mi(n, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (t.isGeometry)
                        for (var o = t.vertices, n = t.lineDistances, i = 0, r = o.length; i < r; i += 2) Za.copy(o[i]), Ja.copy(o[i + 1]), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + Za.distanceTo(Ja);
                    return this
                }
            }), Qa.prototype = Object.assign(Object.create(Ya.prototype), {
                constructor: Qa,
                isLineLoop: !0
            }), $a.prototype = Object.create(oi.prototype), $a.prototype.constructor = $a, $a.prototype.isPointsMaterial = !0, $a.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            };
            var ts = new Ye,
                es = new Fn,
                ns = new Rn,
                is = new Ce;

            function rs(t, e) {
                dn.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Si, this.material = void 0 !== e ? e : new $a({
                    color: 16777215 * Math.random()
                }), this.updateMorphTargets()
            }

            function os(t, e, n, i, r, o, a) {
                var s = es.distanceSqToPoint(t);
                if (s < n) {
                    var c = new Ce;
                    es.closestPointToPoint(t, c), c.applyMatrix4(i);
                    var l = r.ray.origin.distanceTo(c);
                    if (l < r.near || l > r.far) return;
                    o.push({
                        distance: l,
                        distanceToRay: Math.sqrt(s),
                        point: c,
                        index: e,
                        face: null,
                        object: a
                    })
                }
            }

            function as(t, e, n, i, r, o, a, s, c) {
                He.call(this, t, e, n, i, r, o, a, s, c), this.format = void 0 !== a ? a : At, this.minFilter = void 0 !== o ? o : ut, this.magFilter = void 0 !== r ? r : ut, this.generateMipmaps = !1
            }

            function ss(t, e, n, i, r, o, a, s, c, l, h, u) {
                He.call(this, null, o, a, s, c, l, i, r, h, u), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function cs(t, e, n, i, r, o, a, s, c) {
                He.call(this, t, e, n, i, r, o, a, s, c), this.needsUpdate = !0
            }

            function ls(t, e, n, i, r, o, a, s, c, l) {
                if ((l = void 0 !== l ? l : Ot) !== Ot && l !== It) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && l === Ot && (n = gt), void 0 === n && l === It && (n = Et), He.call(this, null, i, r, o, a, s, l, n, c), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== a ? a : ct, this.minFilter = void 0 !== s ? s : ct, this.flipY = !1, this.generateMipmaps = !1
            }

            function hs(t) {
                Si.call(this), this.type = "WireframeGeometry";
                var e, n, i, r, o, a, s, c, l, h, u = [],
                    p = [0, 0],
                    d = {},
                    f = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    var m = t.faces;
                    for (e = 0, i = m.length; e < i; e++) {
                        var v = m[e];
                        for (n = 0; n < 3; n++) s = v[f[n]], c = v[f[(n + 1) % 3]], p[0] = Math.min(s, c), p[1] = Math.max(s, c), l = p[0] + "," + p[1], void 0 === d[l] && (d[l] = {
                            index1: p[0],
                            index2: p[1]
                        })
                    }
                    for (l in d) a = d[l], h = t.vertices[a.index1], u.push(h.x, h.y, h.z), h = t.vertices[a.index2], u.push(h.x, h.y, h.z)
                } else if (t && t.isBufferGeometry) {
                    var g, y, _, x, b, w, M, T;
                    if (h = new Ce, null !== t.index) {
                        for (g = t.attributes.position, y = t.index, 0 === (_ = t.groups).length && (_ = [{
                                start: 0,
                                count: y.count,
                                materialIndex: 0
                            }]), r = 0, o = _.length; r < o; ++r)
                            for (x = _[r], b = x.start, w = x.count, e = b, i = b + w; e < i; e += 3)
                                for (n = 0; n < 3; n++) s = y.getX(e + n), c = y.getX(e + (n + 1) % 3), p[0] = Math.min(s, c), p[1] = Math.max(s, c), l = p[0] + "," + p[1], void 0 === d[l] && (d[l] = {
                                    index1: p[0],
                                    index2: p[1]
                                });
                        for (l in d) a = d[l], h.fromBufferAttribute(g, a.index1), u.push(h.x, h.y, h.z), h.fromBufferAttribute(g, a.index2), u.push(h.x, h.y, h.z)
                    } else
                        for (g = t.attributes.position, e = 0, i = g.count / 3; e < i; e++)
                            for (n = 0; n < 3; n++) M = 3 * e + n, h.fromBufferAttribute(g, M), u.push(h.x, h.y, h.z), T = 3 * e + (n + 1) % 3, h.fromBufferAttribute(g, T), u.push(h.x, h.y, h.z)
                }
                this.addAttribute("position", new mi(u, 3))
            }

            function us(t, e, n) {
                Ki.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                }, this.fromBufferGeometry(new ps(t, e, n)), this.mergeVertices()
            }

            function ps(t, e, n) {
                Si.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
                var i, r, o = [],
                    a = [],
                    s = [],
                    c = [],
                    l = new Ce,
                    h = new Ce,
                    u = new Ce,
                    p = new Ce,
                    d = new Ce;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var f = e + 1;
                for (i = 0; i <= n; i++) {
                    var m = i / n;
                    for (r = 0; r <= e; r++) {
                        var v = r / e;
                        t(v, m, h), a.push(h.x, h.y, h.z), v - 1e-5 >= 0 ? (t(v - 1e-5, m, u), p.subVectors(h, u)) : (t(v + 1e-5, m, u), p.subVectors(u, h)), m - 1e-5 >= 0 ? (t(v, m - 1e-5, u), d.subVectors(h, u)) : (t(v, m + 1e-5, u), d.subVectors(u, h)), l.crossVectors(p, d).normalize(), s.push(l.x, l.y, l.z), c.push(v, m)
                    }
                }
                for (i = 0; i < n; i++)
                    for (r = 0; r < e; r++) {
                        var g = i * f + r,
                            y = i * f + r + 1,
                            _ = (i + 1) * f + r + 1,
                            x = (i + 1) * f + r;
                        o.push(g, y, x), o.push(y, _, x)
                    }
                this.setIndex(o), this.addAttribute("position", new mi(a, 3)), this.addAttribute("normal", new mi(s, 3)), this.addAttribute("uv", new mi(c, 2))
            }

            function ds(t, e, n, i) {
                Ki.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: i
                }, this.fromBufferGeometry(new fs(t, e, n, i)), this.mergeVertices()
            }

            function fs(t, e, n, i) {
                Si.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: i
                }, n = n || 1;
                var r = [],
                    o = [];

                function a(t, e, n, i) {
                    var r, o, a = Math.pow(2, i),
                        c = [];
                    for (r = 0; r <= a; r++) {
                        c[r] = [];
                        var l = t.clone().lerp(n, r / a),
                            h = e.clone().lerp(n, r / a),
                            u = a - r;
                        for (o = 0; o <= u; o++) c[r][o] = 0 === o && r === a ? l : l.clone().lerp(h, o / u)
                    }
                    for (r = 0; r < a; r++)
                        for (o = 0; o < 2 * (a - r) - 1; o++) {
                            var p = Math.floor(o / 2);
                            o % 2 == 0 ? (s(c[r][p + 1]), s(c[r + 1][p]), s(c[r][p])) : (s(c[r][p + 1]), s(c[r + 1][p + 1]), s(c[r + 1][p]))
                        }
                }

                function s(t) {
                    r.push(t.x, t.y, t.z)
                }

                function c(e, n) {
                    var i = 3 * e;
                    n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
                }

                function l(t, e, n, i) {
                    i < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5)
                }

                function h(t) {
                    return Math.atan2(t.z, -t.x)
                }

                function u(t) {
                    return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                }! function(t) {
                    for (var n = new Ce, i = new Ce, r = new Ce, o = 0; o < e.length; o += 3) c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), a(n, i, r, t)
                }(i = i || 0),
                function(t) {
                    for (var e = new Ce, n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
                }(n),
                function() {
                    for (var t = new Ce, e = 0; e < r.length; e += 3) {
                        t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                        var n = h(t) / 2 / Math.PI + .5,
                            i = u(t) / Math.PI + .5;
                        o.push(n, 1 - i)
                    }(function() {
                        for (var t = new Ce, e = new Ce, n = new Ce, i = new Ce, a = new Ae, s = new Ae, c = new Ae, u = 0, p = 0; u < r.length; u += 9, p += 6) {
                            t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), a.set(o[p + 0], o[p + 1]), s.set(o[p + 2], o[p + 3]), c.set(o[p + 4], o[p + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                            var d = h(i);
                            l(a, p + 0, t, d), l(s, p + 2, e, d), l(c, p + 4, n, d)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < o.length; t += 6) {
                            var e = o[t + 0],
                                n = o[t + 2],
                                i = o[t + 4],
                                r = Math.max(e, n, i),
                                a = Math.min(e, n, i);
                            r > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), i < .2 && (o[t + 4] += 1))
                        }
                    }()
                }(), this.addAttribute("position", new mi(r, 3)), this.addAttribute("normal", new mi(r.slice(), 3)), this.addAttribute("uv", new mi(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function ms(t, e) {
                Ki.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new vs(t, e)), this.mergeVertices()
            }

            function vs(t, e) {
                fs.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function gs(t, e) {
                Ki.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new ys(t, e)), this.mergeVertices()
            }

            function ys(t, e) {
                fs.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function _s(t, e) {
                Ki.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new xs(t, e)), this.mergeVertices()
            }

            function xs(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                fs.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function bs(t, e) {
                Ki.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new ws(t, e)), this.mergeVertices()
            }

            function ws(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = 1 / n,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
                fs.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Ms(t, e, n, i, r, o) {
                Ki.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                var a = new Ts(t, e, n, i, r);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Ts(t, e, n, i, r) {
                Si.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, e = e || 64, n = n || 1, i = i || 8, r = r || !1;
                var o = t.computeFrenetFrames(e, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                var a, s, c = new Ce,
                    l = new Ce,
                    h = new Ae,
                    u = new Ce,
                    p = [],
                    d = [],
                    f = [],
                    m = [];

                function v(r) {
                    u = t.getPointAt(r / e, u);
                    var a = o.normals[r],
                        h = o.binormals[r];
                    for (s = 0; s <= i; s++) {
                        var f = s / i * Math.PI * 2,
                            m = Math.sin(f),
                            v = -Math.cos(f);
                        l.x = v * a.x + m * h.x, l.y = v * a.y + m * h.y, l.z = v * a.z + m * h.z, l.normalize(), d.push(l.x, l.y, l.z), c.x = u.x + n * l.x, c.y = u.y + n * l.y, c.z = u.z + n * l.z, p.push(c.x, c.y, c.z)
                    }
                }! function() {
                    for (a = 0; a < e; a++) v(a);
                    v(!1 === r ? e : 0),
                        function() {
                            for (a = 0; a <= e; a++)
                                for (s = 0; s <= i; s++) h.x = a / e, h.y = s / i, f.push(h.x, h.y)
                        }(),
                        function() {
                            for (s = 1; s <= e; s++)
                                for (a = 1; a <= i; a++) {
                                    var t = (i + 1) * (s - 1) + (a - 1),
                                        n = (i + 1) * s + (a - 1),
                                        r = (i + 1) * s + a,
                                        o = (i + 1) * (s - 1) + a;
                                    m.push(t, n, o), m.push(n, r, o)
                                }
                        }()
                }(), this.setIndex(m), this.addAttribute("position", new mi(p, 3)), this.addAttribute("normal", new mi(d, 3)), this.addAttribute("uv", new mi(f, 2))
            }

            function Es(t, e, n, i, r, o, a) {
                Ki.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: o
                }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Ss(t, e, n, i, r, o)), this.mergeVertices()
            }

            function Ss(t, e, n, i, r, o) {
                Si.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: o
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3;
                var a, s, c = [],
                    l = [],
                    h = [],
                    u = [],
                    p = new Ce,
                    d = new Ce,
                    f = new Ce,
                    m = new Ce,
                    v = new Ce,
                    g = new Ce,
                    y = new Ce;
                for (a = 0; a <= n; ++a) {
                    var _ = a / n * r * Math.PI * 2;
                    for (A(_, r, o, t, f), A(_ + .01, r, o, t, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= i; ++s) {
                        var x = s / i * Math.PI * 2,
                            b = -e * Math.cos(x),
                            w = e * Math.sin(x);
                        p.x = f.x + (b * y.x + w * v.x), p.y = f.y + (b * y.y + w * v.y), p.z = f.z + (b * y.z + w * v.z), l.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), h.push(d.x, d.y, d.z), u.push(a / n), u.push(s / i)
                    }
                }
                for (s = 1; s <= n; s++)
                    for (a = 1; a <= i; a++) {
                        var M = (i + 1) * (s - 1) + (a - 1),
                            T = (i + 1) * s + (a - 1),
                            E = (i + 1) * s + a,
                            S = (i + 1) * (s - 1) + a;
                        c.push(M, T, S), c.push(T, E, S)
                    }

                function A(t, e, n, i, r) {
                    var o = Math.cos(t),
                        a = Math.sin(t),
                        s = n / e * t,
                        c = Math.cos(s);
                    r.x = i * (2 + c) * .5 * o, r.y = i * (2 + c) * a * .5, r.z = i * Math.sin(s) * .5
                }
                this.setIndex(c), this.addAttribute("position", new mi(l, 3)), this.addAttribute("normal", new mi(h, 3)), this.addAttribute("uv", new mi(u, 2))
            }

            function As(t, e, n, i, r) {
                Ki.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, this.fromBufferGeometry(new Ps(t, e, n, i, r)), this.mergeVertices()
            }

            function Ps(t, e, n, i, r) {
                Si.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
                var o, a, s = [],
                    c = [],
                    l = [],
                    h = [],
                    u = new Ce,
                    p = new Ce,
                    d = new Ce;
                for (o = 0; o <= n; o++)
                    for (a = 0; a <= i; a++) {
                        var f = a / i * r,
                            m = o / n * Math.PI * 2;
                        p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f), p.z = e * Math.sin(m), c.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), d.subVectors(p, u).normalize(), l.push(d.x, d.y, d.z), h.push(a / i), h.push(o / n)
                    }
                for (o = 1; o <= n; o++)
                    for (a = 1; a <= i; a++) {
                        var v = (i + 1) * o + a - 1,
                            g = (i + 1) * (o - 1) + a - 1,
                            y = (i + 1) * (o - 1) + a,
                            _ = (i + 1) * o + a;
                        s.push(v, g, _), s.push(g, y, _)
                    }
                this.setIndex(s), this.addAttribute("position", new mi(c, 3)), this.addAttribute("normal", new mi(l, 3)), this.addAttribute("uv", new mi(h, 2))
            }
            rs.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: rs,
                isPoints: !0,
                raycast: function(t, e) {
                    var n = this.geometry,
                        i = this.matrixWorld,
                        r = t.params.Points.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), ns.copy(n.boundingSphere), ns.applyMatrix4(i), ns.radius += r, !1 !== t.ray.intersectsSphere(ns)) {
                        ts.getInverse(i), es.copy(t.ray).applyMatrix4(ts);
                        var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o;
                        if (n.isBufferGeometry) {
                            var s = n.index,
                                c = n.attributes,
                                l = c.position.array;
                            if (null !== s)
                                for (var h = s.array, u = 0, p = h.length; u < p; u++) {
                                    var d = h[u];
                                    is.fromArray(l, 3 * d), os(is, d, a, i, t, e, this)
                                } else
                                    for (var u = 0, f = l.length / 3; u < f; u++) is.fromArray(l, 3 * u), os(is, u, a, i, t, e, this)
                        } else
                            for (var m = n.vertices, u = 0, f = m.length; u < f; u++) os(m[u], u, a, i, t, e, this)
                    }
                },
                updateMorphTargets: function() {
                    var t, e, n, i = this.geometry;
                    if (i.isBufferGeometry) {
                        var r = i.morphAttributes,
                            o = Object.keys(r);
                        if (o.length > 0) {
                            var a = r[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) n = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    } else {
                        var s = i.morphTargets;
                        void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), as.prototype = Object.assign(Object.create(He.prototype), {
                constructor: as,
                isVideoTexture: !0,
                update: function() {
                    var t = this.image;
                    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), ss.prototype = Object.create(He.prototype), ss.prototype.constructor = ss, ss.prototype.isCompressedTexture = !0, cs.prototype = Object.create(He.prototype), cs.prototype.constructor = cs, cs.prototype.isCanvasTexture = !0, ls.prototype = Object.create(He.prototype), ls.prototype.constructor = ls, ls.prototype.isDepthTexture = !0, hs.prototype = Object.create(Si.prototype), hs.prototype.constructor = hs, us.prototype = Object.create(Ki.prototype), us.prototype.constructor = us, ps.prototype = Object.create(Si.prototype), ps.prototype.constructor = ps, ds.prototype = Object.create(Ki.prototype), ds.prototype.constructor = ds, fs.prototype = Object.create(Si.prototype), fs.prototype.constructor = fs, ms.prototype = Object.create(Ki.prototype), ms.prototype.constructor = ms, vs.prototype = Object.create(fs.prototype), vs.prototype.constructor = vs, gs.prototype = Object.create(Ki.prototype), gs.prototype.constructor = gs, ys.prototype = Object.create(fs.prototype), ys.prototype.constructor = ys, _s.prototype = Object.create(Ki.prototype), _s.prototype.constructor = _s, xs.prototype = Object.create(fs.prototype), xs.prototype.constructor = xs, bs.prototype = Object.create(Ki.prototype), bs.prototype.constructor = bs, ws.prototype = Object.create(fs.prototype), ws.prototype.constructor = ws, Ms.prototype = Object.create(Ki.prototype), Ms.prototype.constructor = Ms, Ts.prototype = Object.create(Si.prototype), Ts.prototype.constructor = Ts, Ts.prototype.toJSON = function() {
                var t = Si.prototype.toJSON.call(this);
                return t.path = this.parameters.path.toJSON(), t
            }, Es.prototype = Object.create(Ki.prototype), Es.prototype.constructor = Es, Ss.prototype = Object.create(Si.prototype), Ss.prototype.constructor = Ss, As.prototype = Object.create(Ki.prototype), As.prototype.constructor = As, Ps.prototype = Object.create(Si.prototype), Ps.prototype.constructor = Ps;
            var Ls = {
                triangulate: function(t, e, n) {
                    n = n || 2;
                    var i, r, o, a, s, c, l, h = e && e.length,
                        u = h ? e[0] * n : t.length,
                        p = Rs(t, 0, u, n, !0),
                        d = [];
                    if (!p || p.next === p.prev) return d;
                    if (h && (p = function(t, e, n, i) {
                            var r, o, a, s, c, l = [];
                            for (r = 0, o = e.length; r < o; r++) a = e[r] * i, s = r < o - 1 ? e[r + 1] * i : t.length, (c = Rs(t, a, s, i, !1)) === c.next && (c.steiner = !0), l.push(Us(c));
                            for (l.sort(Hs), r = 0; r < l.length; r++) Fs(l[r], n), n = Cs(n, n.next);
                            return n
                        }(t, e, p, n)), t.length > 80 * n) {
                        i = o = t[0], r = a = t[1];
                        for (var f = n; f < u; f += n) s = t[f], c = t[f + 1], s < i && (i = s), c < r && (r = c), s > o && (o = s), c > a && (a = c);
                        l = 0 !== (l = Math.max(o - i, a - r)) ? 1 / l : 0
                    }
                    return Os(p, d, n, i, r, l), d
                }
            };

            function Rs(t, e, n, i, r) {
                var o, a;
                if (r === function(t, e, n, i) {
                        for (var r = 0, o = e, a = n - i; o < n; o += i) r += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                        return r
                    }(t, e, n, i) > 0)
                    for (o = e; o < n; o += i) a = Ys(o, t[o], t[o + 1], a);
                else
                    for (o = n - i; o >= e; o -= i) a = Ys(o, t[o], t[o + 1], a);
                return a && Vs(a, a.next) && (Zs(a), a = a.next), a
            }

            function Cs(t, e) {
                if (!t) return t;
                e || (e = t);
                var n, i = t;
                do {
                    if (n = !1, i.steiner || !Vs(i, i.next) && 0 !== js(i.prev, i, i.next)) i = i.next;
                    else {
                        if (Zs(i), (i = e = i.prev) === i.next) break;
                        n = !0
                    }
                } while (n || i !== e);
                return e
            }

            function Os(t, e, n, i, r, o, a) {
                if (t) {
                    !a && o && function(t, e, n, i) {
                        var r = t;
                        do {
                            null === r.z && (r.z = ks(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                var e, n, i, r, o, a, s, c, l = 1;
                                do {
                                    for (n = t, t = null, o = null, a = 0; n;) {
                                        for (a++, i = n, s = 0, e = 0; e < l && (s++, i = i.nextZ); e++);
                                        for (c = l; s > 0 || c > 0 && i;) 0 !== s && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                                        n = i
                                    }
                                    o.nextZ = null, l *= 2
                                } while (a > 1)
                            }(r)
                    }(t, i, r, o);
                    for (var s, c, l = t; t.prev !== t.next;)
                        if (s = t.prev, c = t.next, o ? Ds(t, i, r, o) : Is(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), Zs(t), t = c.next, l = c.next;
                        else if ((t = c) === l) {
                        a ? 1 === a ? Os(t = Ns(t, e, n), e, n, i, r, o, 2) : 2 === a && Bs(t, e, n, i, r, o) : Os(Cs(t), e, n, i, r, o, 1);
                        break
                    }
                }
            }

            function Is(t) {
                var e = t.prev,
                    n = t,
                    i = t.next;
                if (js(e, n, i) >= 0) return !1;
                for (var r = t.next.next; r !== t.prev;) {
                    if (zs(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && js(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function Ds(t, e, n, i) {
                var r = t.prev,
                    o = t,
                    a = t.next;
                if (js(r, o, a) >= 0) return !1;
                for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, c = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, l = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, h = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, u = ks(s, c, e, n, i), p = ks(l, h, e, n, i), d = t.prevZ, f = t.nextZ; d && d.z >= u && f && f.z <= p;) {
                    if (d !== t.prev && d !== t.next && zs(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && js(d.prev, d, d.next) >= 0) return !1;
                    if (d = d.prevZ, f !== t.prev && f !== t.next && zs(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && js(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                for (; d && d.z >= u;) {
                    if (d !== t.prev && d !== t.next && zs(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && js(d.prev, d, d.next) >= 0) return !1;
                    d = d.prevZ
                }
                for (; f && f.z <= p;) {
                    if (f !== t.prev && f !== t.next && zs(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && js(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                return !0
            }

            function Ns(t, e, n) {
                var i = t;
                do {
                    var r = i.prev,
                        o = i.next.next;
                    !Vs(r, o) && Ws(r, i, i.next, o) && Xs(r, o) && Xs(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), Zs(i), Zs(i.next), i = t = o), i = i.next
                } while (i !== t);
                return i
            }

            function Bs(t, e, n, i, r, o) {
                var a = t;
                do {
                    for (var s = a.next.next; s !== a.prev;) {
                        if (a.i !== s.i && Gs(a, s)) {
                            var c = qs(a, s);
                            return a = Cs(a, a.next), c = Cs(c, c.next), Os(a, e, n, i, r, o), void Os(c, e, n, i, r, o)
                        }
                        s = s.next
                    }
                    a = a.next
                } while (a !== t)
            }

            function Hs(t, e) {
                return t.x - e.x
            }

            function Fs(t, e) {
                if (e = function(t, e) {
                        var n, i = e,
                            r = t.x,
                            o = t.y,
                            a = -1 / 0;
                        do {
                            if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
                                var s = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                if (s <= r && s > a) {
                                    if (a = s, s === r) {
                                        if (o === i.y) return i;
                                        if (o === i.next.y) return i.next
                                    }
                                    n = i.x < i.next.x ? i : i.next
                                }
                            }
                            i = i.next
                        } while (i !== e);
                        if (!n) return null;
                        if (r === a) return n.prev;
                        var c, l = n,
                            h = n.x,
                            u = n.y,
                            p = 1 / 0;
                        for (i = n.next; i !== l;) r >= i.x && i.x >= h && r !== i.x && zs(o < u ? r : a, o, h, u, o < u ? a : r, o, i.x, i.y) && ((c = Math.abs(o - i.y) / (r - i.x)) < p || c === p && i.x > n.x) && Xs(i, t) && (n = i, p = c), i = i.next;
                        return n
                    }(t, e)) {
                    var n = qs(e, t);
                    Cs(n, n.next)
                }
            }

            function ks(t, e, n, i, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function Us(t) {
                var e = t,
                    n = t;
                do {
                    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                } while (e !== t);
                return n
            }

            function zs(t, e, n, i, r, o, a, s) {
                return (r - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (i - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0
            }

            function Gs(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    var n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Ws(n, n.next, t, e)) return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }(t, e) && Xs(t, e) && Xs(e, t) && function(t, e) {
                    var n = t,
                        i = !1,
                        r = (t.x + e.x) / 2,
                        o = (t.y + e.y) / 2;
                    do {
                        n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== t);
                    return i
                }(t, e)
            }

            function js(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
            }

            function Vs(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function Ws(t, e, n, i) {
                return !!(Vs(t, n) && Vs(e, i) || Vs(t, i) && Vs(n, e)) || js(t, e, n) > 0 != js(t, e, i) > 0 && js(n, i, t) > 0 != js(n, i, e) > 0
            }

            function Xs(t, e) {
                return js(t.prev, t, t.next) < 0 ? js(t, e, t.next) >= 0 && js(t, t.prev, e) >= 0 : js(t, e, t.prev) < 0 || js(t, t.next, e) < 0
            }

            function qs(t, e) {
                var n = new Js(t.i, t.x, t.y),
                    i = new Js(e.i, e.x, e.y),
                    r = t.next,
                    o = e.prev;
                return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
            }

            function Ys(t, e, n, i) {
                var r = new Js(t, e, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function Zs(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function Js(t, e, n) {
                this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var Ks = {
                area: function(t) {
                    for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                    return .5 * n
                },
                isClockWise: function(t) {
                    return Ks.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    var n = [],
                        i = [],
                        r = [];
                    Qs(t), $s(n, t);
                    var o = t.length;
                    e.forEach(Qs);
                    for (var a = 0; a < e.length; a++) i.push(o), o += e[a].length, $s(n, e[a]);
                    for (var s = Ls.triangulate(n, i), a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
                    return r
                }
            };

            function Qs(t) {
                var e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function $s(t, e) {
                for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
            }

            function tc(t, e) {
                Ki.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new ec(t, e)), this.mergeVertices()
            }

            function ec(t, e) {
                Si.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: t,
                    options: e
                };
                for (var n = this, i = [], r = [], o = 0, a = (t = Array.isArray(t) ? t : [t]).length; o < a; o++) {
                    var s = t[o];
                    c(s)
                }

                function c(t) {
                    var o = [],
                        a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        s = void 0 !== e.steps ? e.steps : 1,
                        c = void 0 !== e.depth ? e.depth : 100,
                        l = void 0 === e.bevelEnabled || e.bevelEnabled,
                        h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                        u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                        p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                        d = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                        f = e.extrudePath,
                        m = void 0 !== e.UVGenerator ? e.UVGenerator : nc;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
                    var v, g, y, _, x, b, w, M, T = !1;
                    f && (v = f.getSpacedPoints(s), T = !0, l = !1, g = f.computeFrenetFrames(s, !1), y = new Ce, _ = new Ce, x = new Ce), l || (d = 0, h = 0, u = 0, p = 0);
                    var E = t.extractPoints(a),
                        S = E.shape,
                        A = E.holes,
                        P = !Ks.isClockWise(S);
                    if (P)
                        for (S = S.reverse(), w = 0, M = A.length; w < M; w++) b = A[w], Ks.isClockWise(b) && (A[w] = b.reverse());
                    var L = Ks.triangulateShape(S, A),
                        R = S;
                    for (w = 0, M = A.length; w < M; w++) b = A[w], S = S.concat(b);

                    function C(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                    }
                    var O, I, D, N, B, H, F = S.length,
                        k = L.length;

                    function U(t, e, n) {
                        var i, r, o, a = t.x - e.x,
                            s = t.y - e.y,
                            c = n.x - t.x,
                            l = n.y - t.y,
                            h = a * a + s * s,
                            u = a * l - s * c;
                        if (Math.abs(u) > Number.EPSILON) {
                            var p = Math.sqrt(h),
                                d = Math.sqrt(c * c + l * l),
                                f = e.x - s / p,
                                m = e.y + a / p,
                                v = n.x - l / d,
                                g = n.y + c / d,
                                y = ((v - f) * l - (g - m) * c) / (a * l - s * c);
                            i = f + a * y - t.x, r = m + s * y - t.y;
                            var _ = i * i + r * r;
                            if (_ <= 2) return new Ae(i, r);
                            o = Math.sqrt(_ / 2)
                        } else {
                            var x = !1;
                            a > Number.EPSILON ? c > Number.EPSILON && (x = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (x = !0) : Math.sign(s) === Math.sign(l) && (x = !0), x ? (i = -s, r = a, o = Math.sqrt(h)) : (i = a, r = s, o = Math.sqrt(h / 2))
                        }
                        return new Ae(i / o, r / o)
                    }
                    for (var z = [], G = 0, j = R.length, V = j - 1, W = G + 1; G < j; G++, V++, W++) V === j && (V = 0), W === j && (W = 0), z[G] = U(R[G], R[V], R[W]);
                    var X, q, Y = [],
                        Z = z.concat();
                    for (w = 0, M = A.length; w < M; w++) {
                        for (b = A[w], X = [], G = 0, j = b.length, V = j - 1, W = G + 1; G < j; G++, V++, W++) V === j && (V = 0), W === j && (W = 0), X[G] = U(b[G], b[V], b[W]);
                        Y.push(X), Z = Z.concat(X)
                    }
                    for (O = 0; O < d; O++) {
                        for (D = O / d, N = h * Math.cos(D * Math.PI / 2), I = u * Math.sin(D * Math.PI / 2) + p, G = 0, j = R.length; G < j; G++) K((B = C(R[G], z[G], I)).x, B.y, -N);
                        for (w = 0, M = A.length; w < M; w++)
                            for (b = A[w], X = Y[w], G = 0, j = b.length; G < j; G++) K((B = C(b[G], X[G], I)).x, B.y, -N)
                    }
                    for (I = u + p, G = 0; G < F; G++) B = l ? C(S[G], Z[G], I) : S[G], T ? (_.copy(g.normals[0]).multiplyScalar(B.x), y.copy(g.binormals[0]).multiplyScalar(B.y), x.copy(v[0]).add(_).add(y), K(x.x, x.y, x.z)) : K(B.x, B.y, 0);
                    for (q = 1; q <= s; q++)
                        for (G = 0; G < F; G++) B = l ? C(S[G], Z[G], I) : S[G], T ? (_.copy(g.normals[q]).multiplyScalar(B.x), y.copy(g.binormals[q]).multiplyScalar(B.y), x.copy(v[q]).add(_).add(y), K(x.x, x.y, x.z)) : K(B.x, B.y, c / s * q);
                    for (O = d - 1; O >= 0; O--) {
                        for (D = O / d, N = h * Math.cos(D * Math.PI / 2), I = u * Math.sin(D * Math.PI / 2) + p, G = 0, j = R.length; G < j; G++) K((B = C(R[G], z[G], I)).x, B.y, c + N);
                        for (w = 0, M = A.length; w < M; w++)
                            for (b = A[w], X = Y[w], G = 0, j = b.length; G < j; G++) B = C(b[G], X[G], I), T ? K(B.x, B.y + v[s - 1].y, v[s - 1].x + N) : K(B.x, B.y, c + N)
                    }

                    function J(t, e) {
                        var n, i;
                        for (G = t.length; --G >= 0;) {
                            n = G, (i = G - 1) < 0 && (i = t.length - 1);
                            var r = 0,
                                o = s + 2 * d;
                            for (r = 0; r < o; r++) {
                                var a = F * r,
                                    c = F * (r + 1),
                                    l = e + n + a,
                                    h = e + i + a,
                                    u = e + i + c,
                                    p = e + n + c;
                                $(l, h, u, p)
                            }
                        }
                    }

                    function K(t, e, n) {
                        o.push(t), o.push(e), o.push(n)
                    }

                    function Q(t, e, r) {
                        tt(t), tt(e), tt(r);
                        var o = i.length / 3,
                            a = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                        et(a[0]), et(a[1]), et(a[2])
                    }

                    function $(t, e, r, o) {
                        tt(t), tt(e), tt(o), tt(e), tt(r), tt(o);
                        var a = i.length / 3,
                            s = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                        et(s[0]), et(s[1]), et(s[3]), et(s[1]), et(s[2]), et(s[3])
                    }

                    function tt(t) {
                        i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2])
                    }

                    function et(t) {
                        r.push(t.x), r.push(t.y)
                    }! function() {
                        var t = i.length / 3;
                        if (l) {
                            var e = 0,
                                r = F * e;
                            for (G = 0; G < k; G++) Q((H = L[G])[2] + r, H[1] + r, H[0] + r);
                            for (r = F * (e = s + 2 * d), G = 0; G < k; G++) Q((H = L[G])[0] + r, H[1] + r, H[2] + r)
                        } else {
                            for (G = 0; G < k; G++) Q((H = L[G])[2], H[1], H[0]);
                            for (G = 0; G < k; G++) Q((H = L[G])[0] + F * s, H[1] + F * s, H[2] + F * s)
                        }
                        n.addGroup(t, i.length / 3 - t, 0)
                    }(),
                    function() {
                        var t = i.length / 3,
                            e = 0;
                        for (J(R, e), e += R.length, w = 0, M = A.length; w < M; w++) J(b = A[w], e), e += b.length;
                        n.addGroup(t, i.length / 3 - t, 1)
                    }()
                }
                this.addAttribute("position", new mi(i, 3)), this.addAttribute("uv", new mi(r, 2)), this.computeVertexNormals()
            }
            tc.prototype = Object.create(Ki.prototype), tc.prototype.constructor = tc, tc.prototype.toJSON = function() {
                var t = Ki.prototype.toJSON.call(this),
                    e = this.parameters.shapes,
                    n = this.parameters.options;
                return ic(e, n, t)
            }, ec.prototype = Object.create(Si.prototype), ec.prototype.constructor = ec, ec.prototype.toJSON = function() {
                var t = Si.prototype.toJSON.call(this),
                    e = this.parameters.shapes,
                    n = this.parameters.options;
                return ic(e, n, t)
            };
            var nc = {
                generateTopUV: function(t, e, n, i, r) {
                    var o = e[3 * n],
                        a = e[3 * n + 1],
                        s = e[3 * i],
                        c = e[3 * i + 1],
                        l = e[3 * r],
                        h = e[3 * r + 1];
                    return [new Ae(o, a), new Ae(s, c), new Ae(l, h)]
                },
                generateSideWallUV: function(t, e, n, i, r, o) {
                    var a = e[3 * n],
                        s = e[3 * n + 1],
                        c = e[3 * n + 2],
                        l = e[3 * i],
                        h = e[3 * i + 1],
                        u = e[3 * i + 2],
                        p = e[3 * r],
                        d = e[3 * r + 1],
                        f = e[3 * r + 2],
                        m = e[3 * o],
                        v = e[3 * o + 1],
                        g = e[3 * o + 2];
                    return Math.abs(s - h) < .01 ? [new Ae(a, 1 - c), new Ae(l, 1 - u), new Ae(p, 1 - f), new Ae(m, 1 - g)] : [new Ae(s, 1 - c), new Ae(h, 1 - u), new Ae(d, 1 - f), new Ae(v, 1 - g)]
                }
            };

            function ic(t, e, n) {
                if (n.shapes = [], Array.isArray(t))
                    for (var i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        n.shapes.push(o.uuid)
                    } else n.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
            }

            function rc(t, e) {
                Ki.call(this), this.type = "TextGeometry", this.parameters = {
                    text: t,
                    parameters: e
                }, this.fromBufferGeometry(new oc(t, e)), this.mergeVertices()
            }

            function oc(t, e) {
                var n = (e = e || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Ki;
                var i = n.generateShapes(t, e.size);
                e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), ec.call(this, i, e), this.type = "TextBufferGeometry"
            }

            function ac(t, e, n, i, r, o, a) {
                Ki.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: a
                }, this.fromBufferGeometry(new sc(t, e, n, i, r, o, a)), this.mergeVertices()
            }

            function sc(t, e, n, i, r, o, a) {
                Si.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: a
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
                var s, c, l = Math.min(o + a, Math.PI),
                    h = 0,
                    u = [],
                    p = new Ce,
                    d = new Ce,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (c = 0; c <= n; c++) {
                    var y = [],
                        _ = c / n,
                        x = 0;
                    for (0 == c && 0 == o ? x = .5 / e : c == n && l == Math.PI && (x = -.5 / e), s = 0; s <= e; s++) {
                        var b = s / e;
                        p.x = -t * Math.cos(i + b * r) * Math.sin(o + _ * a), p.y = t * Math.cos(o + _ * a), p.z = t * Math.sin(i + b * r) * Math.sin(o + _ * a), m.push(p.x, p.y, p.z), d.copy(p).normalize(), v.push(d.x, d.y, d.z), g.push(b + x, 1 - _), y.push(h++)
                    }
                    u.push(y)
                }
                for (c = 0; c < n; c++)
                    for (s = 0; s < e; s++) {
                        var w = u[c][s + 1],
                            M = u[c][s],
                            T = u[c + 1][s],
                            E = u[c + 1][s + 1];
                        (0 !== c || o > 0) && f.push(w, M, E), (c !== n - 1 || l < Math.PI) && f.push(M, T, E)
                    }
                this.setIndex(f), this.addAttribute("position", new mi(m, 3)), this.addAttribute("normal", new mi(v, 3)), this.addAttribute("uv", new mi(g, 2))
            }

            function cc(t, e, n, i, r, o) {
                Ki.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: o
                }, this.fromBufferGeometry(new lc(t, e, n, i, r, o)), this.mergeVertices()
            }

            function lc(t, e, n, i, r, o) {
                Si.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: o
                }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, i = void 0 !== i ? Math.max(1, i) : 1;
                var a, s, c, l = [],
                    h = [],
                    u = [],
                    p = [],
                    d = t,
                    f = (e - t) / i,
                    m = new Ce,
                    v = new Ae;
                for (s = 0; s <= i; s++) {
                    for (c = 0; c <= n; c++) a = r + c / n * o, m.x = d * Math.cos(a), m.y = d * Math.sin(a), h.push(m.x, m.y, m.z), u.push(0, 0, 1), v.x = (m.x / e + 1) / 2, v.y = (m.y / e + 1) / 2, p.push(v.x, v.y);
                    d += f
                }
                for (s = 0; s < i; s++) {
                    var g = s * (n + 1);
                    for (c = 0; c < n; c++) {
                        var y = a = c + g,
                            _ = a + n + 1,
                            x = a + n + 2,
                            b = a + 1;
                        l.push(y, _, b), l.push(_, x, b)
                    }
                }
                this.setIndex(l), this.addAttribute("position", new mi(h, 3)), this.addAttribute("normal", new mi(u, 3)), this.addAttribute("uv", new mi(p, 2))
            }

            function hc(t, e, n, i) {
                Ki.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: i
                }, this.fromBufferGeometry(new uc(t, e, n, i)), this.mergeVertices()
            }

            function uc(t, e, n, i) {
                Si.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: i
                }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = Se.clamp(i, 0, 2 * Math.PI);
                var r, o, a, s = [],
                    c = [],
                    l = [],
                    h = 1 / e,
                    u = new Ce,
                    p = new Ae;
                for (o = 0; o <= e; o++) {
                    var d = n + o * h * i,
                        f = Math.sin(d),
                        m = Math.cos(d);
                    for (a = 0; a <= t.length - 1; a++) u.x = t[a].x * f, u.y = t[a].y, u.z = t[a].x * m, c.push(u.x, u.y, u.z), p.x = o / e, p.y = a / (t.length - 1), l.push(p.x, p.y)
                }
                for (o = 0; o < e; o++)
                    for (a = 0; a < t.length - 1; a++) {
                        var v = r = a + o * t.length,
                            g = r + t.length,
                            y = r + t.length + 1,
                            _ = r + 1;
                        s.push(v, g, _), s.push(g, y, _)
                    }
                if (this.setIndex(s), this.addAttribute("position", new mi(c, 3)), this.addAttribute("uv", new mi(l, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                    var x = this.attributes.normal.array,
                        b = new Ce,
                        w = new Ce,
                        M = new Ce;
                    for (r = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3) b.x = x[a + 0], b.y = x[a + 1], b.z = x[a + 2], w.x = x[r + a + 0], w.y = x[r + a + 1], w.z = x[r + a + 2], M.addVectors(b, w).normalize(), x[a + 0] = x[r + a + 0] = M.x, x[a + 1] = x[r + a + 1] = M.y, x[a + 2] = x[r + a + 2] = M.z
                }
            }

            function pc(t, e) {
                Ki.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new dc(t, e)), this.mergeVertices()
            }

            function dc(t, e) {
                Si.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, e = e || 12;
                var n = [],
                    i = [],
                    r = [],
                    o = [],
                    a = 0,
                    s = 0;
                if (!1 === Array.isArray(t)) l(t);
                else
                    for (var c = 0; c < t.length; c++) l(t[c]), this.addGroup(a, s, c), a += s, s = 0;

                function l(t) {
                    var a, c, l, h = i.length / 3,
                        u = t.extractPoints(e),
                        p = u.shape,
                        d = u.holes;
                    for (!1 === Ks.isClockWise(p) && (p = p.reverse()), a = 0, c = d.length; a < c; a++) l = d[a], !0 === Ks.isClockWise(l) && (d[a] = l.reverse());
                    var f = Ks.triangulateShape(p, d);
                    for (a = 0, c = d.length; a < c; a++) l = d[a], p = p.concat(l);
                    for (a = 0, c = p.length; a < c; a++) {
                        var m = p[a];
                        i.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y)
                    }
                    for (a = 0, c = f.length; a < c; a++) {
                        var v = f[a],
                            g = v[0] + h,
                            y = v[1] + h,
                            _ = v[2] + h;
                        n.push(g, y, _), s += 3
                    }
                }
                this.setIndex(n), this.addAttribute("position", new mi(i, 3)), this.addAttribute("normal", new mi(r, 3)), this.addAttribute("uv", new mi(o, 2))
            }

            function fc(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (var n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }

            function mc(t, e) {
                Si.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var n, i, r, o, a = [],
                    s = Math.cos(Se.DEG2RAD * e),
                    c = [0, 0],
                    l = {},
                    h = ["a", "b", "c"];
                t.isBufferGeometry ? (o = new Ki).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var u = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
                    for (var m = p[d], v = 0; v < 3; v++) n = m[h[v]], i = m[h[(v + 1) % 3]], c[0] = Math.min(n, i), c[1] = Math.max(n, i), r = c[0] + "," + c[1], void 0 === l[r] ? l[r] = {
                        index1: c[0],
                        index2: c[1],
                        face1: d,
                        face2: void 0
                    } : l[r].face2 = d;
                for (r in l) {
                    var g = l[r];
                    if (void 0 === g.face2 || p[g.face1].normal.dot(p[g.face2].normal) <= s) {
                        var y = u[g.index1];
                        a.push(y.x, y.y, y.z), y = u[g.index2], a.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new mi(a, 3))
            }

            function vc(t, e, n, i, r, o, a, s) {
                Ki.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new gc(t, e, n, i, r, o, a, s)), this.mergeVertices()
            }

            function gc(t, e, n, i, r, o, a, s) {
                Si.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                };
                var c = this;
                t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
                var l = [],
                    h = [],
                    u = [],
                    p = [],
                    d = 0,
                    f = [],
                    m = n / 2,
                    v = 0;

                function g(n) {
                    var r, o, f, g = new Ae,
                        y = new Ce,
                        _ = 0,
                        x = !0 === n ? t : e,
                        b = !0 === n ? 1 : -1;
                    for (o = d, r = 1; r <= i; r++) h.push(0, m * b, 0), u.push(0, b, 0), p.push(.5, .5), d++;
                    for (f = d, r = 0; r <= i; r++) {
                        var w = r / i,
                            M = w * s + a,
                            T = Math.cos(M),
                            E = Math.sin(M);
                        y.x = x * E, y.y = m * b, y.z = x * T, h.push(y.x, y.y, y.z), u.push(0, b, 0), g.x = .5 * T + .5, g.y = .5 * E * b + .5, p.push(g.x, g.y), d++
                    }
                    for (r = 0; r < i; r++) {
                        var S = o + r,
                            A = f + r;
                        !0 === n ? l.push(A, A + 1, S) : l.push(A + 1, A, S), _ += 3
                    }
                    c.addGroup(v, _, !0 === n ? 1 : 2), v += _
                }! function() {
                    var o, g, y = new Ce,
                        _ = new Ce,
                        x = 0,
                        b = (e - t) / n;
                    for (g = 0; g <= r; g++) {
                        var w = [],
                            M = g / r,
                            T = M * (e - t) + t;
                        for (o = 0; o <= i; o++) {
                            var E = o / i,
                                S = E * s + a,
                                A = Math.sin(S),
                                P = Math.cos(S);
                            _.x = T * A, _.y = -M * n + m, _.z = T * P, h.push(_.x, _.y, _.z), y.set(A, b, P).normalize(), u.push(y.x, y.y, y.z), p.push(E, 1 - M), w.push(d++)
                        }
                        f.push(w)
                    }
                    for (o = 0; o < i; o++)
                        for (g = 0; g < r; g++) {
                            var L = f[g][o],
                                R = f[g + 1][o],
                                C = f[g + 1][o + 1],
                                O = f[g][o + 1];
                            l.push(L, R, O), l.push(R, C, O), x += 6
                        }
                    c.addGroup(v, x, 0), v += x
                }(), !1 === o && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(l), this.addAttribute("position", new mi(h, 3)), this.addAttribute("normal", new mi(u, 3)), this.addAttribute("uv", new mi(p, 2))
            }

            function yc(t, e, n, i, r, o, a) {
                vc.call(this, 0, t, e, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function _c(t, e, n, i, r, o, a) {
                gc.call(this, 0, t, e, n, i, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function xc(t, e, n, i) {
                Ki.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: i
                }, this.fromBufferGeometry(new bc(t, e, n, i)), this.mergeVertices()
            }

            function bc(t, e, n, i) {
                Si.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: i
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI;
                var r, o, a = [],
                    s = [],
                    c = [],
                    l = [],
                    h = new Ce,
                    u = new Ae;
                for (s.push(0, 0, 0), c.push(0, 0, 1), l.push(.5, .5), o = 0, r = 3; o <= e; o++, r += 3) {
                    var p = n + o / e * i;
                    h.x = t * Math.cos(p), h.y = t * Math.sin(p), s.push(h.x, h.y, h.z), c.push(0, 0, 1), u.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, l.push(u.x, u.y)
                }
                for (r = 1; r <= e; r++) a.push(r, r + 1, 0);
                this.setIndex(a), this.addAttribute("position", new mi(s, 3)), this.addAttribute("normal", new mi(c, 3)), this.addAttribute("uv", new mi(l, 2))
            }
            rc.prototype = Object.create(Ki.prototype), rc.prototype.constructor = rc, oc.prototype = Object.create(ec.prototype), oc.prototype.constructor = oc, ac.prototype = Object.create(Ki.prototype), ac.prototype.constructor = ac, sc.prototype = Object.create(Si.prototype), sc.prototype.constructor = sc, cc.prototype = Object.create(Ki.prototype), cc.prototype.constructor = cc, lc.prototype = Object.create(Si.prototype), lc.prototype.constructor = lc, hc.prototype = Object.create(Ki.prototype), hc.prototype.constructor = hc, uc.prototype = Object.create(Si.prototype), uc.prototype.constructor = uc, pc.prototype = Object.create(Ki.prototype), pc.prototype.constructor = pc, pc.prototype.toJSON = function() {
                var t = Ki.prototype.toJSON.call(this),
                    e = this.parameters.shapes;
                return fc(e, t)
            }, dc.prototype = Object.create(Si.prototype), dc.prototype.constructor = dc, dc.prototype.toJSON = function() {
                var t = Si.prototype.toJSON.call(this),
                    e = this.parameters.shapes;
                return fc(e, t)
            }, mc.prototype = Object.create(Si.prototype), mc.prototype.constructor = mc, vc.prototype = Object.create(Ki.prototype), vc.prototype.constructor = vc, gc.prototype = Object.create(Si.prototype), gc.prototype.constructor = gc, yc.prototype = Object.create(vc.prototype), yc.prototype.constructor = yc, _c.prototype = Object.create(gc.prototype), _c.prototype.constructor = _c, xc.prototype = Object.create(Ki.prototype), xc.prototype.constructor = xc, bc.prototype = Object.create(Si.prototype), bc.prototype.constructor = bc;
            var wc = Object.freeze({
                WireframeGeometry: hs,
                ParametricGeometry: us,
                ParametricBufferGeometry: ps,
                TetrahedronGeometry: ms,
                TetrahedronBufferGeometry: vs,
                OctahedronGeometry: gs,
                OctahedronBufferGeometry: ys,
                IcosahedronGeometry: _s,
                IcosahedronBufferGeometry: xs,
                DodecahedronGeometry: bs,
                DodecahedronBufferGeometry: ws,
                PolyhedronGeometry: ds,
                PolyhedronBufferGeometry: fs,
                TubeGeometry: Ms,
                TubeBufferGeometry: Ts,
                TorusKnotGeometry: Es,
                TorusKnotBufferGeometry: Ss,
                TorusGeometry: As,
                TorusBufferGeometry: Ps,
                TextGeometry: rc,
                TextBufferGeometry: oc,
                SphereGeometry: ac,
                SphereBufferGeometry: sc,
                RingGeometry: cc,
                RingBufferGeometry: lc,
                PlaneGeometry: Er,
                PlaneBufferGeometry: Sr,
                LatheGeometry: hc,
                LatheBufferGeometry: uc,
                ShapeGeometry: pc,
                ShapeBufferGeometry: dc,
                ExtrudeGeometry: tc,
                ExtrudeBufferGeometry: ec,
                EdgesGeometry: mc,
                ConeGeometry: yc,
                ConeBufferGeometry: _c,
                CylinderGeometry: vc,
                CylinderBufferGeometry: gc,
                CircleGeometry: xc,
                CircleBufferGeometry: bc,
                BoxGeometry: Qi,
                BoxBufferGeometry: $i
            });

            function Mc(t) {
                oi.call(this), this.type = "ShadowMaterial", this.color = new $n(0), this.transparent = !0, this.setValues(t)
            }

            function Tc(t) {
                or.call(this, t), this.type = "RawShaderMaterial"
            }

            function Ec(t) {
                oi.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new $n(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $n(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _e, this.normalScale = new Ae(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Sc(t) {
                Ec.call(this), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearcoat = 0, this.clearcoatRoughness = 0, this.sheen = null, this.clearcoatNormalScale = new Ae(1, 1), this.clearcoatNormalMap = null, this.transparency = 0, this.setValues(t)
            }

            function Ac(t) {
                oi.call(this), this.type = "MeshPhongMaterial", this.color = new $n(16777215), this.specular = new $n(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $n(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _e, this.normalScale = new Ae(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Pc(t) {
                Ac.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
            }

            function Lc(t) {
                oi.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _e, this.normalScale = new Ae(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Rc(t) {
                oi.call(this), this.type = "MeshLambertMaterial", this.color = new $n(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $n(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Cc(t) {
                oi.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new $n(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _e, this.normalScale = new Ae(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Oc(t) {
                Ga.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            Mc.prototype = Object.create(oi.prototype), Mc.prototype.constructor = Mc, Mc.prototype.isShadowMaterial = !0, Mc.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, Tc.prototype = Object.create(or.prototype), Tc.prototype.constructor = Tc, Tc.prototype.isRawShaderMaterial = !0, Ec.prototype = Object.create(oi.prototype), Ec.prototype.constructor = Ec, Ec.prototype.isMeshStandardMaterial = !0, Ec.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Sc.prototype = Object.create(Ec.prototype), Sc.prototype.constructor = Sc, Sc.prototype.isMeshPhysicalMaterial = !0, Sc.prototype.copy = function(t) {
                return Ec.prototype.copy.call(this, t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.reflectivity = t.reflectivity, this.clearcoat = t.clearcoat, this.clearcoatRoughness = t.clearcoatRoughness, t.sheen ? this.sheen = (this.sheen || new $n).copy(t.sheen) : this.sheen = null, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.transparency = t.transparency, this
            }, Ac.prototype = Object.create(oi.prototype), Ac.prototype.constructor = Ac, Ac.prototype.isMeshPhongMaterial = !0, Ac.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Pc.prototype = Object.create(Ac.prototype), Pc.prototype.constructor = Pc, Pc.prototype.isMeshToonMaterial = !0, Pc.prototype.copy = function(t) {
                return Ac.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
            }, Lc.prototype = Object.create(oi.prototype), Lc.prototype.constructor = Lc, Lc.prototype.isMeshNormalMaterial = !0, Lc.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Rc.prototype = Object.create(oi.prototype), Rc.prototype.constructor = Rc, Rc.prototype.isMeshLambertMaterial = !0, Rc.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Cc.prototype = Object.create(oi.prototype), Cc.prototype.constructor = Cc, Cc.prototype.isMeshMatcapMaterial = !0, Cc.prototype.copy = function(t) {
                return oi.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Oc.prototype = Object.create(Ga.prototype), Oc.prototype.constructor = Oc, Oc.prototype.isLineDashedMaterial = !0, Oc.prototype.copy = function(t) {
                return Ga.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var Ic = Object.freeze({
                    ShadowMaterial: Mc,
                    SpriteMaterial: ya,
                    RawShaderMaterial: Tc,
                    ShaderMaterial: or,
                    PointsMaterial: $a,
                    MeshPhysicalMaterial: Sc,
                    MeshStandardMaterial: Ec,
                    MeshPhongMaterial: Ac,
                    MeshToonMaterial: Pc,
                    MeshNormalMaterial: Lc,
                    MeshLambertMaterial: Rc,
                    MeshDepthMaterial: Jo,
                    MeshDistanceMaterial: Ko,
                    MeshBasicMaterial: ai,
                    MeshMatcapMaterial: Cc,
                    LineDashedMaterial: Oc,
                    LineBasicMaterial: Ga,
                    Material: oi
                }),
                Dc = {
                    arraySlice: function(t, e, n) {
                        return Dc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                    },
                    convertArray: function(t, e, n) {
                        return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(t) {
                        for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i) n[i] = i;
                        return n.sort(function(e, n) {
                            return t[e] - t[n]
                        }), n
                    },
                    sortedArray: function(t, e, n) {
                        for (var i = t.length, r = new t.constructor(i), o = 0, a = 0; a !== i; ++o)
                            for (var s = n[o] * e, c = 0; c !== e; ++c) r[a++] = t[s + c];
                        return r
                    },
                    flattenJSON: function(t, e, n, i) {
                        for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[i];) o = t[r++];
                        if (void 0 !== o) {
                            var a = o[i];
                            if (void 0 !== a)
                                if (Array.isArray(a))
                                    do {
                                        void 0 !== (a = o[i]) && (e.push(o.time), n.push.apply(n, a)), o = t[r++]
                                    } while (void 0 !== o);
                                else if (void 0 !== a.toArray)
                                do {
                                    void 0 !== (a = o[i]) && (e.push(o.time), a.toArray(n, n.length)), o = t[r++]
                                } while (void 0 !== o);
                            else
                                do {
                                    void 0 !== (a = o[i]) && (e.push(o.time), n.push(a)), o = t[r++]
                                } while (void 0 !== o)
                        }
                    }
                };

            function Nc(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
            }

            function Bc(t, e, n, i) {
                Nc.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function Hc(t, e, n, i) {
                Nc.call(this, t, e, n, i)
            }

            function Fc(t, e, n, i) {
                Nc.call(this, t, e, n, i)
            }

            function kc(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Dc.convertArray(e, this.TimeBufferType), this.values = Dc.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }

            function Uc(t, e, n) {
                kc.call(this, t, e, n)
            }

            function zc(t, e, n, i) {
                kc.call(this, t, e, n, i)
            }

            function Gc(t, e, n, i) {
                kc.call(this, t, e, n, i)
            }

            function jc(t, e, n, i) {
                Nc.call(this, t, e, n, i)
            }

            function Vc(t, e, n, i) {
                kc.call(this, t, e, n, i)
            }

            function Wc(t, e, n, i) {
                kc.call(this, t, e, n, i)
            }

            function Xc(t, e, n, i) {
                kc.call(this, t, e, n, i)
            }

            function qc(t, e, n) {
                this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = Se.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function Yc(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Gc;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Xc;
                        case "color":
                            return zc;
                        case "quaternion":
                            return Vc;
                        case "bool":
                        case "boolean":
                            return Uc;
                        case "string":
                            return Wc
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    var n = [],
                        i = [];
                    Dc.flattenJSON(t.keys, n, i, "value"), t.times = n, t.values = i
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            Object.assign(Nc.prototype, {
                    evaluate: function(t) {
                        var e = this.parameterPositions,
                            n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                var o;n: {
                                    i: if (!(t < i)) {
                                        for (var a = n + 2;;) {
                                            if (void 0 === i) {
                                                if (t < r) break i;
                                                return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                            }
                                            if (n === a) break;
                                            if (r = i, i = e[++n], t < i) break e
                                        }
                                        o = e.length;
                                        break n
                                    }if (t >= r) break t;
                                    var s = e[1];t < s && (n = 2, r = s);
                                    for (var a = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                        if (n === a) break;
                                        if (i = r, r = e[--n - 1], t >= r) break e
                                    }
                                    o = n,
                                    n = 0
                                }
                                for (; n < o;) {
                                    var c = n + o >>> 1;
                                    t < e[c] ? o = c : n = c + 1
                                }
                                if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, r, i)
                        }
                        return this.interpolate_(n, r, t, i)
                    },
                    settings: null,
                    DefaultSettings_: {},
                    getSettings_: function() {
                        return this.settings || this.DefaultSettings_
                    },
                    copySampleValue_: function(t) {
                        for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, o = 0; o !== i; ++o) e[o] = n[r + o];
                        return e
                    },
                    interpolate_: function() {
                        throw new Error("call to abstract method")
                    },
                    intervalChanged_: function() {}
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(Nc.prototype, {
                    beforeStart_: Nc.prototype.copySampleValue_,
                    afterEnd_: Nc.prototype.copySampleValue_
                }), Bc.prototype = Object.assign(Object.create(Nc.prototype), {
                    constructor: Bc,
                    DefaultSettings_: {
                        endingStart: oe,
                        endingEnd: oe
                    },
                    intervalChanged_: function(t, e, n) {
                        var i = this.parameterPositions,
                            r = t - 2,
                            o = t + 1,
                            a = i[r],
                            s = i[o];
                        if (void 0 === a) switch (this.getSettings_().endingStart) {
                            case 2401:
                                r = t, a = 2 * e - n;
                                break;
                            case 2402:
                                r = i.length - 2, a = e + i[r] - i[r + 1];
                                break;
                            default:
                                r = t, a = n
                        }
                        if (void 0 === s) switch (this.getSettings_().endingEnd) {
                            case 2401:
                                o = t, s = 2 * n - e;
                                break;
                            case 2402:
                                o = 1, s = n + i[1] - i[0];
                                break;
                            default:
                                o = t - 1, s = e
                        }
                        var c = .5 * (n - e),
                            l = this.valueSize;
                        this._weightPrev = c / (e - a), this._weightNext = c / (s - n), this._offsetPrev = r * l, this._offsetNext = o * l
                    },
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (n - e) / (i - e), f = d * d, m = f * d, v = -u * m + 2 * u * f - u * d, g = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, _ = p * m - p * f, x = 0; x !== a; ++x) r[x] = v * o[l + x] + g * o[c + x] + y * o[s + x] + _ * o[h + x];
                        return r
                    }
                }), Hc.prototype = Object.assign(Object.create(Nc.prototype), {
                    constructor: Hc,
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = (n - e) / (i - e), h = 1 - l, u = 0; u !== a; ++u) r[u] = o[c + u] * h + o[s + u] * l;
                        return r
                    }
                }), Fc.prototype = Object.assign(Object.create(Nc.prototype), {
                    constructor: Fc,
                    interpolate_: function(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }), Object.assign(kc, {
                    toJSON: function(t) {
                        var e, n = t.constructor;
                        if (void 0 !== n.toJSON) e = n.toJSON(t);
                        else {
                            e = {
                                name: t.name,
                                times: Dc.convertArray(t.times, Array),
                                values: Dc.convertArray(t.values, Array)
                            };
                            var i = t.getInterpolation();
                            i !== t.DefaultInterpolation && (e.interpolation = i)
                        }
                        return e.type = t.ValueTypeName, e
                    }
                }), Object.assign(kc.prototype, {
                    constructor: kc,
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: 2301,
                    InterpolantFactoryMethodDiscrete: function(t) {
                        return new Fc(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodLinear: function(t) {
                        return new Hc(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: function(t) {
                        return new Bc(this.times, this.values, this.getValueSize(), t)
                    },
                    setInterpolation: function(t) {
                        var e;
                        switch (t) {
                            case 2300:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case 2301:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case 2302:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(n);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", n), this
                        }
                        return this.createInterpolant = e, this
                    },
                    getInterpolation: function() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return 2300;
                            case this.InterpolantFactoryMethodLinear:
                                return 2301;
                            case this.InterpolantFactoryMethodSmooth:
                                return 2302
                        }
                    },
                    getValueSize: function() {
                        return this.values.length / this.times.length
                    },
                    shift: function(t) {
                        if (0 !== t)
                            for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] += t;
                        return this
                    },
                    scale: function(t) {
                        if (1 !== t)
                            for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] *= t;
                        return this
                    },
                    trim: function(t, e) {
                        for (var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < t;) ++r;
                        for (; - 1 !== o && n[o] > e;) --o;
                        if (++o, 0 !== r || o !== i) {
                            r >= o && (o = Math.max(o, 1), r = o - 1);
                            var a = this.getValueSize();
                            this.times = Dc.arraySlice(n, r, o), this.values = Dc.arraySlice(this.values, r * a, o * a)
                        }
                        return this
                    },
                    validate: function() {
                        var t = !0,
                            e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        var n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        for (var o = null, a = 0; a !== r; a++) {
                            var s = n[a];
                            if ("number" == typeof s && isNaN(s)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                                break
                            }
                            if (null !== o && o > s) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                                break
                            }
                            o = s
                        }
                        if (void 0 !== i && Dc.isTypedArray(i))
                            for (var a = 0, c = i.length; a !== c; ++a) {
                                var l = i[a];
                                if (isNaN(l)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), t = !1;
                                    break
                                }
                            }
                        return t
                    },
                    optimize: function() {
                        for (var t = this.times, e = this.values, n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                            var s = !1,
                                c = t[a],
                                l = t[a + 1];
                            if (c !== l && (1 !== a || c !== c[0]))
                                if (i) s = !0;
                                else
                                    for (var h = a * n, u = h - n, p = h + n, d = 0; d !== n; ++d) {
                                        var f = e[h + d];
                                        if (f !== e[u + d] || f !== e[p + d]) {
                                            s = !0;
                                            break
                                        }
                                    }
                            if (s) {
                                if (a !== r) {
                                    t[r] = t[a];
                                    for (var m = a * n, v = r * n, d = 0; d !== n; ++d) e[v + d] = e[m + d]
                                }++r
                            }
                        }
                        if (o > 0) {
                            t[r] = t[o];
                            for (var m = o * n, v = r * n, d = 0; d !== n; ++d) e[v + d] = e[m + d];
                            ++r
                        }
                        return r !== t.length && (this.times = Dc.arraySlice(t, 0, r), this.values = Dc.arraySlice(e, 0, r * n)), this
                    },
                    clone: function() {
                        var t = Dc.arraySlice(this.times, 0),
                            e = Dc.arraySlice(this.values, 0),
                            n = this.constructor,
                            i = new n(this.name, t, e);
                        return i.createInterpolant = this.createInterpolant, i
                    }
                }), Uc.prototype = Object.assign(Object.create(kc.prototype), {
                    constructor: Uc,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: 2300,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), zc.prototype = Object.assign(Object.create(kc.prototype), {
                    constructor: zc,
                    ValueTypeName: "color"
                }), Gc.prototype = Object.assign(Object.create(kc.prototype), {
                    constructor: Gc,
                    ValueTypeName: "number"
                }), jc.prototype = Object.assign(Object.create(Nc.prototype), {
                    constructor: jc,
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = (n - e) / (i - e), l = s + a; s !== l; s += 4) Pe.slerpFlat(r, 0, o, s - a, o, s, c);
                        return r
                    }
                }), Vc.prototype = Object.assign(Object.create(kc.prototype), {
                    constructor: Vc,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: 2301,
                    InterpolantFactoryMethodLinear: function(t) {
                        return new jc(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: void 0
                }), Wc.prototype = Object.assign(Object.create(kc.prototype), {
                    constructor: Wc,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: 2300,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), Xc.prototype = Object.assign(Object.create(kc.prototype), {
                    constructor: Xc,
                    ValueTypeName: "vector"
                }), Object.assign(qc, {
                    parse: function(t) {
                        for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, o = n.length; r !== o; ++r) e.push(Yc(n[r]).scale(i));
                        return new qc(t.name, t.duration, e)
                    },
                    toJSON: function(t) {
                        for (var e = [], n = t.tracks, i = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid
                            }, r = 0, o = n.length; r !== o; ++r) e.push(kc.toJSON(n[r]));
                        return i
                    },
                    CreateFromMorphTargetSequence: function(t, e, n, i) {
                        for (var r = e.length, o = [], a = 0; a < r; a++) {
                            var s = [],
                                c = [];
                            s.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
                            var l = Dc.getKeyframeOrder(s);
                            s = Dc.sortedArray(s, 1, l), c = Dc.sortedArray(c, 1, l), i || 0 !== s[0] || (s.push(r), c.push(c[0])), o.push(new Gc(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(1 / n))
                        }
                        return new qc(t, -1, o)
                    },
                    findByName: function(t, e) {
                        var n = t;
                        if (!Array.isArray(t)) {
                            var i = t;
                            n = i.geometry && i.geometry.animations || i.animations
                        }
                        for (var r = 0; r < n.length; r++)
                            if (n[r].name === e) return n[r];
                        return null
                    },
                    CreateClipsFromMorphTargetSequences: function(t, e, n) {
                        for (var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                            var s = t[o],
                                c = s.name.match(r);
                            if (c && c.length > 1) {
                                var l = c[1],
                                    h = i[l];
                                h || (i[l] = h = []), h.push(s)
                            }
                        }
                        var u = [];
                        for (var l in i) u.push(qc.CreateFromMorphTargetSequence(l, i[l], e, n));
                        return u
                    },
                    parseAnimation: function(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        for (var n = function(t, e, n, i, r) {
                                if (0 !== n.length) {
                                    var o = [],
                                        a = [];
                                    Dc.flattenJSON(n, o, a, i), 0 !== o.length && r.push(new t(e, o, a))
                                }
                            }, i = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                            var l = s[c].keys;
                            if (l && 0 !== l.length)
                                if (l[0].morphTargets) {
                                    for (var h = {}, u = 0; u < l.length; u++)
                                        if (l[u].morphTargets)
                                            for (var p = 0; p < l[u].morphTargets.length; p++) h[l[u].morphTargets[p]] = -1;
                                    for (var d in h) {
                                        for (var f = [], m = [], p = 0; p !== l[u].morphTargets.length; ++p) {
                                            var v = l[u];
                                            f.push(v.time), m.push(v.morphTarget === d ? 1 : 0)
                                        }
                                        i.push(new Gc(".morphTargetInfluence[" + d + "]", f, m))
                                    }
                                    o = h.length * (a || 1)
                                } else {
                                    var g = ".bones[" + e[c].name + "]";
                                    n(Xc, g + ".position", l, "pos", i), n(Vc, g + ".quaternion", l, "rot", i), n(Xc, g + ".scale", l, "scl", i)
                                }
                        }
                        if (0 === i.length) return null;
                        var y = new qc(r, o, i);
                        return y
                    }
                }), Object.assign(qc.prototype, {
                    resetDuration: function() {
                        for (var t = this.tracks, e = 0, n = 0, i = t.length; n !== i; ++n) {
                            var r = this.tracks[n];
                            e = Math.max(e, r.times[r.times.length - 1])
                        }
                        return this.duration = e, this
                    },
                    trim: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                        return this
                    },
                    validate: function() {
                        for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                        return t
                    },
                    optimize: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                        return this
                    },
                    clone: function() {
                        for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                        return new qc(this.name, this.duration, t)
                    }
                });
            var Zc = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function Jc(t, e, n) {
                var i = this,
                    r = !1,
                    o = 0,
                    a = 0,
                    s = void 0,
                    c = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    a++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, a), r = !0
                }, this.itemEnd = function(t) {
                    o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (r = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function(t) {
                    return s ? s(t) : t
                }, this.setURLModifier = function(t) {
                    return s = t, this
                }, this.addHandler = function(t, e) {
                    return c.push(t, e), this
                }, this.removeHandler = function(t) {
                    var e = c.indexOf(t);
                    return -1 !== e && c.splice(e, 2), this
                }, this.getHandler = function(t) {
                    for (var e = 0, n = c.length; e < n; e += 2) {
                        var i = c[e],
                            r = c[e + 1];
                        if (i.test(t)) return r
                    }
                    return null
                }
            }
            var Kc = new Jc;

            function Qc(t) {
                this.manager = void 0 !== t ? t : Kc, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = ""
            }
            Object.assign(Qc.prototype, {
                load: function() {},
                parse: function() {},
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                }
            });
            var $c = {};

            function tl(t) {
                Qc.call(this, t)
            }

            function el(t) {
                Qc.call(this, t)
            }

            function nl(t) {
                Qc.call(this, t)
            }

            function il(t) {
                Qc.call(this, t)
            }

            function rl(t) {
                Qc.call(this, t)
            }

            function ol(t) {
                Qc.call(this, t)
            }

            function al(t) {
                Qc.call(this, t)
            }

            function sl() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function cl(t, e, n, i, r, o, a, s) {
                sl.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
            }

            function ll(t, e, n, i, r, o) {
                cl.call(this, t, e, n, n, i, r, o), this.type = "ArcCurve"
            }

            function hl() {
                var t = 0,
                    e = 0,
                    n = 0,
                    i = 0;

                function r(r, o, a, s) {
                    t = r, e = a, n = -3 * r + 3 * o - 2 * a - s, i = 2 * r - 2 * o + a + s
                }
                return {
                    initCatmullRom: function(t, e, n, i, o) {
                        r(e, n, o * (n - t), o * (i - e))
                    },
                    initNonuniformCatmullRom: function(t, e, n, i, o, a, s) {
                        var c = (e - t) / o - (n - t) / (o + a) + (n - e) / a,
                            l = (n - e) / a - (i - e) / (a + s) + (i - n) / s;
                        r(e, n, c *= a, l *= a)
                    },
                    calc: function(r) {
                        var o = r * r,
                            a = o * r;
                        return t + e * r + n * o + i * a
                    }
                }
            }
            tl.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: tl,
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Zc.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    if (void 0 === $c[t]) {
                        var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (a) {
                            var s = a[1],
                                c = !!a[2],
                                l = a[3];
                            l = decodeURIComponent(l), c && (l = atob(l));
                            try {
                                var h, u = (this.responseType || "").toLowerCase();
                                switch (u) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var p = new Uint8Array(l.length), d = 0; d < l.length; d++) p[d] = l.charCodeAt(d);
                                        h = "blob" === u ? new Blob([p.buffer], {
                                            type: s
                                        }) : p.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        h = f.parseFromString(l, s);
                                        break;
                                    case "json":
                                        h = JSON.parse(l);
                                        break;
                                    default:
                                        h = l
                                }
                                setTimeout(function() {
                                    e && e(h), r.manager.itemEnd(t)
                                }, 0)
                            } catch (e) {
                                setTimeout(function() {
                                    i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                                }, 0)
                            }
                        } else {
                            $c[t] = [], $c[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: i
                            });
                            var m = new XMLHttpRequest;
                            for (var v in m.open("GET", t, !0), m.addEventListener("load", function(e) {
                                    var n = this.response;
                                    Zc.add(t, n);
                                    var i = $c[t];
                                    if (delete $c[t], 200 === this.status || 0 === this.status) {
                                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                        for (var o = 0, a = i.length; o < a; o++) {
                                            var s = i[o];
                                            s.onLoad && s.onLoad(n)
                                        }
                                        r.manager.itemEnd(t)
                                    } else {
                                        for (var o = 0, a = i.length; o < a; o++) {
                                            var s = i[o];
                                            s.onError && s.onError(e)
                                        }
                                        r.manager.itemError(t), r.manager.itemEnd(t)
                                    }
                                }, !1), m.addEventListener("progress", function(e) {
                                    for (var n = $c[t], i = 0, r = n.length; i < r; i++) {
                                        var o = n[i];
                                        o.onProgress && o.onProgress(e)
                                    }
                                }, !1), m.addEventListener("error", function(e) {
                                    var n = $c[t];
                                    delete $c[t];
                                    for (var i = 0, o = n.length; i < o; i++) {
                                        var a = n[i];
                                        a.onError && a.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }, !1), m.addEventListener("abort", function(e) {
                                    var n = $c[t];
                                    delete $c[t];
                                    for (var i = 0, o = n.length; i < o; i++) {
                                        var a = n[i];
                                        a.onError && a.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                            m.send(null)
                        }
                        return r.manager.itemStart(t), m
                    }
                    $c[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    })
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            }), el.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: el,
                load: function(t, e, n, i) {
                    var r = this,
                        o = new tl(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, n, i)
                },
                parse: function(t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                        var i = qc.parse(t[n]);
                        e.push(i)
                    }
                    return e
                }
            }), nl.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: nl,
                load: function(t, e, n, i) {
                    var r = this,
                        o = [],
                        a = new ss;
                    a.image = o;
                    var s = new tl(this.manager);

                    function c(c) {
                        s.load(t[c], function(t) {
                            var n = r.parse(t, !0);
                            o[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, 6 === (l += 1) && (1 === n.mipmapCount && (a.minFilter = ut), a.format = n.format, a.needsUpdate = !0, e && e(a))
                        }, n, i)
                    }
                    if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                        for (var l = 0, h = 0, u = t.length; h < u; ++h) c(h);
                    else s.load(t, function(t) {
                        var n = r.parse(t, !0);
                        if (n.isCubemap)
                            for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                                o[s] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < n.mipmapCount; c++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
                            } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (a.minFilter = ut), a.format = n.format, a.needsUpdate = !0, e && e(a)
                    }, n, i);
                    return a
                }
            }), il.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: il,
                load: function(t, e, n, i) {
                    var r = this,
                        o = new pr,
                        a = new tl(this.manager);
                    return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(t, function(t) {
                        var n = r.parse(t);
                        n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : at, o.wrapT = void 0 !== n.wrapT ? n.wrapT : at, o.magFilter = void 0 !== n.magFilter ? n.magFilter : ut, o.minFilter = void 0 !== n.minFilter ? n.minFilter : dt, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps), 1 === n.mipmapCount && (o.minFilter = ut), o.needsUpdate = !0, e && e(o, n))
                    }, n, i), o
                }
            }), rl.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: rl,
                load: function(t, e, n, i) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Zc.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), Zc.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function c(e) {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                }
            }), ol.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: ol,
                load: function(t, e, n, i) {
                    var r = new Pr,
                        o = new rl(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;

                    function s(n) {
                        o.load(t[n], function(t) {
                            r.images[n] = t, 6 == ++a && (r.needsUpdate = !0, e && e(r))
                        }, void 0, i)
                    }
                    for (var c = 0; c < t.length; ++c) s(c);
                    return r
                }
            }), al.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: al,
                load: function(t, e, n, i) {
                    var r = new He,
                        o = new rl(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(n) {
                        r.image = n;
                        var i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        r.format = i ? At : Pt, r.needsUpdate = !0, void 0 !== e && e(r)
                    }, n, i), r
                }
            }), Object.assign(sl.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    var n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, n, i = [],
                        r = this.getPoint(0),
                        o = 0;
                    for (i.push(0), n = 1; n <= t; n++) e = this.getPoint(n / t), o += e.distanceTo(r), i.push(o), r = e;
                    return this.cacheArcLengths = i, i
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    var n, i = this.getLengths(),
                        r = 0,
                        o = i.length;
                    n = e || t * i[o - 1];
                    for (var a, s = 0, c = o - 1; s <= c;)
                        if (r = Math.floor(s + (c - s) / 2), (a = i[r] - n) < 0) s = r + 1;
                        else {
                            if (!(a > 0)) {
                                c = r;
                                break
                            }
                            c = r - 1
                        }
                    if (i[r = c] === n) return r / (o - 1);
                    var l = i[r],
                        h = i[r + 1],
                        u = h - l,
                        p = (n - l) / u,
                        d = (r + p) / (o - 1);
                    return d
                },
                getTangent: function(t) {
                    var e = t - 1e-4,
                        n = t + 1e-4;
                    e < 0 && (e = 0), n > 1 && (n = 1);
                    var i = this.getPoint(e),
                        r = this.getPoint(n),
                        o = r.clone().sub(i);
                    return o.normalize()
                },
                getTangentAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getTangent(e)
                },
                computeFrenetFrames: function(t, e) {
                    var n, i, r, o = new Ce,
                        a = [],
                        s = [],
                        c = [],
                        l = new Ce,
                        h = new Ye;
                    for (n = 0; n <= t; n++) i = n / t, a[n] = this.getTangentAt(i), a[n].normalize();
                    s[0] = new Ce, c[0] = new Ce;
                    var u = Number.MAX_VALUE,
                        p = Math.abs(a[0].x),
                        d = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (p <= u && (u = p, o.set(1, 0, 0)), d <= u && (u = d, o.set(0, 1, 0)), f <= u && o.set(0, 0, 1), l.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], l), c[0].crossVectors(a[0], s[0]), n = 1; n <= t; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), l.crossVectors(a[n - 1], a[n]), l.length() > Number.EPSILON && (l.normalize(), r = Math.acos(Se.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(h.makeRotationAxis(l, r))), c[n].crossVectors(a[n], s[n]);
                    if (!0 === e)
                        for (r = Math.acos(Se.clamp(s[0].dot(s[t]), -1, 1)), r /= t, a[0].dot(l.crossVectors(s[0], s[t])) > 0 && (r = -r), n = 1; n <= t; n++) s[n].applyMatrix4(h.makeRotationAxis(a[n], r * n)), c[n].crossVectors(a[n], s[n]);
                    return {
                        tangents: a,
                        normals: s,
                        binormals: c
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), cl.prototype = Object.create(sl.prototype), cl.prototype.constructor = cl, cl.prototype.isEllipseCurve = !0, cl.prototype.getPoint = function(t, e) {
                for (var n = e || new Ae, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0;) r += i;
                for (; r > i;) r -= i;
                r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
                var a = this.aStartAngle + t * r,
                    s = this.aX + this.xRadius * Math.cos(a),
                    c = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var l = Math.cos(this.aRotation),
                        h = Math.sin(this.aRotation),
                        u = s - this.aX,
                        p = c - this.aY;
                    s = u * l - p * h + this.aX, c = u * h + p * l + this.aY
                }
                return n.set(s, c)
            }, cl.prototype.copy = function(t) {
                return sl.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, cl.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, cl.prototype.fromJSON = function(t) {
                return sl.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, ll.prototype = Object.create(cl.prototype), ll.prototype.constructor = ll, ll.prototype.isArcCurve = !0;
            var ul = new Ce,
                pl = new hl,
                dl = new hl,
                fl = new hl;

            function ml(t, e, n, i) {
                sl.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = i || .5
            }

            function vl(t, e, n, i, r) {
                var o = .5 * (i - e),
                    a = .5 * (r - n),
                    s = t * t,
                    c = t * s;
                return (2 * n - 2 * i + o + a) * c + (-3 * n + 3 * i - 2 * o - a) * s + o * t + n
            }

            function gl(t, e, n, i) {
                return function(t, e) {
                    var n = 1 - t;
                    return n * n * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, n) + function(t, e) {
                    return t * t * e
                }(t, i)
            }

            function yl(t, e, n, i, r) {
                return function(t, e) {
                    var n = 1 - t;
                    return n * n * n * e
                }(t, e) + function(t, e) {
                    var n = 1 - t;
                    return 3 * n * n * t * e
                }(t, n) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, i) + function(t, e) {
                    return t * t * t * e
                }(t, r)
            }

            function _l(t, e, n, i) {
                sl.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Ae, this.v1 = e || new Ae, this.v2 = n || new Ae, this.v3 = i || new Ae
            }

            function xl(t, e, n, i) {
                sl.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Ce, this.v1 = e || new Ce, this.v2 = n || new Ce, this.v3 = i || new Ce
            }

            function bl(t, e) {
                sl.call(this), this.type = "LineCurve", this.v1 = t || new Ae, this.v2 = e || new Ae
            }

            function wl(t, e) {
                sl.call(this), this.type = "LineCurve3", this.v1 = t || new Ce, this.v2 = e || new Ce
            }

            function Ml(t, e, n) {
                sl.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Ae, this.v1 = e || new Ae, this.v2 = n || new Ae
            }

            function Tl(t, e, n) {
                sl.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Ce, this.v1 = e || new Ce, this.v2 = n || new Ce
            }

            function El(t) {
                sl.call(this), this.type = "SplineCurve", this.points = t || []
            }
            ml.prototype = Object.create(sl.prototype), ml.prototype.constructor = ml, ml.prototype.isCatmullRomCurve3 = !0, ml.prototype.getPoint = function(t, e) {
                var n, i, r, o, a = e || new Ce,
                    s = this.points,
                    c = s.length,
                    l = (c - (this.closed ? 0 : 1)) * t,
                    h = Math.floor(l),
                    u = l - h;
                if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / c) + 1) * c : 0 === u && h === c - 1 && (h = c - 2, u = 1), this.closed || h > 0 ? n = s[(h - 1) % c] : (ul.subVectors(s[0], s[1]).add(s[0]), n = ul), i = s[h % c], r = s[(h + 1) % c], this.closed || h + 2 < c ? o = s[(h + 2) % c] : (ul.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = ul), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var p = "chordal" === this.curveType ? .5 : .25,
                        d = Math.pow(n.distanceToSquared(i), p),
                        f = Math.pow(i.distanceToSquared(r), p),
                        m = Math.pow(r.distanceToSquared(o), p);
                    f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), pl.initNonuniformCatmullRom(n.x, i.x, r.x, o.x, d, f, m), dl.initNonuniformCatmullRom(n.y, i.y, r.y, o.y, d, f, m), fl.initNonuniformCatmullRom(n.z, i.z, r.z, o.z, d, f, m)
                } else "catmullrom" === this.curveType && (pl.initCatmullRom(n.x, i.x, r.x, o.x, this.tension), dl.initCatmullRom(n.y, i.y, r.y, o.y, this.tension), fl.initCatmullRom(n.z, i.z, r.z, o.z, this.tension));
                return a.set(pl.calc(u), dl.calc(u), fl.calc(u)), a
            }, ml.prototype.copy = function(t) {
                sl.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push(i.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, ml.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, ml.prototype.fromJSON = function(t) {
                sl.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push((new Ce).fromArray(i))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, _l.prototype = Object.create(sl.prototype), _l.prototype.constructor = _l, _l.prototype.isCubicBezierCurve = !0, _l.prototype.getPoint = function(t, e) {
                var n = e || new Ae,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(yl(t, i.x, r.x, o.x, a.x), yl(t, i.y, r.y, o.y, a.y)), n
            }, _l.prototype.copy = function(t) {
                return sl.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, _l.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, _l.prototype.fromJSON = function(t) {
                return sl.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, xl.prototype = Object.create(sl.prototype), xl.prototype.constructor = xl, xl.prototype.isCubicBezierCurve3 = !0, xl.prototype.getPoint = function(t, e) {
                var n = e || new Ce,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(yl(t, i.x, r.x, o.x, a.x), yl(t, i.y, r.y, o.y, a.y), yl(t, i.z, r.z, o.z, a.z)), n
            }, xl.prototype.copy = function(t) {
                return sl.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, xl.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, xl.prototype.fromJSON = function(t) {
                return sl.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, bl.prototype = Object.create(sl.prototype), bl.prototype.constructor = bl, bl.prototype.isLineCurve = !0, bl.prototype.getPoint = function(t, e) {
                var n = e || new Ae;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, bl.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, bl.prototype.getTangent = function() {
                var t = this.v2.clone().sub(this.v1);
                return t.normalize()
            }, bl.prototype.copy = function(t) {
                return sl.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, bl.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, bl.prototype.fromJSON = function(t) {
                return sl.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, wl.prototype = Object.create(sl.prototype), wl.prototype.constructor = wl, wl.prototype.isLineCurve3 = !0, wl.prototype.getPoint = function(t, e) {
                var n = e || new Ce;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, wl.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, wl.prototype.copy = function(t) {
                return sl.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, wl.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, wl.prototype.fromJSON = function(t) {
                return sl.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Ml.prototype = Object.create(sl.prototype), Ml.prototype.constructor = Ml, Ml.prototype.isQuadraticBezierCurve = !0, Ml.prototype.getPoint = function(t, e) {
                var n = e || new Ae,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2;
                return n.set(gl(t, i.x, r.x, o.x), gl(t, i.y, r.y, o.y)), n
            }, Ml.prototype.copy = function(t) {
                return sl.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Ml.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Ml.prototype.fromJSON = function(t) {
                return sl.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Tl.prototype = Object.create(sl.prototype), Tl.prototype.constructor = Tl, Tl.prototype.isQuadraticBezierCurve3 = !0, Tl.prototype.getPoint = function(t, e) {
                var n = e || new Ce,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2;
                return n.set(gl(t, i.x, r.x, o.x), gl(t, i.y, r.y, o.y), gl(t, i.z, r.z, o.z)), n
            }, Tl.prototype.copy = function(t) {
                return sl.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Tl.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Tl.prototype.fromJSON = function(t) {
                return sl.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, El.prototype = Object.create(sl.prototype), El.prototype.constructor = El, El.prototype.isSplineCurve = !0, El.prototype.getPoint = function(t, e) {
                var n = e || new Ae,
                    i = this.points,
                    r = (i.length - 1) * t,
                    o = Math.floor(r),
                    a = r - o,
                    s = i[0 === o ? o : o - 1],
                    c = i[o],
                    l = i[o > i.length - 2 ? i.length - 1 : o + 1],
                    h = i[o > i.length - 3 ? i.length - 1 : o + 2];
                return n.set(vl(a, s.x, c.x, l.x, h.x), vl(a, s.y, c.y, l.y, h.y)), n
            }, El.prototype.copy = function(t) {
                sl.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push(i.clone())
                }
                return this
            }, El.prototype.toJSON = function() {
                var t = sl.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t
            }, El.prototype.fromJSON = function(t) {
                sl.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push((new Ae).fromArray(i))
                }
                return this
            };
            var Sl = Object.freeze({
                ArcCurve: ll,
                CatmullRomCurve3: ml,
                CubicBezierCurve: _l,
                CubicBezierCurve3: xl,
                EllipseCurve: cl,
                LineCurve: bl,
                LineCurve3: wl,
                QuadraticBezierCurve: Ml,
                QuadraticBezierCurve3: Tl,
                SplineCurve: El
            });

            function Al() {
                sl.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function Pl(t) {
                Al.call(this), this.type = "Path", this.currentPoint = new Ae, t && this.setFromPoints(t)
            }

            function Ll(t) {
                Pl.call(this, t), this.uuid = Se.generateUUID(), this.type = "Shape", this.holes = []
            }

            function Rl(t, e) {
                dn.call(this), this.type = "Light", this.color = new $n(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
            }

            function Cl(t, e, n) {
                Rl.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(dn.DefaultUp), this.updateMatrix(), this.groundColor = new $n(e)
            }

            function Ol(t) {
                this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new Ae(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ye, this._frustum = new _r, this._frameExtents = new Ae(1, 1), this._viewportCount = 1, this._viewports = [new Fe(0, 0, 1, 1)]
            }

            function Il() {
                Ol.call(this, new sr(50, 1, .5, 500))
            }

            function Dl(t, e, n, i, r, o) {
                Rl.call(this, t, e), this.type = "SpotLight", this.position.copy(dn.DefaultUp), this.updateMatrix(), this.target = new dn, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Il
            }

            function Nl() {
                Ol.call(this, new sr(90, 1, .5, 500)), this._frameExtents = new Ae(4, 2), this._viewportCount = 6, this._viewports = [new Fe(2, 1, 1, 1), new Fe(0, 1, 1, 1), new Fe(3, 1, 1, 1), new Fe(1, 1, 1, 1), new Fe(3, 0, 1, 1), new Fe(1, 0, 1, 1)], this._cubeDirections = [new Ce(1, 0, 0), new Ce(-1, 0, 0), new Ce(0, 0, 1), new Ce(0, 0, -1), new Ce(0, 1, 0), new Ce(0, -1, 0)], this._cubeUps = [new Ce(0, 1, 0), new Ce(0, 1, 0), new Ce(0, 1, 0), new Ce(0, 1, 0), new Ce(0, 0, 1), new Ce(0, 0, -1)]
            }

            function Bl(t, e, n, i) {
                Rl.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Nl
            }

            function Hl(t, e, n, i, r, o) {
                ar.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
            }

            function Fl() {
                Ol.call(this, new Hl(-5, 5, 5, -5, .5, 500))
            }

            function kl(t, e) {
                Rl.call(this, t, e), this.type = "DirectionalLight", this.position.copy(dn.DefaultUp), this.updateMatrix(), this.target = new dn, this.shadow = new Fl
            }

            function Ul(t, e) {
                Rl.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
            }

            function zl(t, e, n, i) {
                Rl.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
            }

            function Gl(t) {
                Qc.call(this, t), this.textures = {}
            }
            Al.prototype = Object.assign(Object.create(sl.prototype), {
                constructor: Al,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new bl(e, t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                        if (n[i] >= e) {
                            var r = n[i] - e,
                                o = this.curves[i],
                                a = o.getLength(),
                                s = 0 === a ? 0 : 1 - r / a;
                            return o.getPointAt(s)
                        }
                        i++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
                        for (var o = r[i], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) {
                            var l = s[c];
                            e && e.equals(l) || (n.push(l), e = l)
                        }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function(t) {
                    sl.prototype.copy.call(this, t), this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var i = t.curves[e];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    var t = sl.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (var e = 0, n = this.curves.length; e < n; e++) {
                        var i = this.curves[e];
                        t.curves.push(i.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    sl.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var i = t.curves[e];
                        this.curves.push((new Sl[i.type]).fromJSON(i))
                    }
                    return this
                }
            }), Pl.prototype = Object.assign(Object.create(Al.prototype), {
                constructor: Pl,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
                },
                moveTo: function(t, e) {
                    this.currentPoint.set(t, e)
                },
                lineTo: function(t, e) {
                    var n = new bl(this.currentPoint.clone(), new Ae(t, e));
                    this.curves.push(n), this.currentPoint.set(t, e)
                },
                quadraticCurveTo: function(t, e, n, i) {
                    var r = new Ml(this.currentPoint.clone(), new Ae(t, e), new Ae(n, i));
                    this.curves.push(r), this.currentPoint.set(n, i)
                },
                bezierCurveTo: function(t, e, n, i, r, o) {
                    var a = new _l(this.currentPoint.clone(), new Ae(t, e), new Ae(n, i), new Ae(r, o));
                    this.curves.push(a), this.currentPoint.set(r, o)
                },
                splineThru: function(t) {
                    var e = [this.currentPoint.clone()].concat(t),
                        n = new El(e);
                    this.curves.push(n), this.currentPoint.copy(t[t.length - 1])
                },
                arc: function(t, e, n, i, r, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(t + a, e + s, n, i, r, o)
                },
                absarc: function(t, e, n, i, r, o) {
                    this.absellipse(t, e, n, n, i, r, o)
                },
                ellipse: function(t, e, n, i, r, o, a, s) {
                    var c = this.currentPoint.x,
                        l = this.currentPoint.y;
                    this.absellipse(t + c, e + l, n, i, r, o, a, s)
                },
                absellipse: function(t, e, n, i, r, o, a, s) {
                    var c = new cl(t, e, n, i, r, o, a, s);
                    if (this.curves.length > 0) {
                        var l = c.getPoint(0);
                        l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
                    }
                    this.curves.push(c);
                    var h = c.getPoint(1);
                    this.currentPoint.copy(h)
                },
                copy: function(t) {
                    return Al.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    var t = Al.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return Al.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), Ll.prototype = Object.assign(Object.create(Pl.prototype), {
                constructor: Ll,
                getPointsHoles: function(t) {
                    for (var e = [], n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    Pl.prototype.copy.call(this, t), this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var i = t.holes[e];
                        this.holes.push(i.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var t = Pl.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (var e = 0, n = this.holes.length; e < n; e++) {
                        var i = this.holes[e];
                        t.holes.push(i.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    Pl.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var i = t.holes[e];
                        this.holes.push((new Pl).fromJSON(i))
                    }
                    return this
                }
            }), Rl.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: Rl,
                isLight: !0,
                copy: function(t) {
                    return dn.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = dn.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), Cl.prototype = Object.assign(Object.create(Rl.prototype), {
                constructor: Cl,
                isHemisphereLight: !0,
                copy: function(t) {
                    return Rl.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(Ol.prototype, {
                _projScreenMatrix: new Ye,
                _lightPositionWorld: new Ce,
                _lookTarget: new Ce,
                getViewportCount: function() {
                    return this._viewportCount
                },
                getFrustum: function() {
                    return this._frustum
                },
                updateMatrices: function(t) {
                    var e = this.camera,
                        n = this.matrix,
                        i = this._projScreenMatrix,
                        r = this._lookTarget,
                        o = this._lightPositionWorld;
                    o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                },
                getViewport: function(t) {
                    return this._viewports[t]
                },
                getFrameExtents: function() {
                    return this._frameExtents
                },
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), Il.prototype = Object.assign(Object.create(Ol.prototype), {
                constructor: Il,
                isSpotLightShadow: !0,
                updateMatrices: function(t, e, n) {
                    var i = this.camera,
                        r = 2 * Se.RAD2DEG * t.angle,
                        o = this.mapSize.width / this.mapSize.height,
                        a = t.distance || i.far;
                    r === i.fov && o === i.aspect && a === i.far || (i.fov = r, i.aspect = o, i.far = a, i.updateProjectionMatrix()), Ol.prototype.updateMatrices.call(this, t, e, n)
                }
            }), Dl.prototype = Object.assign(Object.create(Rl.prototype), {
                constructor: Dl,
                isSpotLight: !0,
                copy: function(t) {
                    return Rl.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Nl.prototype = Object.assign(Object.create(Ol.prototype), {
                constructor: Nl,
                isPointLightShadow: !0,
                updateMatrices: function(t, e, n) {
                    var i = this.camera,
                        r = this.matrix,
                        o = this._lightPositionWorld,
                        a = this._lookTarget,
                        s = this._projScreenMatrix;
                    o.setFromMatrixPosition(t.matrixWorld), i.position.copy(o), a.copy(i.position), a.add(this._cubeDirections[n]), i.up.copy(this._cubeUps[n]), i.lookAt(a), i.updateMatrixWorld(), r.makeTranslation(-o.x, -o.y, -o.z), s.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromMatrix(s)
                }
            }), Bl.prototype = Object.assign(Object.create(Rl.prototype), {
                constructor: Bl,
                isPointLight: !0,
                copy: function(t) {
                    return Rl.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), Hl.prototype = Object.assign(Object.create(ar.prototype), {
                constructor: Hl,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return ar.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, n, i, r, o) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2,
                        r = n - t,
                        o = n + t,
                        a = i + e,
                        s = i - e;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            l = this.zoom / (this.view.height / this.view.fullHeight),
                            h = (this.right - this.left) / this.view.width,
                            u = (this.top - this.bottom) / this.view.height;
                        r += h * (this.view.offsetX / c), o = r + h * (this.view.width / c), a -= u * (this.view.offsetY / l), s = a - u * (this.view.height / l)
                    }
                    this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = dn.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), Fl.prototype = Object.assign(Object.create(Ol.prototype), {
                constructor: Fl,
                isDirectionalLightShadow: !0,
                updateMatrices: function(t, e, n) {
                    Ol.prototype.updateMatrices.call(this, t, e, n)
                }
            }), kl.prototype = Object.assign(Object.create(Rl.prototype), {
                constructor: kl,
                isDirectionalLight: !0,
                copy: function(t) {
                    return Rl.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Ul.prototype = Object.assign(Object.create(Rl.prototype), {
                constructor: Ul,
                isAmbientLight: !0
            }), zl.prototype = Object.assign(Object.create(Rl.prototype), {
                constructor: zl,
                isRectAreaLight: !0,
                copy: function(t) {
                    return Rl.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    var e = Rl.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            }), Gl.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: Gl,
                load: function(t, e, n, i) {
                    var r = this,
                        o = new tl(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, n, i)
                },
                parse: function(t) {
                    var e = this.textures;

                    function n(t) {
                        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                    }
                    var i = new Ic[t.type];
                    if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new $n).setHex(t.sheen)), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.vertexColors && (i.vertexColors = t.vertexColors), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.uniforms)
                        for (var r in t.uniforms) {
                            var o = t.uniforms[r];
                            switch (i.uniforms[r] = {}, o.type) {
                                case "t":
                                    i.uniforms[r].value = n(o.value);
                                    break;
                                case "c":
                                    i.uniforms[r].value = (new $n).setHex(o.value);
                                    break;
                                case "v2":
                                    i.uniforms[r].value = (new Ae).fromArray(o.value);
                                    break;
                                case "v3":
                                    i.uniforms[r].value = (new Ce).fromArray(o.value);
                                    break;
                                case "v4":
                                    i.uniforms[r].value = (new Fe).fromArray(o.value);
                                    break;
                                case "m3":
                                    i.uniforms[r].value = (new De).fromArray(o.value);
                                case "m4":
                                    i.uniforms[r].value = (new Ye).fromArray(o.value);
                                    break;
                                default:
                                    i.uniforms[r].value = o.value
                            }
                        }
                    if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                        for (var a in t.extensions) i.extensions[a] = t.extensions[a];
                    if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap), i.transparent = !0), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                        var s = t.normalScale;
                        !1 === Array.isArray(s) && (s = [s, s]), i.normalScale = (new Ae).fromArray(s)
                    }
                    return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Ae).fromArray(t.clearcoatNormalScale)), i
                },
                setTextures: function(t) {
                    return this.textures = t, this
                }
            });
            var jl = {
                decodeText: function(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    for (var e = "", n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                    try {
                        return decodeURIComponent(escape(e))
                    } catch (t) {
                        return e
                    }
                },
                extractUrlBase: function(t) {
                    var e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            };

            function Vl() {
                Si.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function Wl(t, e, n, i) {
                "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), si.call(this, t, e, n), this.meshPerAttribute = i || 1
            }

            function Xl(t) {
                Qc.call(this, t)
            }
            Vl.prototype = Object.assign(Object.create(Si.prototype), {
                constructor: Vl,
                isInstancedBufferGeometry: !0,
                copy: function(t) {
                    return Si.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = Si.prototype.toJSON.call(this);
                    return t.maxInstancedCount = this.maxInstancedCount, t.isInstancedBufferGeometry = !0, t
                }
            }), Wl.prototype = Object.assign(Object.create(si.prototype), {
                constructor: Wl,
                isInstancedBufferAttribute: !0,
                copy: function(t) {
                    return si.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                toJSON: function() {
                    var t = si.prototype.toJSON.call(this);
                    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                }
            }), Xl.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: Xl,
                load: function(t, e, n, i) {
                    var r = this,
                        o = new tl(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, n, i)
                },
                parse: function(t) {
                    var e = t.isInstancedBufferGeometry ? new Vl : new Si,
                        n = t.data.index;
                    if (void 0 !== n) {
                        var i = new ql[n.type](n.array);
                        e.setIndex(new si(i, 1))
                    }
                    var r = t.data.attributes;
                    for (var o in r) {
                        var a = r[o],
                            i = new ql[a.type](a.array),
                            s = a.isInstancedBufferAttribute ? Wl : si,
                            c = new s(i, a.itemSize, a.normalized);
                        void 0 !== a.name && (c.name = a.name), e.addAttribute(o, c)
                    }
                    var l = t.data.morphAttributes;
                    if (l)
                        for (var o in l) {
                            for (var h = l[o], u = [], p = 0, d = h.length; p < d; p++) {
                                var a = h[p],
                                    i = new ql[a.type](a.array),
                                    c = new si(i, a.itemSize, a.normalized);
                                void 0 !== a.name && (c.name = a.name), u.push(c)
                            }
                            e.morphAttributes[o] = u
                        }
                    var f = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== f)
                        for (var p = 0, m = f.length; p !== m; ++p) {
                            var v = f[p];
                            e.addGroup(v.start, v.count, v.materialIndex)
                        }
                    var g = t.data.boundingSphere;
                    if (void 0 !== g) {
                        var y = new Ce;
                        void 0 !== g.center && y.fromArray(g.center), e.boundingSphere = new Rn(y, g.radius)
                    }
                    return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
                }
            });
            var ql = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function Yl(t) {
                Qc.call(this, t)
            }
            Yl.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: Yl,
                load: function(t, e, n, i) {
                    var r = this,
                        o = "" === this.path ? jl.extractUrlBase(t) : this.path;
                    this.resourcePath = this.resourcePath || o;
                    var a = new tl(r.manager);
                    a.setPath(this.path), a.load(t, function(n) {
                        var o = null;
                        try {
                            o = JSON.parse(n)
                        } catch (e) {
                            return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                        }
                        var a = o.metadata;
                        void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                    }, n, i)
                },
                parse: function(t, e) {
                    var n = this.parseShape(t.shapes),
                        i = this.parseGeometries(t.geometries, n),
                        r = this.parseImages(t.images, function() {
                            void 0 !== e && e(s)
                        }),
                        o = this.parseTextures(t.textures, r),
                        a = this.parseMaterials(t.materials, o),
                        s = this.parseObject(t.object, i, a);
                    return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
                },
                parseShape: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var n = 0, i = t.length; n < i; n++) {
                            var r = (new Ll).fromJSON(t[n]);
                            e[r.uuid] = r
                        }
                    return e
                },
                parseGeometries: function(t, e) {
                    var n = {};
                    if (void 0 !== t)
                        for (var i = new Xl, r = 0, o = t.length; r < o; r++) {
                            var a, s = t[r];
                            switch (s.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    a = new wc[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    a = new wc[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    a = new wc[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    a = new wc[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    a = new wc[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    a = new wc[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    a = new wc[s.type](s.radius, s.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    a = new wc[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    a = new wc[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    a = new wc[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    a = new wc[s.type]((new Sl[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    a = new wc[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    a = new wc[s.type](s.vertices, s.indices, s.radius, s.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var c = [], l = 0, h = s.shapes.length; l < h; l++) {
                                        var u = e[s.shapes[l]];
                                        c.push(u)
                                    }
                                    a = new wc[s.type](c, s.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (var c = [], l = 0, h = s.shapes.length; l < h; l++) {
                                        var u = e[s.shapes[l]];
                                        c.push(u)
                                    }
                                    var p = s.options.extrudePath;
                                    void 0 !== p && (s.options.extrudePath = (new Sl[p.type]).fromJSON(p)), a = new wc[s.type](c, s.options);
                                    break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    a = i.parse(s);
                                    break;
                                case "Geometry":
                                    if ("THREE" in window && "LegacyJSONLoader" in THREE) {
                                        var d = new THREE.LegacyJSONLoader;
                                        a = d.parse(s, this.resourcePath).geometry
                                    } else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                    continue
                            }
                            a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), n[s.uuid] = a
                        }
                    return n
                },
                parseMaterials: function(t, e) {
                    var n = {},
                        i = {};
                    if (void 0 !== t) {
                        var r = new Gl;
                        r.setTextures(e);
                        for (var o = 0, a = t.length; o < a; o++) {
                            var s = t[o];
                            if ("MultiMaterial" === s.type) {
                                for (var c = [], l = 0; l < s.materials.length; l++) {
                                    var h = s.materials[l];
                                    void 0 === n[h.uuid] && (n[h.uuid] = r.parse(h)), c.push(n[h.uuid])
                                }
                                i[s.uuid] = c
                            } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), i[s.uuid] = n[s.uuid]
                        }
                    }
                    return i
                },
                parseAnimations: function(t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                        var i = t[n],
                            r = qc.parse(i);
                        void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    var n = this,
                        i = {};

                    function r(t) {
                        return n.manager.itemStart(t), a.load(t, function() {
                            n.manager.itemEnd(t)
                        }, void 0, function() {
                            n.manager.itemError(t), n.manager.itemEnd(t)
                        })
                    }
                    if (void 0 !== t && t.length > 0) {
                        var o = new Jc(e),
                            a = new rl(o);
                        a.setCrossOrigin(this.crossOrigin);
                        for (var s = 0, c = t.length; s < c; s++) {
                            var l = t[s],
                                h = l.url;
                            if (Array.isArray(h)) {
                                i[l.uuid] = [];
                                for (var u = 0, p = h.length; u < p; u++) {
                                    var d = h[u],
                                        f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
                                    i[l.uuid].push(r(f))
                                }
                            } else {
                                var f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.resourcePath + l.url;
                                i[l.uuid] = r(f)
                            }
                        }
                    }
                    return i
                },
                parseTextures: function(t, e) {
                    function n(t, e) {
                        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                    }
                    var i = {};
                    if (void 0 !== t)
                        for (var r = 0, o = t.length; r < o; r++) {
                            var a, s = t[r];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(e[s.image]) ? new Pr(e[s.image]) : new He(e[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, Jl)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], Kl), a.wrapT = n(s.wrap[1], Kl)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, Ql)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, Ql)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), i[s.uuid] = a
                        }
                    return i
                },
                parseObject: function(t, e, n) {
                    var i;

                    function r(t) {
                        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                    }

                    function o(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], i = 0, r = t.length; i < r; i++) {
                                    var o = t[i];
                                    void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(n[o])
                                }
                                return e
                            }
                            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                        }
                    }
                    switch (t.type) {
                        case "Scene":
                            i = new fn, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new $n(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new ma(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new fa(t.fog.color, t.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            i = new sr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            i = new Hl(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                            break;
                        case "AmbientLight":
                            i = new Ul(t.color, t.intensity);
                            break;
                        case "DirectionalLight":
                            i = new kl(t.color, t.intensity);
                            break;
                        case "PointLight":
                            i = new Bl(t.color, t.intensity, t.distance, t.decay);
                            break;
                        case "RectAreaLight":
                            i = new zl(t.color, t.intensity, t.width, t.height);
                            break;
                        case "SpotLight":
                            i = new Dl(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                            break;
                        case "HemisphereLight":
                            i = new Cl(t.color, t.groundColor, t.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var a = r(t.geometry),
                                s = o(t.material);
                            i = a.bones && a.bones.length > 0 ? new Ba(a, s) : new Vi(a, s), void 0 !== t.drawMode && i.setDrawMode(t.drawMode);
                            break;
                        case "LOD":
                            i = new Na;
                            break;
                        case "Line":
                            i = new Ya(r(t.geometry), o(t.material), t.mode);
                            break;
                        case "LineLoop":
                            i = new Qa(r(t.geometry), o(t.material));
                            break;
                        case "LineSegments":
                            i = new Ka(r(t.geometry), o(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            i = new rs(r(t.geometry), o(t.material));
                            break;
                        case "Sprite":
                            i = new Ca(o(t.material));
                            break;
                        case "Group":
                            i = new oa;
                            break;
                        default:
                            i = new dn
                    }
                    if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children)
                        for (var c = t.children, l = 0; l < c.length; l++) i.add(this.parseObject(c[l], e, n));
                    if ("LOD" === t.type)
                        for (var h = t.levels, u = 0; u < h.length; u++) {
                            var p = h[u],
                                d = i.getObjectByProperty("uuid", p.object);
                            void 0 !== d && i.addLevel(d, p.distance)
                        }
                    return i
                }
            });
            var Zl, Jl = {
                    UVMapping: 300,
                    CubeReflectionMapping: Q,
                    CubeRefractionMapping: $,
                    EquirectangularReflectionMapping: tt,
                    EquirectangularRefractionMapping: et,
                    SphericalReflectionMapping: nt,
                    CubeUVReflectionMapping: it,
                    CubeUVRefractionMapping: rt
                },
                Kl = {
                    RepeatWrapping: ot,
                    ClampToEdgeWrapping: at,
                    MirroredRepeatWrapping: st
                },
                Ql = {
                    NearestFilter: ct,
                    NearestMipmapNearestFilter: lt,
                    NearestMipmapLinearFilter: ht,
                    LinearFilter: ut,
                    LinearMipmapNearestFilter: pt,
                    LinearMipmapLinearFilter: dt
                };

            function $l(t) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Qc.call(this, t), this.options = void 0
            }

            function th() {
                this.type = "ShapePath", this.color = new $n, this.subPaths = [], this.currentPath = null
            }

            function eh(t) {
                this.type = "Font", this.data = t
            }

            function nh(t, e, n, i, r) {
                var o = r.glyphs[t] || r.glyphs["?"];
                if (o) {
                    var a, s, c, l, h, u, p, d, f = new th;
                    if (o.o)
                        for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g;) {
                            var y = m[v++];
                            switch (y) {
                                case "m":
                                    a = m[v++] * e + n, s = m[v++] * e + i, f.moveTo(a, s);
                                    break;
                                case "l":
                                    a = m[v++] * e + n, s = m[v++] * e + i, f.lineTo(a, s);
                                    break;
                                case "q":
                                    c = m[v++] * e + n, l = m[v++] * e + i, h = m[v++] * e + n, u = m[v++] * e + i, f.quadraticCurveTo(h, u, c, l);
                                    break;
                                case "b":
                                    c = m[v++] * e + n, l = m[v++] * e + i, h = m[v++] * e + n, u = m[v++] * e + i, p = m[v++] * e + n, d = m[v++] * e + i, f.bezierCurveTo(h, u, p, d, c, l)
                            }
                        }
                    return {
                        offsetX: o.ha * e,
                        path: f
                    }
                }
                console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".")
            }

            function ih(t) {
                Qc.call(this, t)
            }
            $l.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: $l,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Zc.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    fetch(t).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return void 0 === r.options ? createImageBitmap(t) : createImageBitmap(t, r.options)
                    }).then(function(n) {
                        Zc.add(t, n), e && e(n), r.manager.itemEnd(t)
                    }).catch(function(e) {
                        i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }), r.manager.itemStart(t)
                }
            }), Object.assign(th.prototype, {
                moveTo: function(t, e) {
                    this.currentPath = new Pl, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
                },
                lineTo: function(t, e) {
                    this.currentPath.lineTo(t, e)
                },
                quadraticCurveTo: function(t, e, n, i) {
                    this.currentPath.quadraticCurveTo(t, e, n, i)
                },
                bezierCurveTo: function(t, e, n, i, r, o) {
                    this.currentPath.bezierCurveTo(t, e, n, i, r, o)
                },
                splineThru: function(t) {
                    this.currentPath.splineThru(t)
                },
                toShapes: function(t, e) {
                    function n(t) {
                        for (var e = [], n = 0, i = t.length; n < i; n++) {
                            var r = t[n],
                                o = new Ll;
                            o.curves = r.curves, e.push(o)
                        }
                        return e
                    }

                    function i(t, e) {
                        for (var n = e.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
                            var a = e[r],
                                s = e[o],
                                c = s.x - a.x,
                                l = s.y - a.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (a = e[o], c = -c, s = e[r], l = -l), t.y < a.y || t.y > s.y) continue;
                                if (t.y === a.y) {
                                    if (t.x === a.x) return !0
                                } else {
                                    var h = l * (t.x - a.x) - c * (t.y - a.y);
                                    if (0 === h) return !0;
                                    if (h < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (t.y !== a.y) continue;
                                if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                            }
                        }
                        return i
                    }
                    var r = Ks.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === e) return n(o);
                    var a, s, c, l = [];
                    if (1 === o.length) return s = o[0], (c = new Ll).curves = s.curves, l.push(c), l;
                    var h = !r(o[0].getPoints());
                    h = t ? !h : h;
                    var u, p, d = [],
                        f = [],
                        m = [],
                        v = 0;
                    f[v] = void 0, m[v] = [];
                    for (var g = 0, y = o.length; g < y; g++) s = o[g], u = s.getPoints(), a = r(u), (a = t ? !a : a) ? (!h && f[v] && v++, f[v] = {
                        s: new Ll,
                        p: u
                    }, f[v].s.curves = s.curves, h && v++, m[v] = []) : m[v].push({
                        h: s,
                        p: u[0]
                    });
                    if (!f[0]) return n(o);
                    if (f.length > 1) {
                        for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) d[b] = [];
                        for (var b = 0, w = f.length; b < w; b++)
                            for (var M = m[b], T = 0; T < M.length; T++) {
                                for (var E = M[T], S = !0, A = 0; A < f.length; A++) i(E.p, f[A].p) && (b !== A && x.push({
                                    froms: b,
                                    tos: A,
                                    hole: T
                                }), S ? (S = !1, d[A].push(E)) : _ = !0);
                                S && d[b].push(E)
                            }
                        x.length > 0 && (_ || (m = d))
                    }
                    for (var g = 0, P = f.length; g < P; g++) {
                        c = f[g].s, l.push(c);
                        for (var L = 0, R = (p = m[g]).length; L < R; L++) c.holes.push(p[L].h)
                    }
                    return l
                }
            }), Object.assign(eh.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    for (var n = [], i = function(t, e, n) {
                            for (var i = Array.from ? Array.from(t) : String(t).split(""), r = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, a = [], s = 0, c = 0, l = 0; l < i.length; l++) {
                                var h = i[l];
                                if ("\n" === h) s = 0, c -= o;
                                else {
                                    var u = nh(h, r, s, c, n);
                                    s += u.offsetX, a.push(u.path)
                                }
                            }
                            return a
                        }(t, e, this.data), r = 0, o = i.length; r < o; r++) Array.prototype.push.apply(n, i[r].toShapes());
                    return n
                }
            }), ih.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: ih,
                load: function(t, e, n, i) {
                    var r = this,
                        o = new tl(this.manager);
                    o.setPath(this.path), o.load(t, function(t) {
                        var n;
                        try {
                            n = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var i = r.parse(n);
                        e && e(i)
                    }, n, i)
                },
                parse: function(t) {
                    return new eh(t)
                }
            });
            var rh = {
                getContext: function() {
                    return void 0 === Zl && (Zl = new(window.AudioContext || window.webkitAudioContext)), Zl
                },
                setContext: function(t) {
                    Zl = t
                }
            };

            function oh(t) {
                Qc.call(this, t)
            }

            function ah() {
                this.coefficients = [];
                for (var t = 0; t < 9; t++) this.coefficients.push(new Ce)
            }

            function sh(t, e) {
                Rl.call(this, void 0, e), this.sh = void 0 !== t ? t : new ah
            }

            function ch(t, e, n) {
                sh.call(this, void 0, n);
                var i = (new $n).set(t),
                    r = (new $n).set(e),
                    o = new Ce(i.r, i.g, i.b),
                    a = new Ce(r.r, r.g, r.b),
                    s = Math.sqrt(Math.PI),
                    c = s * Math.sqrt(.75);
                this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
            }

            function lh(t, e) {
                sh.call(this, void 0, e);
                var n = (new $n).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
            oh.prototype = Object.assign(Object.create(Qc.prototype), {
                constructor: oh,
                load: function(t, e, n, i) {
                    var r = new tl(this.manager);
                    r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function(t) {
                        var n = t.slice(0),
                            i = rh.getContext();
                        i.decodeAudioData(n, function(t) {
                            e(t)
                        })
                    }, n, i)
                }
            }), Object.assign(ah.prototype, {
                isSphericalHarmonics3: !0,
                set: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this
                },
                zero: function() {
                    for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this
                },
                getAt: function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        o = this.coefficients;
                    return e.copy(o[0]).multiplyScalar(.282095), e.addScale(o[1], .488603 * i), e.addScale(o[2], .488603 * r), e.addScale(o[3], .488603 * n), e.addScale(o[4], n * i * 1.092548), e.addScale(o[5], i * r * 1.092548), e.addScale(o[6], .315392 * (3 * r * r - 1)), e.addScale(o[7], n * r * 1.092548), e.addScale(o[8], .546274 * (n * n - i * i)), e
                },
                getIrradianceAt: function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        o = this.coefficients;
                    return e.copy(o[0]).multiplyScalar(.886227), e.addScale(o[1], 1.023328 * i), e.addScale(o[2], 1.023328 * r), e.addScale(o[3], 1.023328 * n), e.addScale(o[4], .858086 * n * i), e.addScale(o[5], .858086 * i * r), e.addScale(o[6], .743125 * r * r - .247708), e.addScale(o[7], .858086 * n * r), e.addScale(o[8], .429043 * (n * n - i * i)), e
                },
                add: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this
                },
                scale: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this
                },
                lerp: function(t, e) {
                    for (var n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                    return this
                },
                equals: function(t) {
                    for (var e = 0; e < 9; e++)
                        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0
                },
                copy: function(t) {
                    return this.set(t.coefficients)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = this.coefficients, i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    for (var n = this.coefficients, i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
                    return t
                }
            }), Object.assign(ah, {
                getBasisAt: function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z;
                    e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                }
            }), sh.prototype = Object.assign(Object.create(Rl.prototype), {
                constructor: sh,
                isLightProbe: !0,
                copy: function(t) {
                    return Rl.prototype.copy.call(this, t), this.sh.copy(t.sh), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = Rl.prototype.toJSON.call(this, t);
                    return e
                }
            }), ch.prototype = Object.assign(Object.create(sh.prototype), {
                constructor: ch,
                isHemisphereLightProbe: !0,
                copy: function(t) {
                    return sh.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    var e = sh.prototype.toJSON.call(this, t);
                    return e
                }
            }), lh.prototype = Object.assign(Object.create(sh.prototype), {
                constructor: lh,
                isAmbientLightProbe: !0,
                copy: function(t) {
                    return sh.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    var e = sh.prototype.toJSON.call(this, t);
                    return e
                }
            });
            var hh = new Ye,
                uh = new Ye;

            function ph() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new sr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new sr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }

            function dh(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            Object.assign(ph.prototype, {
                update: function(t) {
                    var e = this._cache,
                        n = e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep;
                    if (n) {
                        e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                        var i, r, o = t.projectionMatrix.clone(),
                            a = e.eyeSep / 2,
                            s = a * e.near / e.focus,
                            c = e.near * Math.tan(Se.DEG2RAD * e.fov * .5) / e.zoom;
                        uh.elements[12] = -a, hh.elements[12] = a, i = -c * e.aspect + s, r = c * e.aspect + s, o.elements[0] = 2 * e.near / (r - i), o.elements[8] = (r + i) / (r - i), this.cameraL.projectionMatrix.copy(o), i = -c * e.aspect - s, r = c * e.aspect - s, o.elements[0] = 2 * e.near / (r - i), o.elements[8] = (r + i) / (r - i), this.cameraR.projectionMatrix.copy(o)
                    }
                    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(uh), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(hh)
                }
            }), Object.assign(dh.prototype, {
                start: function() {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var e = ("undefined" == typeof performance ? Date : performance).now();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            });
            var fh = new Ce,
                mh = new Pe,
                vh = new Ce,
                gh = new Ce;

            function yh() {
                dn.call(this), this.type = "AudioListener", this.context = rh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new dh
            }

            function _h(t) {
                dn.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }
            yh.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: yh,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(t) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                },
                updateMatrixWorld: function(t) {
                    dn.prototype.updateMatrixWorld.call(this, t);
                    var e = this.context.listener,
                        n = this.up;
                    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(fh, mh, vh), gh.set(0, 0, -1).applyQuaternion(mh), e.positionX) {
                        var i = this.context.currentTime + this.timeDelta;
                        e.positionX.linearRampToValueAtTime(fh.x, i), e.positionY.linearRampToValueAtTime(fh.y, i), e.positionZ.linearRampToValueAtTime(fh.z, i), e.forwardX.linearRampToValueAtTime(gh.x, i), e.forwardY.linearRampToValueAtTime(gh.y, i), e.forwardZ.linearRampToValueAtTime(gh.z, i), e.upX.linearRampToValueAtTime(n.x, i), e.upY.linearRampToValueAtTime(n.y, i), e.upZ.linearRampToValueAtTime(n.z, i)
                    } else e.setPosition(fh.x, fh.y, fh.z), e.setOrientation(gh.x, gh.y, gh.z, n.x, n.y, n.z)
                }
            }), _h.prototype = Object.assign(Object.create(dn.prototype), {
                constructor: _h,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                },
                setMediaElementSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                },
                setMediaStreamSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                },
                setBuffer: function(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function() {
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            var t = this.context.createBufferSource();
                            return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(t) {
                    return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                },
                setDetune: function(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                },
                getDetune: function() {
                    return this.detune
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(t) {
                    return this.setFilters(t ? [t] : [])
                },
                setPlaybackRate: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            });
            var xh = new Ce,
                bh = new Pe,
                wh = new Ce,
                Mh = new Ce;

            function Th(t) {
                _h.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
            }

            function Eh(t, e) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }

            function Sh(t, e, n) {
                this.binding = t, this.valueSize = n;
                var i, r = Float64Array;
                switch (e) {
                    case "quaternion":
                        i = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array, i = this._select;
                        break;
                    default:
                        i = this._lerp
                }
                this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
            Th.prototype = Object.assign(Object.create(_h.prototype), {
                constructor: Th,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(t) {
                    return this.panner.refDistance = t, this
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(t) {
                    return this.panner.rolloffFactor = t, this
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(t) {
                    return this.panner.distanceModel = t, this
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(t) {
                    return this.panner.maxDistance = t, this
                },
                setDirectionalCone: function(t, e, n) {
                    return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
                },
                updateMatrixWorld: function(t) {
                    if (dn.prototype.updateMatrixWorld.call(this, t), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                        this.matrixWorld.decompose(xh, bh, wh), Mh.set(0, 0, 1).applyQuaternion(bh);
                        var e = this.panner;
                        if (e.positionX) {
                            var n = this.context.currentTime + this.listener.timeDelta;
                            e.positionX.linearRampToValueAtTime(xh.x, n), e.positionY.linearRampToValueAtTime(xh.y, n), e.positionZ.linearRampToValueAtTime(xh.z, n), e.orientationX.linearRampToValueAtTime(Mh.x, n), e.orientationY.linearRampToValueAtTime(Mh.y, n), e.orientationZ.linearRampToValueAtTime(Mh.z, n)
                        } else e.setPosition(xh.x, xh.y, xh.z), e.setOrientation(Mh.x, Mh.y, Mh.z)
                    }
                }
            }), Object.assign(Eh.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function() {
                    for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n];
                    return t / e.length
                }
            }), Object.assign(Sh.prototype, {
                accumulate: function(t, e) {
                    var n = this.buffer,
                        i = this.valueSize,
                        r = t * i + i,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== i; ++a) n[r + a] = n[a];
                        o = e
                    } else {
                        var s = e / (o += e);
                        this._mixBufferRegion(n, r, 0, s, i)
                    }
                    this.cumulativeWeight = o
                },
                apply: function(t) {
                    var e = this.valueSize,
                        n = this.buffer,
                        i = t * e + e,
                        r = this.cumulativeWeight,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, r < 1) {
                        var a = 3 * e;
                        this._mixBufferRegion(n, i, a, 1 - r, e)
                    }
                    for (var s = e, c = e + e; s !== c; ++s)
                        if (n[s] !== n[s + e]) {
                            o.setValue(n, i);
                            break
                        }
                },
                saveOriginalState: function() {
                    var t = this.binding,
                        e = this.buffer,
                        n = this.valueSize,
                        i = 3 * n;
                    t.getValue(e, i);
                    for (var r = n, o = i; r !== o; ++r) e[r] = e[i + r % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _select: function(t, e, n, i, r) {
                    if (i >= .5)
                        for (var o = 0; o !== r; ++o) t[e + o] = t[n + o]
                },
                _slerp: function(t, e, n, i) {
                    Pe.slerpFlat(t, e, t, e, t, n, i)
                },
                _lerp: function(t, e, n, i, r) {
                    for (var o = 1 - i, a = 0; a !== r; ++a) {
                        var s = e + a;
                        t[s] = t[s] * o + t[n + a] * i
                    }
                }
            });
            var Ah = new RegExp("[\\[\\]\\.:\\/]", "g"),
                Ph = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                Lh = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                Rh = /(WCOD+)?/.source.replace("WCOD", Ph),
                Ch = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                Oh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                Ih = new RegExp("^" + Lh + Rh + Ch + Oh + "$"),
                Dh = ["material", "materials", "bones"];

            function Nh(t, e, n) {
                var i = n || Bh.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }

            function Bh(t, e, n) {
                this.path = e, this.parsedPath = n || Bh.parseTrackName(e), this.node = Bh.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }

            function Hh() {
                this.uuid = Se.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var t = {};
                this._indicesByUUID = t;
                for (var e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var i = this;
                this.stats = {
                    objects: {
                        get total() {
                            return i._objects.length
                        },
                        get inUse() {
                            return this.total - i.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return i._bindings.length
                    }
                }
            }

            function Fh(t, e, n) {
                this._mixer = t, this._clip = e, this._localRoot = n || null;
                for (var i = e.tracks, r = i.length, o = new Array(r), a = {
                        endingStart: oe,
                        endingEnd: oe
                    }, s = 0; s !== r; ++s) {
                    var c = i[s].createInterpolant(null);
                    o[s] = c, c.settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = re, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function kh(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function Uh(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }

            function zh(t, e, n) {
                va.call(this, t, e), this.meshPerAttribute = n || 1
            }

            function Gh(t, e, n, i) {
                this.ray = new Fn(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function jh(t, e) {
                return t.distance - e.distance
            }

            function Vh(t, e, n, i) {
                if (!1 !== t.visible && (t.raycast(e, n), !0 === i))
                    for (var r = t.children, o = 0, a = r.length; o < a; o++) Vh(r[o], e, n, !0)
            }

            function Wh(t, e, n) {
                return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
            }

            function Xh(t, e, n) {
                return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
            }
            Object.assign(Nh.prototype, {
                    getValue: function(t, e) {
                        this.bind();
                        var n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
                    },
                    bind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                    },
                    unbind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                    }
                }), Object.assign(Bh, {
                    Composite: Nh,
                    create: function(t, e, n) {
                        return t && t.isAnimationObjectGroup ? new Bh.Composite(t, e, n) : new Bh(t, e, n)
                    },
                    sanitizeNodeName: function(t) {
                        return t.replace(/\s/g, "_").replace(Ah, "")
                    },
                    parseTrackName: function(t) {
                        var e = Ih.exec(t);
                        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        var n = {
                                nodeName: e[2],
                                objectName: e[3],
                                objectIndex: e[4],
                                propertyName: e[5],
                                propertyIndex: e[6]
                            },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && -1 !== i) {
                            var r = n.nodeName.substring(i + 1); - 1 !== Dh.indexOf(r) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    },
                    findNode: function(t, e) {
                        if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) {
                            var n = t.skeleton.getBoneByName(e);
                            if (void 0 !== n) return n
                        }
                        if (t.children) {
                            var i = function(t) {
                                    for (var n = 0; n < t.length; n++) {
                                        var r = t[n];
                                        if (r.name === e || r.uuid === e) return r;
                                        var o = i(r.children);
                                        if (o) return o
                                    }
                                    return null
                                },
                                r = i(t.children);
                            if (r) return r
                        }
                        return null
                    }
                }), Object.assign(Bh.prototype, {
                    _getValue_unavailable: function() {},
                    _setValue_unavailable: function() {},
                    BindingType: {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    },
                    Versioning: {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    },
                    GetterByBindingType: [function(t, e) {
                        t[e] = this.node[this.propertyName]
                    }, function(t, e) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
                    }, function(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }, function(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }],
                    SetterByBindingTypeAndVersioning: [
                        [function(t, e) {
                            this.targetObject[this.propertyName] = t[e]
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                        }, function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                            this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e]
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty.fromArray(t, e)
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                        }]
                    ],
                    getValue: function(t, e) {
                        this.bind(), this.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        this.bind(), this.setValue(t, e)
                    },
                    bind: function() {
                        var t = this.node,
                            e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName,
                            r = e.propertyIndex;
                        if (t || (t = Bh.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                            if (n) {
                                var o = e.objectIndex;
                                switch (n) {
                                    case "materials":
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        t = t.material.materials;
                                        break;
                                    case "bones":
                                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        t = t.skeleton.bones;
                                        for (var a = 0; a < t.length; a++)
                                            if (t[a].name === o) {
                                                o = a;
                                                break
                                            }
                                        break;
                                    default:
                                        if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        t = t[n]
                                }
                                if (void 0 !== o) {
                                    if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    t = t[o]
                                }
                            }
                            var s = t[i];
                            if (void 0 !== s) {
                                var c = this.Versioning.None;
                                this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                                var l = this.BindingType.Direct;
                                if (void 0 !== r) {
                                    if ("morphTargetInfluences" === i) {
                                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                        if (t.geometry.isBufferGeometry) {
                                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                            for (var a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                                if (t.geometry.morphAttributes.position[a].name === r) {
                                                    r = a;
                                                    break
                                                }
                                        } else {
                                            if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                            for (var a = 0; a < this.node.geometry.morphTargets.length; a++)
                                                if (t.geometry.morphTargets[a].name === r) {
                                                    r = a;
                                                    break
                                                }
                                        }
                                    }
                                    l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                                this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                            } else {
                                var h = e.nodeName;
                                console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + i + " but it wasn't found.", t)
                            }
                        } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                    },
                    unbind: function() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(Bh.prototype, {
                    _getValue_unbound: Bh.prototype.getValue,
                    _setValue_unbound: Bh.prototype.setValue
                }), Object.assign(Hh.prototype, {
                    isAnimationObjectGroup: !0,
                    add: function() {
                        for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, l = 0, h = arguments.length; l !== h; ++l) {
                            var u = arguments[l],
                                p = u.uuid,
                                d = i[p];
                            if (void 0 === d) {
                                d = e++, i[p] = d, t.push(u);
                                for (var f = 0, m = s; f !== m; ++f) a[f].push(new Bh(u, r[f], o[f]))
                            } else if (d < n) {
                                c = t[d];
                                var v = --n,
                                    g = t[v];
                                i[g.uuid] = d, t[d] = g, i[p] = v, t[v] = u;
                                for (var f = 0, m = s; f !== m; ++f) {
                                    var y = a[f],
                                        _ = y[v],
                                        x = y[d];
                                    y[d] = _, void 0 === x && (x = new Bh(u, r[f], o[f])), y[v] = x
                                }
                            } else t[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = n
                    },
                    remove: function() {
                        for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, o = 0, a = arguments.length; o !== a; ++o) {
                            var s = arguments[o],
                                c = s.uuid,
                                l = n[c];
                            if (void 0 !== l && l >= e) {
                                var h = e++,
                                    u = t[h];
                                n[u.uuid] = l, t[l] = u, n[c] = h, t[h] = s;
                                for (var p = 0, d = r; p !== d; ++p) {
                                    var f = i[p],
                                        m = f[h],
                                        v = f[l];
                                    f[l] = m, f[h] = v
                                }
                            }
                        }
                        this.nCachedObjects_ = e
                    },
                    uncache: function() {
                        for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                            var c = arguments[a],
                                l = c.uuid,
                                h = i[l];
                            if (void 0 !== h)
                                if (delete i[l], h < n) {
                                    var u = --n,
                                        p = t[u],
                                        d = --e,
                                        f = t[d];
                                    i[p.uuid] = h, t[h] = p, i[f.uuid] = u, t[u] = f, t.pop();
                                    for (var m = 0, v = o; m !== v; ++m) {
                                        var g = r[m],
                                            y = g[u],
                                            _ = g[d];
                                        g[h] = y, g[u] = _, g.pop()
                                    }
                                } else {
                                    var d = --e,
                                        f = t[d];
                                    i[f.uuid] = h, t[h] = f, t.pop();
                                    for (var m = 0, v = o; m !== v; ++m) {
                                        var g = r[m];
                                        g[h] = g[d], g.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = n
                    },
                    subscribe_: function(t, e) {
                        var n = this._bindingsIndicesByPath,
                            i = n[t],
                            r = this._bindings;
                        if (void 0 !== i) return r[i];
                        var o = this._paths,
                            a = this._parsedPaths,
                            s = this._objects,
                            c = s.length,
                            l = this.nCachedObjects_,
                            h = new Array(c);
                        i = r.length, n[t] = i, o.push(t), a.push(e), r.push(h);
                        for (var u = l, p = s.length; u !== p; ++u) {
                            var d = s[u];
                            h[u] = new Bh(d, t, e)
                        }
                        return h
                    },
                    unsubscribe_: function(t) {
                        var e = this._bindingsIndicesByPath,
                            n = e[t];
                        if (void 0 !== n) {
                            var i = this._paths,
                                r = this._parsedPaths,
                                o = this._bindings,
                                a = o.length - 1,
                                s = o[a],
                                c = t[a];
                            e[c] = n, o[n] = s, o.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop()
                        }
                    }
                }), Object.assign(Fh.prototype, {
                    play: function() {
                        return this._mixer._activateAction(this), this
                    },
                    stop: function() {
                        return this._mixer._deactivateAction(this), this.reset()
                    },
                    reset: function() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    },
                    isRunning: function() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    },
                    isScheduled: function() {
                        return this._mixer._isActiveAction(this)
                    },
                    startAt: function(t) {
                        return this._startTime = t, this
                    },
                    setLoop: function(t, e) {
                        return this.loop = t, this.repetitions = e, this
                    },
                    setEffectiveWeight: function(t) {
                        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                    },
                    getEffectiveWeight: function() {
                        return this._effectiveWeight
                    },
                    fadeIn: function(t) {
                        return this._scheduleFading(t, 0, 1)
                    },
                    fadeOut: function(t) {
                        return this._scheduleFading(t, 1, 0)
                    },
                    crossFadeFrom: function(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            var i = this._clip.duration,
                                r = t._clip.duration,
                                o = r / i,
                                a = i / r;
                            t.warp(1, o, e), this.warp(a, 1, e)
                        }
                        return this
                    },
                    crossFadeTo: function(t, e, n) {
                        return t.crossFadeFrom(this, e, n)
                    },
                    stopFading: function() {
                        var t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    setEffectiveTimeScale: function(t) {
                        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                    },
                    getEffectiveTimeScale: function() {
                        return this._effectiveTimeScale
                    },
                    setDuration: function(t) {
                        return this.timeScale = this._clip.duration / t, this.stopWarping()
                    },
                    syncWith: function(t) {
                        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                    },
                    halt: function(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    },
                    warp: function(t, e, n) {
                        var i = this._mixer,
                            r = i.time,
                            o = this._timeScaleInterpolant,
                            a = this.timeScale;
                        null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        var s = o.parameterPositions,
                            c = o.sampleValues;
                        return s[0] = r, s[1] = r + n, c[0] = t / a, c[1] = e / a, this
                    },
                    stopWarping: function() {
                        var t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    getMixer: function() {
                        return this._mixer
                    },
                    getClip: function() {
                        return this._clip
                    },
                    getRoot: function() {
                        return this._localRoot || this._mixer._root
                    },
                    _update: function(t, e, n, i) {
                        if (this.enabled) {
                            var r = this._startTime;
                            if (null !== r) {
                                var o = (t - r) * n;
                                if (o < 0 || 0 === n) return;
                                this._startTime = null, e = n * o
                            }
                            e *= this._updateTimeScale(t);
                            var a = this._updateTime(e),
                                s = this._updateWeight(t);
                            if (s > 0)
                                for (var c = this._interpolants, l = this._propertyBindings, h = 0, u = c.length; h !== u; ++h) c[h].evaluate(a), l[h].accumulate(i, s)
                        } else this._updateWeight(t)
                    },
                    _updateWeight: function(t) {
                        var e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            var n = this._weightInterpolant;
                            if (null !== n) {
                                var i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    },
                    _updateTimeScale: function(t) {
                        var e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            var n = this._timeScaleInterpolant;
                            if (null !== n) {
                                var i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                            }
                        }
                        return this._effectiveTimeScale = e, e
                    },
                    _updateTime: function(t) {
                        var e = this.time + t,
                            n = this._clip.duration,
                            i = this.loop,
                            r = this._loopCount,
                            o = 2202 === i;
                        if (0 === t) return -1 === r ? e : o && 1 == (1 & r) ? n - e : e;
                        if (2200 === i) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (e >= n) e = n;
                                else {
                                    if (!(e < 0)) {
                                        this.time = e;
                                        break t
                                    }
                                    e = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = e,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= n || e < 0) {
                                var a = Math.floor(e / n);
                                e -= n * a, r += Math.abs(a);
                                var s = this.repetitions - r;
                                if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this.time = e, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === s) {
                                        var c = t < 0;
                                        this._setEndings(c, !c, o)
                                    } else this._setEndings(!1, !1, o);
                                    this._loopCount = r, this.time = e, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: a
                                    })
                                }
                            } else this.time = e;
                            if (o && 1 == (1 & r)) return n - e
                        }
                        return e
                    },
                    _setEndings: function(t, e, n) {
                        var i = this._interpolantSettings;
                        n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : oe : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : oe : 2402)
                    },
                    _scheduleFading: function(t, e, n) {
                        var i = this._mixer,
                            r = i.time,
                            o = this._weightInterpolant;
                        null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
                        var a = o.parameterPositions,
                            s = o.sampleValues;
                        return a[0] = r, s[0] = e, a[1] = r + t, s[1] = n, this
                    }
                }), kh.prototype = Object.assign(Object.create(Me.prototype), {
                    constructor: kh,
                    _bindAction: function(t, e) {
                        var n = t._localRoot || this._root,
                            i = t._clip.tracks,
                            r = i.length,
                            o = t._propertyBindings,
                            a = t._interpolants,
                            s = n.uuid,
                            c = this._bindingsByRootAndName,
                            l = c[s];
                        void 0 === l && (l = {}, c[s] = l);
                        for (var h = 0; h !== r; ++h) {
                            var u = i[h],
                                p = u.name,
                                d = l[p];
                            if (void 0 !== d) o[h] = d;
                            else {
                                if (void 0 !== (d = o[h])) {
                                    null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p));
                                    continue
                                }
                                var f = e && e._propertyBindings[h].binding.parsedPath;
                                ++(d = new Sh(Bh.create(n, p, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), o[h] = d
                            }
                            a[h].resultBuffer = d.buffer
                        }
                    },
                    _activateAction: function(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                var e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    i = this._actionsByClip[n];
                                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            for (var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                                var s = r[o];
                                0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    },
                    _deactivateAction: function(t) {
                        if (this._isActiveAction(t)) {
                            for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                                var r = e[n];
                                0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                            }
                            this._takeBackAction(t)
                        }
                    },
                    _initMemoryManager: function() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        var t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    },
                    _isActiveAction: function(t) {
                        var e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    },
                    _addInactiveAction: function(t, e, n) {
                        var i = this._actions,
                            r = this._actionsByClip,
                            o = r[e];
                        if (void 0 === o) o = {
                            knownActions: [t],
                            actionByRoot: {}
                        }, t._byClipCacheIndex = 0, r[e] = o;
                        else {
                            var a = o.knownActions;
                            t._byClipCacheIndex = a.length, a.push(t)
                        }
                        t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t
                    },
                    _removeInactiveAction: function(t) {
                        var e = this._actions,
                            n = e[e.length - 1],
                            i = t._cacheIndex;
                        n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                        var r = t._clip.uuid,
                            o = this._actionsByClip,
                            a = o[r],
                            s = a.knownActions,
                            c = s[s.length - 1],
                            l = t._byClipCacheIndex;
                        c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null;
                        var h = a.actionByRoot,
                            u = (t._localRoot || this._root).uuid;
                        delete h[u], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(t)
                    },
                    _removeInactiveBindingsForAction: function(t) {
                        for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                            var r = e[n];
                            0 == --r.referenceCount && this._removeInactiveBinding(r)
                        }
                    },
                    _lendAction: function(t) {
                        var e = this._actions,
                            n = t._cacheIndex,
                            i = this._nActiveActions++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _takeBackAction: function(t) {
                        var e = this._actions,
                            n = t._cacheIndex,
                            i = --this._nActiveActions,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _addInactiveBinding: function(t, e, n) {
                        var i = this._bindingsByRootAndName,
                            r = i[e],
                            o = this._bindings;
                        void 0 === r && (r = {}, i[e] = r), r[n] = t, t._cacheIndex = o.length, o.push(t)
                    },
                    _removeInactiveBinding: function(t) {
                        var e = this._bindings,
                            n = t.binding,
                            i = n.rootNode.uuid,
                            r = n.path,
                            o = this._bindingsByRootAndName,
                            a = o[i],
                            s = e[e.length - 1],
                            c = t._cacheIndex;
                        s._cacheIndex = c, e[c] = s, e.pop(), delete a[r], 0 === Object.keys(a).length && delete o[i]
                    },
                    _lendBinding: function(t) {
                        var e = this._bindings,
                            n = t._cacheIndex,
                            i = this._nActiveBindings++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _takeBackBinding: function(t) {
                        var e = this._bindings,
                            n = t._cacheIndex,
                            i = --this._nActiveBindings,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _lendControlInterpolant: function() {
                        var t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++,
                            n = t[e];
                        return void 0 === n && ((n = new Hc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n
                    },
                    _takeBackControlInterpolant: function(t) {
                        var e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            i = --this._nActiveControlInterpolants,
                            r = e[i];
                        t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(1),
                    clipAction: function(t, e) {
                        var n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? qc.findByName(n, t) : t,
                            o = null !== r ? r.uuid : t,
                            a = this._actionsByClip[o],
                            s = null;
                        if (void 0 !== a) {
                            var c = a.actionByRoot[i];
                            if (void 0 !== c) return c;
                            s = a.knownActions[0], null === r && (r = s._clip)
                        }
                        if (null === r) return null;
                        var l = new Fh(this, r, e);
                        return this._bindAction(l, s), this._addInactiveAction(l, o, i), l
                    },
                    existingAction: function(t, e) {
                        var n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? qc.findByName(n, t) : t,
                            o = r ? r.uuid : t,
                            a = this._actionsByClip[o];
                        return void 0 !== a && a.actionByRoot[i] || null
                    },
                    stopAllAction: function() {
                        var t = this._actions,
                            e = this._nActiveActions,
                            n = this._bindings,
                            i = this._nActiveBindings;
                        this._nActiveActions = 0, this._nActiveBindings = 0;
                        for (var r = 0; r !== e; ++r) t[r].reset();
                        for (var r = 0; r !== i; ++r) n[r].useCount = 0;
                        return this
                    },
                    update: function(t) {
                        t *= this.timeScale;
                        for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                            var s = e[a];
                            s._update(i, t, r, o)
                        }
                        for (var c = this._bindings, l = this._nActiveBindings, a = 0; a !== l; ++a) c[a].apply(o);
                        return this
                    },
                    setTime: function(t) {
                        this.time = 0;
                        for (var e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                        return this.update(t)
                    },
                    getRoot: function() {
                        return this._root
                    },
                    uncacheClip: function(t) {
                        var e = this._actions,
                            n = t.uuid,
                            i = this._actionsByClip,
                            r = i[n];
                        if (void 0 !== r) {
                            for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                                var c = o[a];
                                this._deactivateAction(c);
                                var l = c._cacheIndex,
                                    h = e[e.length - 1];
                                c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = l, e[l] = h, e.pop(), this._removeInactiveBindingsForAction(c)
                            }
                            delete i[n]
                        }
                    },
                    uncacheRoot: function(t) {
                        var e = t.uuid,
                            n = this._actionsByClip;
                        for (var i in n) {
                            var r = n[i].actionByRoot,
                                o = r[e];
                            void 0 !== o && (this._deactivateAction(o), this._removeInactiveAction(o))
                        }
                        var a = this._bindingsByRootAndName,
                            s = a[e];
                        if (void 0 !== s)
                            for (var c in s) {
                                var l = s[c];
                                l.restoreOriginalState(), this._removeInactiveBinding(l)
                            }
                    },
                    uncacheAction: function(t, e) {
                        var n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }), Uh.prototype.clone = function() {
                    return new Uh(void 0 === this.value.clone ? this.value : this.value.clone())
                }, zh.prototype = Object.assign(Object.create(va.prototype), {
                    constructor: zh,
                    isInstancedInterleavedBuffer: !0,
                    copy: function(t) {
                        return va.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), Object.assign(Gh.prototype, {
                    linePrecision: 1,
                    set: function(t, e) {
                        this.ray.set(t, e)
                    },
                    setFromCamera: function(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function(t, e, n) {
                        var i = n || [];
                        return Vh(t, this, i, e), i.sort(jh), i
                    },
                    intersectObjects: function(t, e, n) {
                        var i = n || [];
                        if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                        for (var r = 0, o = t.length; r < o; r++) Vh(t[r], this, i, e);
                        return i.sort(jh), i
                    }
                }), Object.assign(Wh.prototype, {
                    set: function(t, e, n) {
                        return this.radius = t, this.phi = e, this.theta = n, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                    },
                    makeSafe: function() {
                        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, n) {
                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Se.clamp(e / this.radius, -1, 1))), this
                    }
                }), Object.assign(Xh.prototype, {
                    set: function(t, e, n) {
                        return this.radius = t, this.theta = e, this.y = n, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, n) {
                        return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
                    }
                });
            var qh = new Ae;

            function Yh(t, e) {
                this.min = void 0 !== t ? t : new Ae(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ae(-1 / 0, -1 / 0)
            }
            Object.assign(Yh.prototype, {
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function(t, e) {
                    var n = qh.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Ae), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Ae), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                },
                getParameter: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Ae), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                },
                clampPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Ae), e.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function(t) {
                    var e = qh.copy(t).clamp(this.min, this.max);
                    return e.sub(t).length()
                },
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            });
            var Zh = new Ce,
                Jh = new Ce;

            function Kh(t, e) {
                this.start = void 0 !== t ? t : new Ce, this.end = void 0 !== e ? e : new Ce
            }

            function Qh(t) {
                dn.call(this), this.material = t, this.render = function() {}
            }
            Object.assign(Kh.prototype, {
                set: function(t, e) {
                    return this.start.copy(t), this.end.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.start.copy(t.start), this.end.copy(t.end), this
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new Ce), t.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(t) {
                    return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new Ce), t.subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new Ce), this.delta(e).multiplyScalar(t).add(this.start)
                },
                closestPointToPointParameter: function(t, e) {
                    Zh.subVectors(t, this.start), Jh.subVectors(this.end, this.start);
                    var n = Jh.dot(Jh),
                        i = Jh.dot(Zh),
                        r = i / n;
                    return e && (r = Se.clamp(r, 0, 1)), r
                },
                closestPointToPoint: function(t, e, n) {
                    var i = this.closestPointToPointParameter(t, e);
                    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Ce), this.delta(n).multiplyScalar(i).add(this.start)
                },
                applyMatrix4: function(t) {
                    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                },
                equals: function(t) {
                    return t.start.equals(this.start) && t.end.equals(this.end)
                }
            }), Qh.prototype = Object.create(dn.prototype), Qh.prototype.constructor = Qh, Qh.prototype.isImmediateRenderObject = !0;
            var $h = new Ce,
                tu = new Ce,
                eu = new De,
                nu = ["a", "b", "c"];

            function iu(t, e, n, i) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== n ? n : 16711680,
                    o = void 0 !== i ? i : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
                var c = new Si,
                    l = new mi(2 * a * 3, 3);
                c.addAttribute("position", l), Ka.call(this, c, new Ga({
                    color: r,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }
            iu.prototype = Object.create(Ka.prototype), iu.prototype.constructor = iu, iu.prototype.update = function() {
                this.object.updateMatrixWorld(!0), eu.getNormalMatrix(this.object.matrixWorld);
                var t = this.object.matrixWorld,
                    e = this.geometry.attributes.position,
                    n = this.object.geometry;
                if (n && n.isGeometry)
                    for (var i = n.vertices, r = n.faces, o = 0, a = 0, s = r.length; a < s; a++)
                        for (var c = r[a], l = 0, h = c.vertexNormals.length; l < h; l++) {
                            var u = i[c[nu[l]]],
                                p = c.vertexNormals[l];
                            $h.copy(u).applyMatrix4(t), tu.copy(p).applyMatrix3(eu).normalize().multiplyScalar(this.size).add($h), e.setXYZ(o, $h.x, $h.y, $h.z), o += 1, e.setXYZ(o, tu.x, tu.y, tu.z), o += 1
                        } else if (n && n.isBufferGeometry)
                            for (var d = n.attributes.position, f = n.attributes.normal, o = 0, l = 0, h = d.count; l < h; l++) $h.set(d.getX(l), d.getY(l), d.getZ(l)).applyMatrix4(t), tu.set(f.getX(l), f.getY(l), f.getZ(l)), tu.applyMatrix3(eu).normalize().multiplyScalar(this.size).add($h), e.setXYZ(o, $h.x, $h.y, $h.z), o += 1, e.setXYZ(o, tu.x, tu.y, tu.z), o += 1;
                e.needsUpdate = !0
            };
            var ru = new Ce;

            function ou(t, e) {
                dn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var n = new Si, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
                    var a = r / 32 * Math.PI * 2,
                        s = o / 32 * Math.PI * 2;
                    i.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                n.addAttribute("position", new mi(i, 3));
                var c = new Ga({
                    fog: !1
                });
                this.cone = new Ka(n, c), this.add(this.cone), this.update()
            }
            ou.prototype = Object.create(dn.prototype), ou.prototype.constructor = ou, ou.prototype.dispose = function() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, ou.prototype.update = function() {
                this.light.updateMatrixWorld();
                var t = this.light.distance ? this.light.distance : 1e3,
                    e = t * Math.tan(this.light.angle);
                this.cone.scale.set(e, e, t), ru.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(ru), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            };
            var au = new Ce,
                su = new Ye,
                cu = new Ye;

            function lu(t) {
                for (var e = function t(e) {
                        var n = [];
                        e && e.isBone && n.push(e);
                        for (var i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                        return n
                    }(t), n = new Si, i = [], r = [], o = new $n(0, 0, 1), a = new $n(0, 1, 0), s = 0; s < e.length; s++) {
                    var c = e[s];
                    c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
                }
                n.addAttribute("position", new mi(i, 3)), n.addAttribute("color", new mi(r, 3));
                var l = new Ga({
                    vertexColors: p,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                Ka.call(this, n, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }

            function hu(t, e, n) {
                this.light = t, this.light.updateMatrixWorld(), this.color = n;
                var i = new sc(e, 4, 2),
                    r = new ai({
                        wireframe: !0,
                        fog: !1
                    });
                Vi.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function uu(t, e) {
                this.type = "RectAreaLightHelper", this.light = t, this.color = e;
                var n = new Si;
                n.addAttribute("position", new mi([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), n.computeBoundingSphere();
                var i = new Ga({
                    fog: !1
                });
                Ya.call(this, n, i);
                var r = new Si;
                r.addAttribute("position", new mi([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), r.computeBoundingSphere(), this.add(new Vi(r, new ai({
                    side: c,
                    fog: !1
                }))), this.update()
            }
            lu.prototype = Object.create(Ka.prototype), lu.prototype.constructor = lu, lu.prototype.updateMatrixWorld = function(t) {
                var e = this.bones,
                    n = this.geometry,
                    i = n.getAttribute("position");
                cu.getInverse(this.root.matrixWorld);
                for (var r = 0, o = 0; r < e.length; r++) {
                    var a = e[r];
                    a.parent && a.parent.isBone && (su.multiplyMatrices(cu, a.matrixWorld), au.setFromMatrixPosition(su), i.setXYZ(o, au.x, au.y, au.z), su.multiplyMatrices(cu, a.parent.matrixWorld), au.setFromMatrixPosition(su), i.setXYZ(o + 1, au.x, au.y, au.z), o += 2)
                }
                n.getAttribute("position").needsUpdate = !0, dn.prototype.updateMatrixWorld.call(this, t)
            }, hu.prototype = Object.create(Vi.prototype), hu.prototype.constructor = hu, hu.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, hu.prototype.update = function() {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }, uu.prototype = Object.create(Ya.prototype), uu.prototype.constructor = uu, uu.prototype.update = function() {
                if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
                else {
                    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                    var t = this.material.color,
                        e = Math.max(t.r, t.g, t.b);
                    e > 1 && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color)
                }
            }, uu.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
            };
            var pu = new Ce,
                du = new $n,
                fu = new $n;

            function mu(t, e, n) {
                dn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var i = new ys(e);
                i.rotateY(.5 * Math.PI), this.material = new ai({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = p);
                var r = i.getAttribute("position"),
                    o = new Float32Array(3 * r.count);
                i.addAttribute("color", new si(o, 3)), this.add(new Vi(i, this.material)), this.update()
            }

            function vu(t, e) {
                this.lightProbe = t, this.size = e;
                var n = {
                        GAMMA_OUTPUT: ""
                    },
                    i = new or({
                        defines: n,
                        uniforms: {
                            sh: {
                                value: this.lightProbe.sh.coefficients
                            },
                            intensity: {
                                value: this.lightProbe.intensity
                            }
                        },
                        vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                        fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n")
                    }),
                    r = new sc(1, 32, 16);
                Vi.call(this, r, i), this.onBeforeRender()
            }

            function gu(t, e, n, i) {
                t = t || 10, e = e || 10, n = new $n(void 0 !== n ? n : 4473924), i = new $n(void 0 !== i ? i : 8947848);
                for (var r = e / 2, o = t / e, a = t / 2, s = [], c = [], l = 0, h = 0, u = -a; l <= e; l++, u += o) {
                    s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
                    var d = l === r ? n : i;
                    d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3
                }
                var f = new Si;
                f.addAttribute("position", new mi(s, 3)), f.addAttribute("color", new mi(c, 3));
                var m = new Ga({
                    vertexColors: p
                });
                Ka.call(this, f, m)
            }

            function yu(t, e, n, i, r, o) {
                t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new $n(void 0 !== r ? r : 4473924), o = new $n(void 0 !== o ? o : 8947848);
                var a, s, c, l, h, u, d, f = [],
                    m = [];
                for (l = 0; l <= e; l++) c = l / e * (2 * Math.PI), a = Math.sin(c) * t, s = Math.cos(c) * t, f.push(0, 0, 0), f.push(a, 0, s), d = 1 & l ? r : o, m.push(d.r, d.g, d.b), m.push(d.r, d.g, d.b);
                for (l = 0; l <= n; l++)
                    for (d = 1 & l ? r : o, u = t - t / n * l, h = 0; h < i; h++) c = h / i * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, f.push(a, 0, s), m.push(d.r, d.g, d.b), c = (h + 1) / i * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, f.push(a, 0, s), m.push(d.r, d.g, d.b);
                var v = new Si;
                v.addAttribute("position", new mi(f, 3)), v.addAttribute("color", new mi(m, 3));
                var g = new Ga({
                    vertexColors: p
                });
                Ka.call(this, v, g)
            }

            function _u(t, e, n, i) {
                this.audio = t, this.range = e || 1, this.divisionsInnerAngle = n || 16, this.divisionsOuterAngle = i || 2;
                var r = new Si,
                    o = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
                    a = new Float32Array(3 * (3 * o + 3));
                r.addAttribute("position", new si(a, 3));
                var s = new Ga({
                        color: 65280
                    }),
                    c = new Ga({
                        color: 16776960
                    });
                Ya.call(this, r, [c, s]), this.update()
            }
            mu.prototype = Object.create(dn.prototype), mu.prototype.constructor = mu, mu.prototype.dispose = function() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, mu.prototype.update = function() {
                var t = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var e = t.geometry.getAttribute("color");
                    du.copy(this.light.color), fu.copy(this.light.groundColor);
                    for (var n = 0, i = e.count; n < i; n++) {
                        var r = n < i / 2 ? du : fu;
                        e.setXYZ(n, r.r, r.g, r.b)
                    }
                    e.needsUpdate = !0
                }
                t.lookAt(pu.setFromMatrixPosition(this.light.matrixWorld).negate())
            }, vu.prototype = Object.create(Vi.prototype), vu.prototype.constructor = vu, vu.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, vu.prototype.onBeforeRender = function() {
                this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
            }, gu.prototype = Object.assign(Object.create(Ka.prototype), {
                constructor: gu,
                copy: function(t) {
                    return Ka.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), yu.prototype = Object.create(Ka.prototype), yu.prototype.constructor = yu, _u.prototype = Object.create(Ya.prototype), _u.prototype.constructor = _u, _u.prototype.update = function() {
                var t, e, n = this.audio,
                    i = this.range,
                    r = this.divisionsInnerAngle,
                    o = this.divisionsOuterAngle,
                    a = Se.degToRad(n.panner.coneInnerAngle),
                    s = Se.degToRad(n.panner.coneOuterAngle),
                    c = a / 2,
                    l = s / 2,
                    h = 0,
                    u = 0,
                    p = this.geometry,
                    d = p.attributes.position;

                function f(n, r, o, a) {
                    var s = (r - n) / o;
                    for (d.setXYZ(h, 0, 0, 0), u++, t = n; t < r; t += s) e = h + u, d.setXYZ(e, Math.sin(t) * i, 0, Math.cos(t) * i), d.setXYZ(e + 1, Math.sin(Math.min(t + s, r)) * i, 0, Math.cos(Math.min(t + s, r)) * i), d.setXYZ(e + 2, 0, 0, 0), u += 3;
                    p.addGroup(h, u, a), h += u, u = 0
                }
                p.clearGroups(), f(-l, -c, o, 0), f(-c, c, r, 1), f(c, l, o, 0), d.needsUpdate = !0, a === s && (this.material[0].visible = !1)
            }, _u.prototype.dispose = function() {
                this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
            };
            var xu = new Ce,
                bu = new Ce,
                wu = new De;

            function Mu(t, e, n, i) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== n ? n : 16776960,
                    o = void 0 !== i ? i : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new Si,
                    l = new mi(2 * a * 3, 3);
                c.addAttribute("position", l), Ka.call(this, c, new Ga({
                    color: r,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }
            Mu.prototype = Object.create(Ka.prototype), Mu.prototype.constructor = Mu, Mu.prototype.update = function() {
                this.object.updateMatrixWorld(!0), wu.getNormalMatrix(this.object.matrixWorld);
                for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, n = this.object.geometry, i = n.vertices, r = n.faces, o = 0, a = 0, s = r.length; a < s; a++) {
                    var c = r[a],
                        l = c.normal;
                    xu.copy(i[c.a]).add(i[c.b]).add(i[c.c]).divideScalar(3).applyMatrix4(t), bu.copy(l).applyMatrix3(wu).normalize().multiplyScalar(this.size).add(xu), e.setXYZ(o, xu.x, xu.y, xu.z), o += 1, e.setXYZ(o, bu.x, bu.y, bu.z), o += 1
                }
                e.needsUpdate = !0
            };
            var Tu = new Ce,
                Eu = new Ce,
                Su = new Ce;

            function Au(t, e, n) {
                dn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                var i = new Si;
                i.addAttribute("position", new mi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                var r = new Ga({
                    fog: !1
                });
                this.lightPlane = new Ya(i, r), this.add(this.lightPlane), (i = new Si).addAttribute("position", new mi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ya(i, r), this.add(this.targetLine), this.update()
            }
            Au.prototype = Object.create(dn.prototype), Au.prototype.constructor = Au, Au.prototype.dispose = function() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, Au.prototype.update = function() {
                Tu.setFromMatrixPosition(this.light.matrixWorld), Eu.setFromMatrixPosition(this.light.target.matrixWorld), Su.subVectors(Eu, Tu), this.lightPlane.lookAt(Eu), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Eu), this.targetLine.scale.z = Su.length()
            };
            var Pu = new Ce,
                Lu = new ar;

            function Ru(t) {
                var e = new Si,
                    n = new Ga({
                        color: 16777215,
                        vertexColors: u
                    }),
                    i = [],
                    r = [],
                    o = {},
                    a = new $n(16755200),
                    s = new $n(16711680),
                    c = new $n(43775),
                    l = new $n(16777215),
                    h = new $n(3355443);

                function p(t, e, n) {
                    d(t, n), d(e, n)
                }

                function d(t, e) {
                    i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(i.length / 3 - 1)
                }
                p("n1", "n2", a), p("n2", "n4", a), p("n4", "n3", a), p("n3", "n1", a), p("f1", "f2", a), p("f2", "f4", a), p("f4", "f3", a), p("f3", "f1", a), p("n1", "f1", a), p("n2", "f2", a), p("n3", "f3", a), p("n4", "f4", a), p("p", "n1", s), p("p", "n2", s), p("p", "n3", s), p("p", "n4", s), p("u1", "u2", c), p("u2", "u3", c), p("u3", "u1", c), p("c", "t", l), p("p", "c", h), p("cn1", "cn2", h), p("cn3", "cn4", h), p("cf1", "cf2", h), p("cf3", "cf4", h), e.addAttribute("position", new mi(i, 3)), e.addAttribute("color", new mi(r, 3)), Ka.call(this, e, n), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }

            function Cu(t, e, n, i, r, o, a) {
                Pu.set(r, o, a).unproject(i);
                var s = e[t];
                if (void 0 !== s)
                    for (var c = n.getAttribute("position"), l = 0, h = s.length; l < h; l++) c.setXYZ(s[l], Pu.x, Pu.y, Pu.z)
            }
            Ru.prototype = Object.create(Ka.prototype), Ru.prototype.constructor = Ru, Ru.prototype.update = function() {
                var t = this.geometry,
                    e = this.pointMap;
                Lu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Cu("c", e, t, Lu, 0, 0, -1), Cu("t", e, t, Lu, 0, 0, 1), Cu("n1", e, t, Lu, -1, -1, -1), Cu("n2", e, t, Lu, 1, -1, -1), Cu("n3", e, t, Lu, -1, 1, -1), Cu("n4", e, t, Lu, 1, 1, -1), Cu("f1", e, t, Lu, -1, -1, 1), Cu("f2", e, t, Lu, 1, -1, 1), Cu("f3", e, t, Lu, -1, 1, 1), Cu("f4", e, t, Lu, 1, 1, 1), Cu("u1", e, t, Lu, .7, 1.1, -1), Cu("u2", e, t, Lu, -.7, 1.1, -1), Cu("u3", e, t, Lu, 0, 2, -1), Cu("cf1", e, t, Lu, -1, 0, 1), Cu("cf2", e, t, Lu, 1, 0, 1), Cu("cf3", e, t, Lu, 0, -1, 1), Cu("cf4", e, t, Lu, 0, 1, 1), Cu("cn1", e, t, Lu, -1, 0, -1), Cu("cn2", e, t, Lu, 1, 0, -1), Cu("cn3", e, t, Lu, 0, -1, -1), Cu("cn4", e, t, Lu, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
            };
            var Ou = new An;

            function Iu(t, e) {
                this.object = t, void 0 === e && (e = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Float32Array(24),
                    r = new Si;
                r.setIndex(new si(n, 1)), r.addAttribute("position", new si(i, 3)), Ka.call(this, r, new Ga({
                    color: e
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Du(t, e) {
                this.type = "Box3Helper", this.box = t, e = e || 16776960;
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Si;
                i.setIndex(new si(n, 1)), i.addAttribute("position", new mi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ka.call(this, i, new Ga({
                    color: e
                })), this.geometry.computeBoundingSphere()
            }

            function Nu(t, e, n) {
                this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                var i = void 0 !== n ? n : 16776960,
                    r = new Si;
                r.addAttribute("position", new mi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), Ya.call(this, r, new Ga({
                    color: i
                }));
                var o = new Si;
                o.addAttribute("position", new mi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Vi(o, new ai({
                    color: i,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }
            Iu.prototype = Object.create(Ka.prototype), Iu.prototype.constructor = Iu, Iu.prototype.update = function(t) {
                if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Ou.setFromObject(this.object), !Ou.isEmpty()) {
                    var e = Ou.min,
                        n = Ou.max,
                        i = this.geometry.attributes.position,
                        r = i.array;
                    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }, Iu.prototype.setFromObject = function(t) {
                return this.object = t, this.update(), this
            }, Iu.prototype.copy = function(t) {
                return Ka.prototype.copy.call(this, t), this.object = t.object, this
            }, Iu.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, Du.prototype = Object.create(Ka.prototype), Du.prototype.constructor = Du, Du.prototype.updateMatrixWorld = function(t) {
                var e = this.box;
                e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), dn.prototype.updateMatrixWorld.call(this, t))
            }, Nu.prototype = Object.create(Ya.prototype), Nu.prototype.constructor = Nu, Nu.prototype.updateMatrixWorld = function(t) {
                var e = -this.plane.constant;
                Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? c : s, this.lookAt(this.plane.normal), dn.prototype.updateMatrixWorld.call(this, t)
            };
            var Bu, Hu, Fu = new Ce;

            function ku(t, e, n, i, r, o) {
                dn.call(this), void 0 === t && (t = new Ce(0, 0, 1)), void 0 === e && (e = new Ce(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === Bu && ((Bu = new Si).addAttribute("position", new mi([0, 0, 0, 0, 1, 0], 3)), (Hu = new gc(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Ya(Bu, new Ga({
                    color: i
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Vi(Hu, new ai({
                    color: i
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o)
            }

            function Uu(t) {
                var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    n = new Si;
                n.addAttribute("position", new mi(e, 3)), n.addAttribute("color", new mi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var i = new Ga({
                    vertexColors: p
                });
                Ka.call(this, n, i)
            }

            function zu(t) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ml.call(this, t), this.type = "catmullrom", this.closed = !0
            }

            function Gu(t) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ml.call(this, t), this.type = "catmullrom"
            }

            function ju(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), ml.call(this, t), this.type = "catmullrom"
            }
            ku.prototype = Object.create(dn.prototype), ku.prototype.constructor = ku, ku.prototype.setDirection = function(t) {
                if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
                else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                else {
                    Fu.set(t.z, 0, -t.x).normalize();
                    var e = Math.acos(t.y);
                    this.quaternion.setFromAxisAngle(Fu, e)
                }
            }, ku.prototype.setLength = function(t, e, n) {
                void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
            }, ku.prototype.setColor = function(t) {
                this.line.material.color.set(t), this.cone.material.color.set(t)
            }, ku.prototype.copy = function(t) {
                return dn.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
            }, ku.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, Uu.prototype = Object.create(Ka.prototype), Uu.prototype.constructor = Uu, sl.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(sl.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Object.assign(Al.prototype, {
                createPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var e = new Ki, n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.vertices.push(new Ce(r.x, r.y, r.z || 0))
                    }
                    return e
                }
            }), Object.assign(Pl.prototype, {
                fromPoints: function(t) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }
            }), zu.prototype = Object.create(ml.prototype), Gu.prototype = Object.create(ml.prototype), ju.prototype = Object.create(ml.prototype), Object.assign(ju.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), gu.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, lu.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(Qc.prototype, {
                extractUrlBase: function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), jl.extractUrlBase(t)
                }
            }), Qc.Handlers = {
                add: function() {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function() {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            }, Object.assign(Yl.prototype, {
                setTexturePath: function(t) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                }
            }), Object.assign(Yh.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign(An.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Kh.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Object.assign(Se, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Se.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Se.ceilPowerOfTwo(t)
                }
            }), Object.assign(De.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(Ye.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                getPosition: function() {
                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Ce).setFromMatrixColumn(this, 3)
                },
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(t, e, n, i, r, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o)
                }
            }), vr.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, Pe.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, Object.assign(Fn.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }
            }), Object.assign(Zn.prototype, {
                area: function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                },
                midpoint: function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                },
                normal: function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                },
                plane: function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }
            }), Object.assign(Zn, {
                barycoordFromPoint: function(t, e, n, i, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Zn.getBarycoord(t, e, n, i, r)
                },
                normal: function(t, e, n, i) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Zn.getNormal(t, e, n, i)
                }
            }), Object.assign(Ll.prototype, {
                extractAllPoints: function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                },
                extrude: function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new tc(this, t)
                },
                makeGeometry: function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new pc(this, t)
                }
            }), Object.assign(Ae.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Ce.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Fe.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Ki.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(dn.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(dn.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(Na.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(ka.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Ba.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(sl.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), sr.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(Rl.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(si.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                }
            }), Object.assign(si.prototype, {
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                },
                setArray: function(t) {
                    return console.warn("THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"), this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
                }
            }), Object.assign(Si.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                },
                addDrawCall: function(t, e, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(Si.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.assign(va.prototype, {
                setArray: function(t) {
                    return console.warn("THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"), this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
                }
            }), Object.assign(ec.prototype, {
                getArrays: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(Uh.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(oi.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new $n
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                    }
                },
                stencilMask: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                    }
                }
            }), Object.defineProperties(Ac.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(or.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), Object.assign(da.prototype, {
                clearTarget: function(t, e, n, i) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
                },
                animate: function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                },
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                },
                allocTextureUnit: function() {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                },
                setTexture: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                },
                setTexture2D: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                },
                setTextureCube: function() {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                },
                getActiveMipMapLevel: function() {
                    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
                }
            }), Object.defineProperties(da.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                }
            }), Object.defineProperties(ta.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(ur.prototype, {
                activeCubeFace: {
                    set: function() {
                        console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
                    }
                },
                activeMipMapLevel: {
                    set: function() {
                        console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
                    }
                }
            }), Object.defineProperties(ke.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(ua.prototype, {
                standing: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                },
                userHeight: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .userHeight has been removed.")
                    }
                }
            }), _h.prototype.load = function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var e = this,
                    n = new oh;
                return n.load(t, function(t) {
                    e.setBuffer(t)
                }), this
            }, Eh.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, hr.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            };
            var Vu = {
                merge: function(t, e, n) {
                    var i;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, n)
                },
                center: function(t) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
                }
            };
            Ne.crossOrigin = void 0, Ne.loadTexture = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new al;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, n, void 0, i);
                return e && (o.mapping = e), o
            }, Ne.loadTextureCube = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new ol;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, n, void 0, i);
                return e && (o.mapping = e), o
            }, Ne.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Ne.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            var Wu = {
                createMultiMaterialObject: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: "109"
                }
            })), t.ACESFilmicToneMapping = K, t.AddEquation = _, t.AddOperation = W, t.AdditiveBlending = m, t.AlphaFormat = St, t.AlwaysDepth = B, t.AlwaysStencilFunc = we, t.AmbientLight = Ul, t.AmbientLightProbe = lh, t.AnimationClip = qc, t.AnimationLoader = el, t.AnimationMixer = kh, t.AnimationObjectGroup = Hh, t.AnimationUtils = Dc, t.ArcCurve = ll, t.ArrayCamera = aa, t.ArrowHelper = ku, t.Audio = _h, t.AudioAnalyser = Eh, t.AudioContext = rh, t.AudioListener = yh, t.AudioLoader = oh, t.AxesHelper = Uu, t.AxisHelper = function(t) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Uu(t)
            }, t.BackSide = c, t.BasicDepthPacking = ge, t.BasicShadowMap = 0, t.BinaryTextureLoader = function(t) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new il(t)
            }, t.Bone = Ua, t.BooleanKeyframeTrack = Uc, t.BoundingBoxHelper = function(t, e) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Iu(t, e)
            }, t.Box2 = Yh, t.Box3 = An, t.Box3Helper = Du, t.BoxBufferGeometry = $i, t.BoxGeometry = Qi, t.BoxHelper = Iu, t.BufferAttribute = si, t.BufferGeometry = Si, t.BufferGeometryLoader = Xl, t.ByteType = mt, t.Cache = Zc, t.Camera = ar, t.CameraHelper = Ru, t.CanvasRenderer = function() {
                console.error("THREE.CanvasRenderer has been removed")
            }, t.CanvasTexture = cs, t.CatmullRomCurve3 = ml, t.CineonToneMapping = J, t.CircleBufferGeometry = bc, t.CircleGeometry = xc, t.ClampToEdgeWrapping = at, t.Clock = dh, t.ClosedSplineCurve3 = zu, t.Color = $n, t.ColorKeyframeTrack = zc, t.CompressedTexture = ss, t.CompressedTextureLoader = nl, t.ConeBufferGeometry = _c, t.ConeGeometry = yc, t.CubeCamera = hr, t.CubeGeometry = Qi, t.CubeReflectionMapping = Q, t.CubeRefractionMapping = $, t.CubeTexture = Pr, t.CubeTextureLoader = ol, t.CubeUVReflectionMapping = it, t.CubeUVRefractionMapping = rt, t.CubicBezierCurve = _l, t.CubicBezierCurve3 = xl, t.CubicInterpolant = Bc, t.CullFaceBack = n, t.CullFaceFront = i, t.CullFaceFrontBack = 3, t.CullFaceNone = e, t.Curve = sl, t.CurvePath = Al, t.CustomBlending = y, t.CylinderBufferGeometry = gc, t.CylinderGeometry = vc, t.Cylindrical = Xh, t.DataTexture = pr, t.DataTexture2DArray = Lr, t.DataTexture3D = Rr, t.DataTextureLoader = il, t.DecrementStencilOp = 7683, t.DecrementWrapStencilOp = 34056, t.DefaultLoadingManager = Kc, t.DepthFormat = Ot, t.DepthStencilFormat = It, t.DepthTexture = ls, t.DirectionalLight = kl, t.DirectionalLightHelper = Au, t.DirectionalLightShadow = Fl, t.DiscreteInterpolant = Fc, t.DodecahedronBufferGeometry = ws, t.DodecahedronGeometry = bs, t.DoubleSide = l, t.DstAlphaFactor = R, t.DstColorFactor = O, t.DynamicBufferAttribute = function(t, e) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new si(t, e).setDynamic(!0)
            }, t.EdgesGeometry = mc, t.EdgesHelper = function(t, e) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ka(new mc(t.geometry), new Ga({
                    color: void 0 !== e ? e : 16777215
                }))
            }, t.EllipseCurve = cl, t.EqualDepth = k, t.EqualStencilFunc = 514, t.EquirectangularReflectionMapping = tt, t.EquirectangularRefractionMapping = et, t.Euler = Ke, t.EventDispatcher = Me, t.ExtrudeBufferGeometry = ec, t.ExtrudeGeometry = tc, t.Face3 = ii, t.Face4 = function(t, e, n, i, r, o, a) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ii(t, e, n, r, o, a)
            }, t.FaceColors = u, t.FaceNormalsHelper = Mu, t.FileLoader = tl, t.FlatShading = 1, t.Float32Attribute = function(t, e) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new mi(t, e)
            }, t.Float32BufferAttribute = mi, t.Float64Attribute = function(t, e) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new vi(t, e)
            }, t.Float64BufferAttribute = vi, t.FloatType = xt, t.Fog = ma, t.FogExp2 = fa, t.Font = eh, t.FontLoader = ih, t.FrontFaceDirectionCCW = 1, t.FrontFaceDirectionCW = 0, t.FrontSide = s, t.Frustum = _r, t.GammaEncoding = ue, t.Geometry = Ki, t.GeometryUtils = Vu, t.GreaterDepth = z, t.GreaterEqualDepth = U, t.GreaterEqualStencilFunc = 518, t.GreaterStencilFunc = 516, t.GridHelper = gu, t.Group = oa, t.HalfFloatType = bt, t.HemisphereLight = Cl, t.HemisphereLightHelper = mu, t.HemisphereLightProbe = ch, t.IcosahedronBufferGeometry = xs, t.IcosahedronGeometry = _s, t.ImageBitmapLoader = $l, t.ImageLoader = rl, t.ImageUtils = Ne, t.ImmediateRenderObject = Qh, t.IncrementStencilOp = 7682, t.IncrementWrapStencilOp = 34055, t.InstancedBufferAttribute = Wl, t.InstancedBufferGeometry = Vl, t.InstancedInterleavedBuffer = zh, t.InstancedMesh = za, t.Int16Attribute = function(t, e) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new ui(t, e)
            }, t.Int16BufferAttribute = ui, t.Int32Attribute = function(t, e) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new di(t, e)
            }, t.Int32BufferAttribute = di, t.Int8Attribute = function(t, e) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new ci(t, e)
            }, t.Int8BufferAttribute = ci, t.IntType = yt, t.InterleavedBuffer = va, t.InterleavedBufferAttribute = ga, t.Interpolant = Nc, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.InvertStencilOp = 5386, t.JSONLoader = function() {
                console.error("THREE.JSONLoader has been removed.")
            }, t.KeepStencilOp = be, t.KeyframeTrack = kc, t.LOD = Na, t.LatheBufferGeometry = uc, t.LatheGeometry = hc, t.Layers = Qe, t.LensFlare = function() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }, t.LessDepth = H, t.LessEqualDepth = F, t.LessEqualStencilFunc = 515, t.LessStencilFunc = 513, t.Light = Rl, t.LightProbe = sh, t.LightProbeHelper = vu, t.LightShadow = Ol, t.Line = Ya, t.Line3 = Kh, t.LineBasicMaterial = Ga, t.LineCurve = bl, t.LineCurve3 = wl, t.LineDashedMaterial = Oc, t.LineLoop = Qa, t.LinePieces = 1, t.LineSegments = Ka, t.LineStrip = 0, t.LinearEncoding = le, t.LinearFilter = ut, t.LinearInterpolant = Hc, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearMipmapLinearFilter = dt, t.LinearMipmapNearestFilter = pt, t.LinearToneMapping = q, t.Loader = Qc, t.LoaderUtils = jl, t.LoadingManager = Jc, t.LogLuvEncoding = de, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = re, t.LuminanceAlphaFormat = Rt, t.LuminanceFormat = Lt, t.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2
            }, t.Material = oi, t.MaterialLoader = Gl, t.Math = Se, t.Matrix3 = De, t.Matrix4 = Ye, t.MaxEquation = M, t.Mesh = Vi, t.MeshBasicMaterial = ai, t.MeshDepthMaterial = Jo, t.MeshDistanceMaterial = Ko, t.MeshFaceMaterial = function(t) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
            }, t.MeshLambertMaterial = Rc, t.MeshMatcapMaterial = Cc, t.MeshNormalMaterial = Lc, t.MeshPhongMaterial = Ac, t.MeshPhysicalMaterial = Sc, t.MeshStandardMaterial = Ec, t.MeshToonMaterial = Pc, t.MinEquation = w, t.MirroredRepeatWrapping = st, t.MixOperation = V, t.MultiMaterial = function(t) {
                return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                    return t.slice()
                }, t
            }, t.MultiplyBlending = g, t.MultiplyOperation = j, t.NearestFilter = ct, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NearestMipmapLinearFilter = ht, t.NearestMipmapNearestFilter = lt, t.NeverDepth = N, t.NeverStencilFunc = 512, t.NoBlending = d, t.NoColors = h, t.NoToneMapping = X, t.NormalBlending = f, t.NotEqualDepth = G, t.NotEqualStencilFunc = 517, t.NumberKeyframeTrack = Gc, t.Object3D = dn, t.ObjectLoader = Yl, t.ObjectSpaceNormalMap = xe, t.OctahedronBufferGeometry = ys, t.OctahedronGeometry = gs, t.OneFactor = E, t.OneMinusDstAlphaFactor = C, t.OneMinusDstColorFactor = I, t.OneMinusSrcAlphaFactor = L, t.OneMinusSrcColorFactor = A, t.OrthographicCamera = Hl, t.PCFShadowMap = r, t.PCFSoftShadowMap = o, t.ParametricBufferGeometry = ps, t.ParametricGeometry = us, t.Particle = function(t) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ca(t)
            }, t.ParticleBasicMaterial = function(t) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new $a(t)
            }, t.ParticleSystem = function(t, e) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new rs(t, e)
            }, t.ParticleSystemMaterial = function(t) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new $a(t)
            }, t.Path = Pl, t.PerspectiveCamera = sr, t.Plane = vr, t.PlaneBufferGeometry = Sr, t.PlaneGeometry = Er, t.PlaneHelper = Nu, t.PointCloud = function(t, e) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new rs(t, e)
            }, t.PointCloudMaterial = function(t) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new $a(t)
            }, t.PointLight = Bl, t.PointLightHelper = hu, t.Points = rs, t.PointsMaterial = $a, t.PolarGridHelper = yu, t.PolyhedronBufferGeometry = fs, t.PolyhedronGeometry = ds, t.PositionalAudio = Th, t.PositionalAudioHelper = _u, t.PropertyBinding = Bh, t.PropertyMixer = Sh, t.QuadraticBezierCurve = Ml, t.QuadraticBezierCurve3 = Tl, t.Quaternion = Pe, t.QuaternionKeyframeTrack = Vc, t.QuaternionLinearInterpolant = jc, t.REVISION = "109", t.RGBADepthPacking = ye, t.RGBAFormat = Pt, t.RGBA_ASTC_10x10_Format = ee, t.RGBA_ASTC_10x5_Format = Qt, t.RGBA_ASTC_10x6_Format = $t, t.RGBA_ASTC_10x8_Format = te, t.RGBA_ASTC_12x10_Format = ne, t.RGBA_ASTC_12x12_Format = ie, t.RGBA_ASTC_4x4_Format = Vt, t.RGBA_ASTC_5x4_Format = Wt, t.RGBA_ASTC_5x5_Format = Xt, t.RGBA_ASTC_6x5_Format = qt, t.RGBA_ASTC_6x6_Format = Yt, t.RGBA_ASTC_8x5_Format = Zt, t.RGBA_ASTC_8x6_Format = Jt, t.RGBA_ASTC_8x8_Format = Kt, t.RGBA_PVRTC_2BPPV1_Format = Gt, t.RGBA_PVRTC_4BPPV1_Format = zt, t.RGBA_S3TC_DXT1_Format = Bt, t.RGBA_S3TC_DXT3_Format = Ht, t.RGBA_S3TC_DXT5_Format = Ft, t.RGBDEncoding = ve, t.RGBEEncoding = pe, t.RGBEFormat = Ct, t.RGBFormat = At, t.RGBM16Encoding = me, t.RGBM7Encoding = fe, t.RGB_ETC1_Format = jt, t.RGB_PVRTC_2BPPV1_Format = Ut, t.RGB_PVRTC_4BPPV1_Format = kt, t.RGB_S3TC_DXT1_Format = Nt, t.RawShaderMaterial = Tc, t.Ray = Fn, t.Raycaster = Gh, t.RectAreaLight = zl, t.RectAreaLightHelper = uu, t.RedFormat = Dt, t.ReinhardToneMapping = Y, t.RepeatWrapping = ot, t.ReplaceStencilOp = 7681, t.ReverseSubtractEquation = b, t.RingBufferGeometry = lc, t.RingGeometry = cc, t.Scene = fn, t.SceneUtils = Wu, t.ShaderChunk = xr, t.ShaderLib = wr, t.ShaderMaterial = or, t.ShadowMaterial = Mc, t.Shape = Ll, t.ShapeBufferGeometry = dc, t.ShapeGeometry = pc, t.ShapePath = th, t.ShapeUtils = Ks, t.ShortType = vt, t.Skeleton = ka, t.SkeletonHelper = lu, t.SkinnedMesh = Ba, t.SmoothShading = 2, t.Sphere = Rn, t.SphereBufferGeometry = sc, t.SphereGeometry = ac, t.Spherical = Wh, t.SphericalHarmonics3 = ah, t.SphericalReflectionMapping = nt, t.Spline = ju, t.SplineCurve = El, t.SplineCurve3 = Gu, t.SpotLight = Dl, t.SpotLightHelper = ou, t.SpotLightShadow = Il, t.Sprite = Ca, t.SpriteMaterial = ya, t.SrcAlphaFactor = P, t.SrcAlphaSaturateFactor = D, t.SrcColorFactor = S, t.StereoCamera = ph, t.StringKeyframeTrack = Wc, t.SubtractEquation = x, t.SubtractiveBlending = v, t.TOUCH = {
                ROTATE: 0,
                PAN: 1,
                DOLLY_PAN: 2,
                DOLLY_ROTATE: 3
            }, t.TangentSpaceNormalMap = _e, t.TetrahedronBufferGeometry = vs, t.TetrahedronGeometry = ms, t.TextBufferGeometry = oc, t.TextGeometry = rc, t.Texture = He, t.TextureLoader = al, t.TorusBufferGeometry = Ps, t.TorusGeometry = As, t.TorusKnotBufferGeometry = Ss, t.TorusKnotGeometry = Es, t.Triangle = Zn, t.TriangleFanDrawMode = ce, t.TriangleStripDrawMode = se, t.TrianglesDrawMode = ae, t.TubeBufferGeometry = Ts, t.TubeGeometry = Ms, t.UVMapping = 300, t.Uint16Attribute = function(t, e) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new pi(t, e)
            }, t.Uint16BufferAttribute = pi, t.Uint32Attribute = function(t, e) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new fi(t, e)
            }, t.Uint32BufferAttribute = fi, t.Uint8Attribute = function(t, e) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new li(t, e)
            }, t.Uint8BufferAttribute = li, t.Uint8ClampedAttribute = function(t, e) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new hi(t, e)
            }, t.Uint8ClampedBufferAttribute = hi, t.Uncharted2ToneMapping = Z, t.Uniform = Uh, t.UniformsLib = br, t.UniformsUtils = nr, t.UnsignedByteType = ft, t.UnsignedInt248Type = Et, t.UnsignedIntType = _t, t.UnsignedShort4444Type = wt, t.UnsignedShort5551Type = Mt, t.UnsignedShort565Type = Tt, t.UnsignedShortType = gt, t.VSMShadowMap = a, t.Vector2 = Ae, t.Vector3 = Ce, t.Vector4 = Fe, t.VectorKeyframeTrack = Xc, t.Vertex = function(t, e, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Ce(t, e, n)
            }, t.VertexColors = p, t.VertexNormalsHelper = iu, t.VideoTexture = as, t.WebGLMultisampleRenderTarget = Ue, t.WebGLRenderTarget = ke, t.WebGLRenderTargetCube = ur, t.WebGLRenderer = da, t.WebGLUtils = na, t.WireframeGeometry = hs, t.WireframeHelper = function(t, e) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ka(new hs(t.geometry), new Ga({
                    color: void 0 !== e ? e : 16777215
                }))
            }, t.WrapAroundEnding = 2402, t.XHRLoader = function(t) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new tl(t)
            }, t.ZeroCurvatureEnding = oe, t.ZeroFactor = T, t.ZeroSlopeEnding = 2401, t.ZeroStencilOp = 0, t.sRGBEncoding = he, Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }(e)
    }, , function(t, e, n) {
        (function(n) {
            var i, r = void 0 !== t && t.exports && void 0 !== n ? n : this || window;
            /*!
             * VERSION: 2.1.3
             * DATE: 2019-05-17
             * UPDATES AND DOCS AT: http://greensock.com
             * 
             * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
             *
             * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
             * This work is subject to the terms at http://greensock.com/standard-license or for
             * Club GreenSock members, the software agreement that was issued with your membership.
             * 
             * @author: Jack Doyle, jack@greensock.com
             **/
            (r._gsQueue || (r._gsQueue = [])).push(function() {
                    "use strict";
                    r._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, n) {
                            var i = function(t) {
                                    var e, n = [],
                                        i = t.length;
                                    for (e = 0; e !== i; n.push(t[e++]));
                                    return n
                                },
                                r = function(t, e, n) {
                                    var i, r, o = t.cycle;
                                    for (i in o) r = o[i], t[i] = "function" == typeof r ? r(n, e[n], e) : r[n % r.length];
                                    delete t.cycle
                                },
                                o = function(t) {
                                    if ("function" == typeof t) return t;
                                    var e = "object" == typeof t ? t : {
                                            each: t
                                        },
                                        n = e.ease,
                                        i = e.from || 0,
                                        r = e.base || 0,
                                        o = {},
                                        a = isNaN(i),
                                        s = e.axis,
                                        c = {
                                            center: .5,
                                            end: 1
                                        }[i] || 0;
                                    return function(t, l, h) {
                                        var u, p, d, f, m, v, g, y, _, x = (h || e).length,
                                            b = o[x];
                                        if (!b) {
                                            if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1 / 0])[0])) {
                                                for (g = -1 / 0; g < (g = h[_++].getBoundingClientRect().left) && _ < x;);
                                                _--
                                            }
                                            for (b = o[x] = [], u = a ? Math.min(_, x) * c - .5 : i % _, p = a ? x * c / _ - .5 : i / _ | 0, g = 0, y = 1 / 0, v = 0; v < x; v++) d = v % _ - u, f = p - (v / _ | 0), b[v] = m = s ? Math.abs("y" === s ? f : d) : Math.sqrt(d * d + f * f), m > g && (g = m), m < y && (y = m);
                                            b.max = g - y, b.min = y, b.v = x = e.amount || e.each * (_ > x ? x - 1 : s ? "y" === s ? x / _ : _ : Math.max(_, x / _)) || 0, b.b = x < 0 ? r - x : r
                                        }
                                        return x = (b[t] - b.min) / b.max, b.b + (n ? n.getRatio(x) : x) * b.v
                                    }
                                },
                                a = function(t, e, i) {
                                    n.call(this, t, e, i), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = a.prototype.render
                                },
                                s = n._internals,
                                c = s.isSelector,
                                l = s.isArray,
                                h = a.prototype = n.to({}, .1, {}),
                                u = [];
                            a.version = "2.1.3", h.constructor = a, h.kill()._gc = !1, a.killTweensOf = a.killDelayedCallsTo = n.killTweensOf, a.getTweensOf = n.getTweensOf, a.lagSmoothing = n.lagSmoothing, a.ticker = n.ticker, a.render = n.render, a.distribute = o, h.invalidate = function() {
                                return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), n.prototype.invalidate.call(this)
                            }, h.updateTo = function(t, e) {
                                var i, r = this.ratio,
                                    o = this.vars.immediateRender || t.immediateRender;
                                for (i in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[i] = t[i];
                                if (this._initted || o)
                                    if (e) this._initted = !1, o && this.render(0, !0, !0);
                                    else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                                    var a = this._totalTime;
                                    this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
                                } else if (this._initted = !1, this._init(), this._time > 0 || o)
                                    for (var s, c = 1 / (1 - r), l = this._firstPT; l;) s = l.s + l.c, l.c *= c, l.s = s - l.c, l = l._next;
                                return this
                            }, h.render = function(t, e, i) {
                                this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                                var r, o, a, c, l, h, u, p, d, f = this._dirty ? this.totalDuration() : this._totalDuration,
                                    m = this._time,
                                    v = this._totalTime,
                                    g = this._cycle,
                                    y = this._duration,
                                    _ = this._rawPrevTime;
                                if (t >= f - 1e-8 && t >= 0 ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, o = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (_ < 0 || t <= 0 && t >= -1e-8 || 1e-8 === _ && "isPause" !== this.data) && _ !== t && (i = !0, _ > 1e-8 && (o = "onReverseComplete")), this._rawPrevTime = p = !e || t || _ === t ? t : 1e-8)) : t < 1e-8 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== v || 0 === y && _ > 0) && (o = "onReverseComplete", r = this._reversed), t > -1e-8 ? t = 0 : t < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || i) && (_ >= 0 && (i = !0), this._rawPrevTime = p = !e || t || _ === t ? t : 1e-8)), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (c = y + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && v <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 != (1 & this._cycle) && (this._time = y - this._time, (d = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== d || this._initted ? this._yoyoEase = d = !0 === d ? this._ease : d instanceof Ease ? d : Ease.map[d] : (d = this.vars.ease, this._yoyoEase = d = d ? d instanceof Ease ? d : "function" == typeof d ? new Ease(d, this.vars.easeParams) : Ease.map[d] || n.defaultEase : n.defaultEase)), this.ratio = d ? 1 - d.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !d ? (l = this._time / y, h = this._easeType, u = this._easePower, (1 === h || 3 === h && l >= .5) && (l = 1 - l), 3 === h && (l *= 2), 1 === u ? l *= l : 2 === u ? l *= l * l : 3 === u ? l *= l * l * l : 4 === u && (l *= l * l * l * l), this.ratio = 1 === h ? 1 - l : 2 === h ? l : this._time / y < .5 ? l / 2 : 1 - l / 2) : d || (this.ratio = this._ease.getRatio(this._time / y))), m !== this._time || i || g !== this._cycle) {
                                    if (!this._initted) {
                                        if (this._init(), !this._initted || this._gc) return;
                                        if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = v, this._rawPrevTime = _, this._cycle = g, s.lazyTweens.push(this), void(this._lazy = [t, e]);
                                        !this._time || r || d ? r && this._ease._calcEnd && !d && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y)
                                    }
                                    for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== m && t >= 0 && (this._active = !0), 0 === v && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : o || (o = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || e || this._callback("onStart"))), a = this._firstPT; a;) a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next;
                                    this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, i), e || (this._totalTime !== v || o) && this._callback("onUpdate")), this._cycle !== g && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), o && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this._callback(o), 0 === y && 1e-8 === this._rawPrevTime && 1e-8 !== p && (this._rawPrevTime = 0)))
                                } else v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
                            }, a.to = function(t, e, n) {
                                return new a(t, e, n)
                            }, a.from = function(t, e, n) {
                                return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new a(t, e, n)
                            }, a.fromTo = function(t, e, n, i) {
                                return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, new a(t, e, i)
                            }, a.staggerTo = a.allTo = function(t, e, s, h, p, d, f) {
                                var m, v, g, y, _ = [],
                                    x = o(s.stagger || h),
                                    b = s.cycle,
                                    w = (s.startAt || u).cycle;
                                for (l(t) || ("string" == typeof t && (t = n.selector(t) || t), c(t) && (t = i(t))), m = (t = t || []).length - 1, g = 0; g <= m; g++) {
                                    for (y in v = {}, s) v[y] = s[y];
                                    if (b && (r(v, t, g), null != v.duration && (e = v.duration, delete v.duration)), w) {
                                        for (y in w = v.startAt = {}, s.startAt) w[y] = s.startAt[y];
                                        r(v.startAt, t, g)
                                    }
                                    v.delay = x(g, t[g], t) + (v.delay || 0), g === m && p && (v.onComplete = function() {
                                        s.onComplete && s.onComplete.apply(s.onCompleteScope || this, arguments), p.apply(f || s.callbackScope || this, d || u)
                                    }), _[g] = new a(t[g], e, v)
                                }
                                return _
                            }, a.staggerFrom = a.allFrom = function(t, e, n, i, r, o, s) {
                                return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, a.staggerTo(t, e, n, i, r, o, s)
                            }, a.staggerFromTo = a.allFromTo = function(t, e, n, i, r, o, s, c) {
                                return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, a.staggerTo(t, e, i, r, o, s, c)
                            }, a.delayedCall = function(t, e, n, i, r) {
                                return new a(e, 0, {
                                    delay: t,
                                    onComplete: e,
                                    onCompleteParams: n,
                                    callbackScope: i,
                                    onReverseComplete: e,
                                    onReverseCompleteParams: n,
                                    immediateRender: !1,
                                    useFrames: r,
                                    overwrite: 0
                                })
                            }, a.set = function(t, e) {
                                return new a(t, 0, e)
                            }, a.isTweening = function(t) {
                                return n.getTweensOf(t, !0).length > 0
                            };
                            var p = function(t, e) {
                                    for (var i = [], r = 0, o = t._first; o;) o instanceof n ? i[r++] = o : (e && (i[r++] = o), r = (i = i.concat(p(o, e))).length), o = o._next;
                                    return i
                                },
                                d = a.getAllTweens = function(e) {
                                    return p(t._rootTimeline, e).concat(p(t._rootFramesTimeline, e))
                                };
                            a.killAll = function(t, n, i, r) {
                                null == n && (n = !0), null == i && (i = !0);
                                var o, a, s, c = d(0 != r),
                                    l = c.length,
                                    h = n && i && r;
                                for (s = 0; s < l; s++) a = c[s], (h || a instanceof e || (o = a.target === a.vars.onComplete) && i || n && !o) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
                            }, a.killChildTweensOf = function(t, e) {
                                if (null != t) {
                                    var r, o, h, u, p, d = s.tweenLookup;
                                    if ("string" == typeof t && (t = n.selector(t) || t), c(t) && (t = i(t)), l(t))
                                        for (u = t.length; --u > -1;) a.killChildTweensOf(t[u], e);
                                    else {
                                        for (h in r = [], d)
                                            for (o = d[h].target.parentNode; o;) o === t && (r = r.concat(d[h].tweens)), o = o.parentNode;
                                        for (p = r.length, u = 0; u < p; u++) e && r[u].totalTime(r[u].totalDuration()), r[u]._enabled(!1, !1)
                                    }
                                }
                            };
                            var f = function(t, n, i, r) {
                                n = !1 !== n, i = !1 !== i;
                                for (var o, a, s = d(r = !1 !== r), c = n && i && r, l = s.length; --l > -1;) a = s[l], (c || a instanceof e || (o = a.target === a.vars.onComplete) && i || n && !o) && a.paused(t)
                            };
                            return a.pauseAll = function(t, e, n) {
                                f(!0, t, e, n)
                            }, a.resumeAll = function(t, e, n) {
                                f(!1, t, e, n)
                            }, a.globalTimeScale = function(e) {
                                var i = t._rootTimeline,
                                    r = n.ticker.time;
                                return arguments.length ? (e = e || 1e-8, i._startTime = r - (r - i._startTime) * i._timeScale / e, i = t._rootFramesTimeline, r = n.ticker.frame, i._startTime = r - (r - i._startTime) * i._timeScale / e, i._timeScale = t._rootTimeline._timeScale = e, e) : i._timeScale
                            }, h.progress = function(t, e) {
                                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this.duration() ? this._time / this._duration : this.ratio
                            }, h.totalProgress = function(t, e) {
                                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                            }, h.time = function(t, e) {
                                if (!arguments.length) return this._time;
                                this._dirty && this.totalDuration();
                                var n = this._duration,
                                    i = this._cycle,
                                    r = i * (n + this._repeatDelay);
                                return t > n && (t = n), this.totalTime(this._yoyo && 1 & i ? n - t + r : this._repeat ? t + r : t, e)
                            }, h.duration = function(e) {
                                return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                            }, h.totalDuration = function(t) {
                                return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                            }, h.repeat = function(t) {
                                return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                            }, h.repeatDelay = function(t) {
                                return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                            }, h.yoyo = function(t) {
                                return arguments.length ? (this._yoyo = t, this) : this._yoyo
                            }, a
                        }, !0), r._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, n) {
                            var i = function(t) {
                                    e.call(this, t);
                                    var n, i, r = this.vars;
                                    for (i in this._labels = {}, this.autoRemoveChildren = !!r.autoRemoveChildren, this.smoothChildTiming = !!r.smoothChildTiming, this._sortChildren = !0, this._onUpdate = r.onUpdate, r) n = r[i], c(n) && -1 !== n.join("").indexOf("{self}") && (r[i] = this._swapSelfInParams(n));
                                    c(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                                },
                                o = n._internals,
                                a = i._internals = {},
                                s = o.isSelector,
                                c = o.isArray,
                                l = o.lazyTweens,
                                h = o.lazyRender,
                                u = r._gsDefine.globals,
                                p = function(t) {
                                    var e, n = {};
                                    for (e in t) n[e] = t[e];
                                    return n
                                },
                                d = function(t, e, n) {
                                    var i, r, o = t.cycle;
                                    for (i in o) r = o[i], t[i] = "function" == typeof r ? r(n, e[n], e) : r[n % r.length];
                                    delete t.cycle
                                },
                                f = a.pauseCallback = function() {},
                                m = function(t, e, n, i) {
                                    var r = "immediateRender";
                                    return r in e || (e[r] = !(n && !1 === n[r] || i)), e
                                },
                                v = function(t) {
                                    if ("function" == typeof t) return t;
                                    var e = "object" == typeof t ? t : {
                                            each: t
                                        },
                                        n = e.ease,
                                        i = e.from || 0,
                                        r = e.base || 0,
                                        o = {},
                                        a = isNaN(i),
                                        s = e.axis,
                                        c = {
                                            center: .5,
                                            end: 1
                                        }[i] || 0;
                                    return function(t, l, h) {
                                        var u, p, d, f, m, v, g, y, _, x = (h || e).length,
                                            b = o[x];
                                        if (!b) {
                                            if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1 / 0])[0])) {
                                                for (g = -1 / 0; g < (g = h[_++].getBoundingClientRect().left) && _ < x;);
                                                _--
                                            }
                                            for (b = o[x] = [], u = a ? Math.min(_, x) * c - .5 : i % _, p = a ? x * c / _ - .5 : i / _ | 0, g = 0, y = 1 / 0, v = 0; v < x; v++) d = v % _ - u, f = p - (v / _ | 0), b[v] = m = s ? Math.abs("y" === s ? f : d) : Math.sqrt(d * d + f * f), m > g && (g = m), m < y && (y = m);
                                            b.max = g - y, b.min = y, b.v = x = e.amount || e.each * (_ > x ? x - 1 : s ? "y" === s ? x / _ : _ : Math.max(_, x / _)) || 0, b.b = x < 0 ? r - x : r
                                        }
                                        return x = (b[t] - b.min) / b.max, b.b + (n ? n.getRatio(x) : x) * b.v
                                    }
                                },
                                g = i.prototype = new e;
                            return i.version = "2.1.3", i.distribute = v, g.constructor = i, g.kill()._gc = g._forcingPlayhead = g._hasPause = !1, g.to = function(t, e, i, r) {
                                var o = i.repeat && u.TweenMax || n;
                                return e ? this.add(new o(t, e, i), r) : this.set(t, i, r)
                            }, g.from = function(t, e, i, r) {
                                return this.add((i.repeat && u.TweenMax || n).from(t, e, m(0, i)), r)
                            }, g.fromTo = function(t, e, i, r, o) {
                                var a = r.repeat && u.TweenMax || n;
                                return r = m(0, r, i), e ? this.add(a.fromTo(t, e, i, r), o) : this.set(t, r, o)
                            }, g.staggerTo = function(t, e, r, o, a, c, l, h) {
                                var u, f, m = new i({
                                        onComplete: c,
                                        onCompleteParams: l,
                                        callbackScope: h,
                                        smoothChildTiming: this.smoothChildTiming
                                    }),
                                    g = v(r.stagger || o),
                                    y = r.startAt,
                                    _ = r.cycle;
                                for ("string" == typeof t && (t = n.selector(t) || t), s(t = t || []) && (t = function(t) {
                                        var e, n = [],
                                            i = t.length;
                                        for (e = 0; e !== i; n.push(t[e++]));
                                        return n
                                    }(t)), f = 0; f < t.length; f++) u = p(r), y && (u.startAt = p(y), y.cycle && d(u.startAt, t, f)), _ && (d(u, t, f), null != u.duration && (e = u.duration, delete u.duration)), m.to(t[f], e, u, g(f, t[f], t));
                                return this.add(m, a)
                            }, g.staggerFrom = function(t, e, n, i, r, o, a, s) {
                                return n.runBackwards = !0, this.staggerTo(t, e, m(0, n), i, r, o, a, s)
                            }, g.staggerFromTo = function(t, e, n, i, r, o, a, s, c) {
                                return i.startAt = n, this.staggerTo(t, e, m(0, i, n), r, o, a, s, c)
                            }, g.call = function(t, e, i, r) {
                                return this.add(n.delayedCall(0, t, e, i), r)
                            }, g.set = function(t, e, i) {
                                return this.add(new n(t, 0, m(0, e, null, !0)), i)
                            }, i.exportRoot = function(t, e) {
                                null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0);
                                var r, o, a, s, c = new i(t),
                                    l = c._timeline;
                                for (null == e && (e = !0), l._remove(c, !0), c._startTime = 0, c._rawPrevTime = c._time = c._totalTime = l._time, a = l._first; a;) s = a._next, e && a instanceof n && a.target === a.vars.onComplete || ((o = a._startTime - a._delay) < 0 && (r = 1), c.add(a, o)), a = s;
                                return l.add(c, 0), r && c.totalDuration(), c
                            }, g.add = function(r, o, a, s) {
                                var l, h, u, p, d, f;
                                if ("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, r)), !(r instanceof t)) {
                                    if (r instanceof Array || r && r.push && c(r)) {
                                        for (a = a || "normal", s = s || 0, l = o, h = r.length, u = 0; u < h; u++) c(p = r[u]) && (p = new i({
                                            tweens: p
                                        })), this.add(p, l), "string" != typeof p && "function" != typeof p && ("sequence" === a ? l = p._startTime + p.totalDuration() / p._timeScale : "start" === a && (p._startTime -= p.delay())), l += s;
                                        return this._uncache(!0)
                                    }
                                    if ("string" == typeof r) return this.addLabel(r, o);
                                    if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                                    r = n.delayedCall(0, r)
                                }
                                if (e.prototype.add.call(this, r, o), (r._time || !r._duration && r._initted) && (l = (this.rawTime() - r._startTime) * r._timeScale, (!r._duration || Math.abs(Math.max(0, Math.min(r.totalDuration(), l))) - r._totalTime > 1e-5) && r.render(l, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                    for (f = (d = this).rawTime() > r._startTime; d._timeline;) f && d._timeline.smoothChildTiming ? d.totalTime(d._totalTime, !0) : d._gc && d._enabled(!0, !1), d = d._timeline;
                                return this
                            }, g.remove = function(e) {
                                if (e instanceof t) {
                                    this._remove(e, !1);
                                    var n = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                                    return e._startTime = (e._paused ? e._pauseTime : n._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
                                }
                                if (e instanceof Array || e && e.push && c(e)) {
                                    for (var i = e.length; --i > -1;) this.remove(e[i]);
                                    return this
                                }
                                return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                            }, g._remove = function(t, n) {
                                return e.prototype._remove.call(this, t, n), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                            }, g.append = function(t, e) {
                                return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                            }, g.insert = g.insertMultiple = function(t, e, n, i) {
                                return this.add(t, e || 0, n, i)
                            }, g.appendMultiple = function(t, e, n, i) {
                                return this.add(t, this._parseTimeOrLabel(null, e, !0, t), n, i)
                            }, g.addLabel = function(t, e) {
                                return this._labels[t] = this._parseTimeOrLabel(e), this
                            }, g.addPause = function(t, e, i, r) {
                                var o = n.delayedCall(0, f, i, r || this);
                                return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
                            }, g.removeLabel = function(t) {
                                return delete this._labels[t], this
                            }, g.getLabelTime = function(t) {
                                return null != this._labels[t] ? this._labels[t] : -1
                            }, g._parseTimeOrLabel = function(e, n, i, r) {
                                var o, a;
                                if (r instanceof t && r.timeline === this) this.remove(r);
                                else if (r && (r instanceof Array || r.push && c(r)))
                                    for (a = r.length; --a > -1;) r[a] instanceof t && r[a].timeline === this && this.remove(r[a]);
                                if (o = "number" != typeof e || n ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof n) return this._parseTimeOrLabel(n, i && "number" == typeof e && null == this._labels[n] ? e - o : 0, i);
                                if (n = n || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = o);
                                else {
                                    if (-1 === (a = e.indexOf("="))) return null == this._labels[e] ? i ? this._labels[e] = o + n : n : this._labels[e] + n;
                                    n = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)), e = a > 1 ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, i) : o
                                }
                                return Number(e) + n
                            }, g.seek = function(t, e) {
                                return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
                            }, g.stop = function() {
                                return this.paused(!0)
                            }, g.gotoAndPlay = function(t, e) {
                                return this.play(t, e)
                            }, g.gotoAndStop = function(t, e) {
                                return this.pause(t, e)
                            }, g.render = function(t, e, n) {
                                this._gc && this._enabled(!0, !1);
                                var i, r, o, a, s, c, u, p, d = this._time,
                                    f = this._dirty ? this.totalDuration() : this._totalDuration,
                                    m = this._startTime,
                                    v = this._timeScale,
                                    g = this._paused;
                                if (d !== this._time && (t += this._time - d), this._hasPause && !this._forcingPlayhead && !e) {
                                    if (t > d)
                                        for (i = this._first; i && i._startTime <= t && !c;) i._duration || "isPause" !== i.data || i.ratio || 0 === i._startTime && 0 === this._rawPrevTime || (c = i), i = i._next;
                                    else
                                        for (i = this._last; i && i._startTime >= t && !c;) i._duration || "isPause" === i.data && i._rawPrevTime > 0 && (c = i), i = i._prev;
                                    c && (this._time = this._totalTime = t = c._startTime, p = this._startTime + (this._reversed ? this._duration - t : t) / this._timeScale)
                                }
                                if (t >= f - 1e-8 && t >= 0) this._totalTime = this._time = f, this._reversed || this._hasPausedChild() || (r = !0, a = "onComplete", s = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-8 || this._rawPrevTime < 0 || 1e-8 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (s = !0, this._rawPrevTime > 1e-8 && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-8, t = f + 1e-4;
                                else if (t < 1e-8)
                                    if (this._totalTime = this._time = 0, t > -1e-8 && (t = 0), (0 !== d || 0 === this._duration && 1e-8 !== this._rawPrevTime && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (a = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (s = r = !0, a = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (s = !0), this._rawPrevTime = t;
                                    else {
                                        if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-8, 0 === t && r)
                                            for (i = this._first; i && 0 === i._startTime;) i._duration || (r = !1), i = i._next;
                                        t = 0, this._initted || (s = !0)
                                    }
                                else this._totalTime = this._time = this._rawPrevTime = t;
                                if (this._time !== d && this._first || n || s || c) {
                                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== d && t > 0 && (this._active = !0), 0 === d && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (u = this._time) >= d)
                                        for (i = this._first; i && (o = i._next, u === this._time && (!this._paused || g));)(i._active || i._startTime <= u && !i._paused && !i._gc) && (c === i && (this.pause(), this._pauseTime = p), i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)), i = o;
                                    else
                                        for (i = this._last; i && (o = i._prev, u === this._time && (!this._paused || g));) {
                                            if (i._active || i._startTime <= d && !i._paused && !i._gc) {
                                                if (c === i) {
                                                    for (c = i._prev; c && c.endTime() > this._time;) c.render(c._reversed ? c.totalDuration() - (t - c._startTime) * c._timeScale : (t - c._startTime) * c._timeScale, e, n), c = c._prev;
                                                    c = null, this.pause(), this._pauseTime = p
                                                }
                                                i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)
                                            }
                                            i = o
                                        }
                                    this._onUpdate && (e || (l.length && h(), this._callback("onUpdate"))), a && (this._gc || m !== this._startTime && v === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (r && (l.length && h(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                                }
                            }, g._hasPausedChild = function() {
                                for (var t = this._first; t;) {
                                    if (t._paused || t instanceof i && t._hasPausedChild()) return !0;
                                    t = t._next
                                }
                                return !1
                            }, g.getChildren = function(t, e, i, r) {
                                r = r || -9999999999;
                                for (var o = [], a = this._first, s = 0; a;) a._startTime < r || (a instanceof n ? !1 !== e && (o[s++] = a) : (!1 !== i && (o[s++] = a), !1 !== t && (s = (o = o.concat(a.getChildren(!0, e, i))).length))), a = a._next;
                                return o
                            }, g.getTweensOf = function(t, e) {
                                var i, r, o = this._gc,
                                    a = [],
                                    s = 0;
                                for (o && this._enabled(!0, !0), r = (i = n.getTweensOf(t)).length; --r > -1;)(i[r].timeline === this || e && this._contains(i[r])) && (a[s++] = i[r]);
                                return o && this._enabled(!1, !0), a
                            }, g.recent = function() {
                                return this._recent
                            }, g._contains = function(t) {
                                for (var e = t.timeline; e;) {
                                    if (e === this) return !0;
                                    e = e.timeline
                                }
                                return !1
                            }, g.shiftChildren = function(t, e, n) {
                                n = n || 0;
                                for (var i, r = this._first, o = this._labels; r;) r._startTime >= n && (r._startTime += t), r = r._next;
                                if (e)
                                    for (i in o) o[i] >= n && (o[i] += t);
                                return this._uncache(!0)
                            }, g._kill = function(t, e) {
                                if (!t && !e) return this._enabled(!1, !1);
                                for (var n = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), i = n.length, r = !1; --i > -1;) n[i]._kill(t, e) && (r = !0);
                                return r
                            }, g.clear = function(t) {
                                var e = this.getChildren(!1, !0, !0),
                                    n = e.length;
                                for (this._time = this._totalTime = 0; --n > -1;) e[n]._enabled(!1, !1);
                                return !1 !== t && (this._labels = {}), this._uncache(!0)
                            }, g.invalidate = function() {
                                for (var e = this._first; e;) e.invalidate(), e = e._next;
                                return t.prototype.invalidate.call(this)
                            }, g._enabled = function(t, n) {
                                if (t === this._gc)
                                    for (var i = this._first; i;) i._enabled(t, !0), i = i._next;
                                return e.prototype._enabled.call(this, t, n)
                            }, g.totalTime = function(e, n, i) {
                                this._forcingPlayhead = !0;
                                var r = t.prototype.totalTime.apply(this, arguments);
                                return this._forcingPlayhead = !1, r
                            }, g.duration = function(t) {
                                return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
                            }, g.totalDuration = function(t) {
                                if (!arguments.length) {
                                    if (this._dirty) {
                                        for (var e, n, i = 0, r = this._last, o = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > o && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : o = r._startTime, r._startTime < 0 && !r._paused && (i -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), o = 0), (n = r._startTime + r._totalDuration / r._timeScale) > i && (i = n), r = e;
                                        this._duration = this._totalDuration = i, this._dirty = !1
                                    }
                                    return this._totalDuration
                                }
                                return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
                            }, g.paused = function(e) {
                                if (!1 === e && this._paused)
                                    for (var n = this._first; n;) n._startTime === this._time && "isPause" === n.data && (n._rawPrevTime = 0), n = n._next;
                                return t.prototype.paused.apply(this, arguments)
                            }, g.usesFrames = function() {
                                for (var e = this._timeline; e._timeline;) e = e._timeline;
                                return e === t._rootFramesTimeline
                            }, g.rawTime = function(t) {
                                return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
                            }, i
                        }, !0), r._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, n) {
                            var i = function(e) {
                                    t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !!this.vars.yoyo, this._dirty = !0
                                },
                                o = e._internals,
                                a = o.lazyTweens,
                                s = o.lazyRender,
                                c = r._gsDefine.globals,
                                l = new n(null, null, 1, 0),
                                h = i.prototype = new t;
                            return h.constructor = i, h.kill()._gc = !1, i.version = "2.1.3", h.invalidate = function() {
                                return this._yoyo = !!this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
                            }, h.addCallback = function(t, n, i, r) {
                                return this.add(e.delayedCall(0, t, i, r), n)
                            }, h.removeCallback = function(t, e) {
                                if (t)
                                    if (null == e) this._kill(null, t);
                                    else
                                        for (var n = this.getTweensOf(t, !1), i = n.length, r = this._parseTimeOrLabel(e); --i > -1;) n[i]._startTime === r && n[i]._enabled(!1, !1);
                                return this
                            }, h.removePause = function(e) {
                                return this.removeCallback(t._internals.pauseCallback, e)
                            }, h.tweenTo = function(t, n) {
                                n = n || {};
                                var i, r, o, a = {
                                        ease: l,
                                        useFrames: this.usesFrames(),
                                        immediateRender: !1,
                                        lazy: !1
                                    },
                                    s = n.repeat && c.TweenMax || e;
                                for (r in n) a[r] = n[r];
                                return a.time = this._parseTimeOrLabel(t), i = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, o = new s(this, i, a), a.onStart = function() {
                                    o.target.paused(!0), o.vars.time === o.target.time() || i !== o.duration() || o.isFromTo || o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale).render(o.time(), !0, !0), n.onStart && n.onStart.apply(n.onStartScope || n.callbackScope || o, n.onStartParams || [])
                                }, o
                            }, h.tweenFromTo = function(t, e, n) {
                                n = n || {}, t = this._parseTimeOrLabel(t), n.startAt = {
                                    onComplete: this.seek,
                                    onCompleteParams: [t],
                                    callbackScope: this
                                }, n.immediateRender = !1 !== n.immediateRender;
                                var i = this.tweenTo(e, n);
                                return i.isFromTo = 1, i.duration(Math.abs(i.vars.time - t) / this._timeScale || .001)
                            }, h.render = function(t, e, n) {
                                this._gc && this._enabled(!0, !1);
                                var i, r, o, c, l, h, u, p, d, f = this._time,
                                    m = this._dirty ? this.totalDuration() : this._totalDuration,
                                    v = this._duration,
                                    g = this._totalTime,
                                    y = this._startTime,
                                    _ = this._timeScale,
                                    x = this._rawPrevTime,
                                    b = this._paused,
                                    w = this._cycle;
                                if (f !== this._time && (t += this._time - f), t >= m - 1e-8 && t >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (r = !0, c = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-8 || x < 0 || 1e-8 === x) && x !== t && this._first && (l = !0, x > 1e-8 && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-8, this._yoyo && 1 & this._cycle ? this._time = t = 0 : (this._time = v, t = v + 1e-4);
                                else if (t < 1e-8)
                                    if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, t > -1e-8 && (t = 0), (0 !== f || 0 === v && 1e-8 !== x && (x > 0 || t < 0 && x >= 0) && !this._locked) && (c = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = r = !0, c = "onReverseComplete") : x >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                                    else {
                                        if (this._rawPrevTime = v || !e || t || this._rawPrevTime === t ? t : 1e-8, 0 === t && r)
                                            for (i = this._first; i && 0 === i._startTime;) i._duration || (r = !1), i = i._next;
                                        t = 0, this._initted || (l = !0)
                                    }
                                else 0 === v && x < 0 && (l = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (h = v + this._repeatDelay, this._cycle = this._totalTime / h >> 0, this._cycle && this._cycle === this._totalTime / h && g <= t && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 1 & this._cycle && (this._time = v - this._time), this._time > v ? (this._time = v, t = v + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time));
                                if (this._hasPause && !this._forcingPlayhead && !e) {
                                    if ((t = this._time) > f || this._repeat && w !== this._cycle)
                                        for (i = this._first; i && i._startTime <= t && !u;) i._duration || "isPause" !== i.data || i.ratio || 0 === i._startTime && 0 === this._rawPrevTime || (u = i), i = i._next;
                                    else
                                        for (i = this._last; i && i._startTime >= t && !u;) i._duration || "isPause" === i.data && i._rawPrevTime > 0 && (u = i), i = i._prev;
                                    u && (d = this._startTime + (this._reversed ? this._duration - u._startTime : u._startTime) / this._timeScale, u._startTime < v && (this._time = this._rawPrevTime = t = u._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay)))
                                }
                                if (this._cycle !== w && !this._locked) {
                                    var M = this._yoyo && 0 != (1 & w),
                                        T = M === (this._yoyo && 0 != (1 & this._cycle)),
                                        E = this._totalTime,
                                        S = this._cycle,
                                        A = this._rawPrevTime,
                                        P = this._time;
                                    if (this._totalTime = w * v, this._cycle < w ? M = !M : this._totalTime += v, this._time = f, this._rawPrevTime = 0 === v ? x - 1e-4 : x, this._cycle = w, this._locked = !0, f = M ? 0 : v, this.render(f, e, 0 === v), e || this._gc || this.vars.onRepeat && (this._cycle = S, this._locked = !1, this._callback("onRepeat")), f !== this._time) return;
                                    if (T && (this._cycle = w, this._locked = !0, f = M ? v + 1e-4 : -1e-4, this.render(f, !0, !1)), this._locked = !1, this._paused && !b) return;
                                    this._time = P, this._totalTime = E, this._cycle = S, this._rawPrevTime = A
                                }
                                if (this._time !== f && this._first || n || l || u) {
                                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== g && t > 0 && (this._active = !0), 0 === g && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (p = this._time) >= f)
                                        for (i = this._first; i && (o = i._next, p === this._time && (!this._paused || b));)(i._active || i._startTime <= this._time && !i._paused && !i._gc) && (u === i && (this.pause(), this._pauseTime = d), i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)), i = o;
                                    else
                                        for (i = this._last; i && (o = i._prev, p === this._time && (!this._paused || b));) {
                                            if (i._active || i._startTime <= f && !i._paused && !i._gc) {
                                                if (u === i) {
                                                    for (u = i._prev; u && u.endTime() > this._time;) u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, n), u = u._prev;
                                                    u = null, this.pause(), this._pauseTime = d
                                                }
                                                i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)
                                            }
                                            i = o
                                        }
                                    this._onUpdate && (e || (a.length && s(), this._callback("onUpdate"))), c && (this._locked || this._gc || y !== this._startTime && _ === this._timeScale || (0 === this._time || m >= this.totalDuration()) && (r && (a.length && s(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c)))
                                } else g !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
                            }, h.getActive = function(t, e, n) {
                                var i, r, o = [],
                                    a = this.getChildren(t || null == t, e || null == t, !!n),
                                    s = 0,
                                    c = a.length;
                                for (i = 0; i < c; i++)(r = a[i]).isActive() && (o[s++] = r);
                                return o
                            }, h.getLabelAfter = function(t) {
                                t || 0 !== t && (t = this._time);
                                var e, n = this.getLabelsArray(),
                                    i = n.length;
                                for (e = 0; e < i; e++)
                                    if (n[e].time > t) return n[e].name;
                                return null
                            }, h.getLabelBefore = function(t) {
                                null == t && (t = this._time);
                                for (var e = this.getLabelsArray(), n = e.length; --n > -1;)
                                    if (e[n].time < t) return e[n].name;
                                return null
                            }, h.getLabelsArray = function() {
                                var t, e = [],
                                    n = 0;
                                for (t in this._labels) e[n++] = {
                                    time: this._labels[t],
                                    name: t
                                };
                                return e.sort(function(t, e) {
                                    return t.time - e.time
                                }), e
                            }, h.invalidate = function() {
                                return this._locked = !1, t.prototype.invalidate.call(this)
                            }, h.progress = function(t, e) {
                                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
                            }, h.totalProgress = function(t, e) {
                                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
                            }, h.totalDuration = function(e) {
                                return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                            }, h.time = function(t, e) {
                                if (!arguments.length) return this._time;
                                this._dirty && this.totalDuration();
                                var n = this._duration,
                                    i = this._cycle,
                                    r = i * (n + this._repeatDelay);
                                return t > n && (t = n), this.totalTime(this._yoyo && 1 & i ? n - t + r : this._repeat ? t + r : t, e)
                            }, h.repeat = function(t) {
                                return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                            }, h.repeatDelay = function(t) {
                                return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                            }, h.yoyo = function(t) {
                                return arguments.length ? (this._yoyo = t, this) : this._yoyo
                            }, h.currentLabel = function(t) {
                                return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                            }, i
                        }, !0),
                        function() {
                            var t = 180 / Math.PI,
                                e = [],
                                n = [],
                                i = [],
                                o = {},
                                a = r._gsDefine.globals,
                                s = function(t, e, n, i) {
                                    n === i && (n = i - (i - e) / 1e6), t === e && (e = t + (n - t) / 1e6), this.a = t, this.b = e, this.c = n, this.d = i, this.da = i - t, this.ca = n - t, this.ba = e - t
                                },
                                c = function(t, e, n, i) {
                                    var r = {
                                            a: t
                                        },
                                        o = {},
                                        a = {},
                                        s = {
                                            c: i
                                        },
                                        c = (t + e) / 2,
                                        l = (e + n) / 2,
                                        h = (n + i) / 2,
                                        u = (c + l) / 2,
                                        p = (l + h) / 2,
                                        d = (p - u) / 8;
                                    return r.b = c + (t - c) / 4, o.b = u + d, r.c = o.a = (r.b + o.b) / 2, o.c = a.a = (u + p) / 2, a.b = p - d, s.b = h + (i - h) / 4, a.c = s.a = (a.b + s.b) / 2, [r, o, a, s]
                                },
                                l = function(t, r, o, a, s) {
                                    var l, h, u, p, d, f, m, v, g, y, _, x, b, w = t.length - 1,
                                        M = 0,
                                        T = t[0].a;
                                    for (l = 0; l < w; l++) h = (d = t[M]).a, u = d.d, p = t[M + 1].d, s ? (_ = e[l], b = ((x = n[l]) + _) * r * .25 / (a ? .5 : i[l] || .5), v = u - ((f = u - (u - h) * (a ? .5 * r : 0 !== _ ? b / _ : 0)) + (((m = u + (p - u) * (a ? .5 * r : 0 !== x ? b / x : 0)) - f) * (3 * _ / (_ + x) + .5) / 4 || 0))) : v = u - ((f = u - (u - h) * r * .5) + (m = u + (p - u) * r * .5)) / 2, f += v, m += v, d.c = g = f, d.b = 0 !== l ? T : T = d.a + .6 * (d.c - d.a), d.da = u - h, d.ca = g - h, d.ba = T - h, o ? (y = c(h, T, g, u), t.splice(M, 1, y[0], y[1], y[2], y[3]), M += 4) : M++, T = m;
                                    (d = t[M]).b = T, d.c = T + .4 * (d.d - T), d.da = d.d - d.a, d.ca = d.c - d.a, d.ba = T - d.a, o && (y = c(d.a, T, d.c, d.d), t.splice(M, 1, y[0], y[1], y[2], y[3]))
                                },
                                h = function(t, i, r, o) {
                                    var a, c, l, h, u, p, d = [];
                                    if (o)
                                        for (c = (t = [o].concat(t)).length; --c > -1;) "string" == typeof(p = t[c][i]) && "=" === p.charAt(1) && (t[c][i] = o[i] + Number(p.charAt(0) + p.substr(2)));
                                    if ((a = t.length - 2) < 0) return d[0] = new s(t[0][i], 0, 0, t[0][i]), d;
                                    for (c = 0; c < a; c++) l = t[c][i], h = t[c + 1][i], d[c] = new s(l, 0, 0, h), r && (u = t[c + 2][i], e[c] = (e[c] || 0) + (h - l) * (h - l), n[c] = (n[c] || 0) + (u - h) * (u - h));
                                    return d[c] = new s(t[c][i], 0, 0, t[c + 1][i]), d
                                },
                                u = function(t, r, a, s, c, u) {
                                    var p, d, f, m, v, g, y, _, x = {},
                                        b = [],
                                        w = u || t[0];
                                    for (d in c = "string" == typeof c ? "," + c + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == r && (r = 1), t[0]) b.push(d);
                                    if (t.length > 1) {
                                        for (_ = t[t.length - 1], y = !0, p = b.length; --p > -1;)
                                            if (d = b[p], Math.abs(w[d] - _[d]) > .05) {
                                                y = !1;
                                                break
                                            }
                                        y && (t = t.concat(), u && t.unshift(u), t.push(t[1]), u = t[t.length - 3])
                                    }
                                    for (e.length = n.length = i.length = 0, p = b.length; --p > -1;) d = b[p], o[d] = -1 !== c.indexOf("," + d + ","), x[d] = h(t, d, o[d], u);
                                    for (p = e.length; --p > -1;) e[p] = Math.sqrt(e[p]), n[p] = Math.sqrt(n[p]);
                                    if (!s) {
                                        for (p = b.length; --p > -1;)
                                            if (o[d])
                                                for (g = (f = x[b[p]]).length - 1, m = 0; m < g; m++) v = f[m + 1].da / n[m] + f[m].da / e[m] || 0, i[m] = (i[m] || 0) + v * v;
                                        for (p = i.length; --p > -1;) i[p] = Math.sqrt(i[p])
                                    }
                                    for (p = b.length, m = a ? 4 : 1; --p > -1;) f = x[d = b[p]], l(f, r, a, s, o[d]), y && (f.splice(0, m), f.splice(f.length - m, m));
                                    return x
                                },
                                p = function(t, e, n) {
                                    for (var i, r, o, a, s, c, l, h, u, p, d, f = 1 / n, m = t.length; --m > -1;)
                                        for (o = (p = t[m]).a, a = p.d - o, s = p.c - o, c = p.b - o, i = r = 0, h = 1; h <= n; h++) i = r - (r = ((l = f * h) * l * a + 3 * (u = 1 - l) * (l * s + u * c)) * l), e[d = m * n + h - 1] = (e[d] || 0) + i * i
                                },
                                d = r._gsDefine.plugin({
                                    propName: "bezier",
                                    priority: -1,
                                    version: "1.3.9",
                                    API: 2,
                                    global: !0,
                                    init: function(t, e, n) {
                                        this._target = t, e instanceof Array && (e = {
                                            values: e
                                        }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                                        var i, r, o, a, c, l = e.values || [],
                                            h = {},
                                            d = l[0],
                                            f = e.autoRotate || n.vars.orientToBezier;
                                        for (i in this._autoRotate = f ? f instanceof Array ? f : [
                                                ["x", "y", "rotation", !0 === f ? 0 : Number(f) || 0]
                                            ] : null, d) this._props.push(i);
                                        for (o = this._props.length; --o > -1;) i = this._props[o], this._overwriteProps.push(i), r = this._func[i] = "function" == typeof t[i], h[i] = r ? t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]() : parseFloat(t[i]), c || h[i] !== l[0][i] && (c = h);
                                        if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? u(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, c) : function(t, e, n) {
                                                var i, r, o, a, c, l, h, u, p, d, f, m = {},
                                                    v = "cubic" === (e = e || "soft") ? 3 : 2,
                                                    g = "soft" === e,
                                                    y = [];
                                                if (g && n && (t = [n].concat(t)), null == t || t.length < v + 1) throw "invalid Bezier data";
                                                for (p in t[0]) y.push(p);
                                                for (l = y.length; --l > -1;) {
                                                    for (m[p = y[l]] = c = [], d = 0, u = t.length, h = 0; h < u; h++) i = null == n ? t[h][p] : "string" == typeof(f = t[h][p]) && "=" === f.charAt(1) ? n[p] + Number(f.charAt(0) + f.substr(2)) : Number(f), g && h > 1 && h < u - 1 && (c[d++] = (i + c[d - 2]) / 2), c[d++] = i;
                                                    for (u = d - v + 1, d = 0, h = 0; h < u; h += v) i = c[h], r = c[h + 1], o = c[h + 2], a = 2 === v ? 0 : c[h + 3], c[d++] = f = 3 === v ? new s(i, r, o, a) : new s(i, (2 * r + i) / 3, (2 * r + o) / 3, o);
                                                    c.length = d
                                                }
                                                return m
                                            }(l, e.type, h), this._segCount = this._beziers[i].length, this._timeRes) {
                                            var m = function(t, e) {
                                                var n, i, r, o, a = [],
                                                    s = [],
                                                    c = 0,
                                                    l = 0,
                                                    h = (e = e >> 0 || 6) - 1,
                                                    u = [],
                                                    d = [];
                                                for (n in t) p(t[n], a, e);
                                                for (r = a.length, i = 0; i < r; i++) c += Math.sqrt(a[i]), d[o = i % e] = c, o === h && (l += c, u[o = i / e >> 0] = d, s[o] = l, c = 0, d = []);
                                                return {
                                                    length: l,
                                                    lengths: s,
                                                    segments: u
                                                }
                                            }(this._beziers, this._timeRes);
                                            this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                                        }
                                        if (f = this._autoRotate)
                                            for (this._initialRotations = [], f[0] instanceof Array || (this._autoRotate = f = [f]), o = f.length; --o > -1;) {
                                                for (a = 0; a < 3; a++) i = f[o][a], this._func[i] = "function" == typeof t[i] && t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)];
                                                i = f[o][2], this._initialRotations[o] = (this._func[i] ? this._func[i].call(this._target) : this._target[i]) || 0, this._overwriteProps.push(i)
                                            }
                                        return this._startRatio = n.vars.runBackwards ? 1 : 0, !0
                                    },
                                    set: function(e) {
                                        var n, i, r, o, a, s, c, l, h, u, p, d = this._segCount,
                                            f = this._func,
                                            m = this._target,
                                            v = e !== this._startRatio;
                                        if (this._timeRes) {
                                            if (h = this._lengths, u = this._curSeg, p = e * this._length, r = this._li, p > this._l2 && r < d - 1) {
                                                for (l = d - 1; r < l && (this._l2 = h[++r]) <= p;);
                                                this._l1 = h[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0]
                                            } else if (p < this._l1 && r > 0) {
                                                for (; r > 0 && (this._l1 = h[--r]) >= p;);
                                                0 === r && p < this._l1 ? this._l1 = 0 : r++, this._l2 = h[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                                            }
                                            if (n = r, p -= this._l1, r = this._si, p > this._s2 && r < u.length - 1) {
                                                for (l = u.length - 1; r < l && (this._s2 = u[++r]) <= p;);
                                                this._s1 = u[r - 1], this._si = r
                                            } else if (p < this._s1 && r > 0) {
                                                for (; r > 0 && (this._s1 = u[--r]) >= p;);
                                                0 === r && p < this._s1 ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r
                                            }
                                            s = 1 === e ? 1 : (r + (p - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                                        } else s = (e - (n = e < 0 ? 0 : e >= 1 ? d - 1 : d * e >> 0) * (1 / d)) * d;
                                        for (i = 1 - s, r = this._props.length; --r > -1;) o = this._props[r], c = (s * s * (a = this._beziers[o][n]).da + 3 * i * (s * a.ca + i * a.ba)) * s + a.a, this._mod[o] && (c = this._mod[o](c, m)), f[o] ? m[o](c) : m[o] = c;
                                        if (this._autoRotate) {
                                            var g, y, _, x, b, w, M, T = this._autoRotate;
                                            for (r = T.length; --r > -1;) o = T[r][2], w = T[r][3] || 0, M = !0 === T[r][4] ? 1 : t, a = this._beziers[T[r][0]], g = this._beziers[T[r][1]], a && g && (a = a[n], g = g[n], y = a.a + (a.b - a.a) * s, y += ((x = a.b + (a.c - a.b) * s) - y) * s, x += (a.c + (a.d - a.c) * s - x) * s, _ = g.a + (g.b - g.a) * s, _ += ((b = g.b + (g.c - g.b) * s) - _) * s, b += (g.c + (g.d - g.c) * s - b) * s, c = v ? Math.atan2(b - _, x - y) * M + w : this._initialRotations[r], this._mod[o] && (c = this._mod[o](c, m)), f[o] ? m[o](c) : m[o] = c)
                                        }
                                    }
                                }),
                                f = d.prototype;
                            d.bezierThrough = u, d.cubicToQuadratic = c, d._autoCSS = !0, d.quadraticToCubic = function(t, e, n) {
                                return new s(t, (2 * e + t) / 3, (2 * e + n) / 3, n)
                            }, d._cssRegister = function() {
                                var t = a.CSSPlugin;
                                if (t) {
                                    var e = t._internals,
                                        n = e._parseToProxy,
                                        i = e._setPluginRatio,
                                        r = e.CSSPropTween;
                                    e._registerComplexSpecialProp("bezier", {
                                        parser: function(t, e, o, a, s, c) {
                                            e instanceof Array && (e = {
                                                values: e
                                            }), c = new d;
                                            var l, h, u, p = e.values,
                                                f = p.length - 1,
                                                m = [],
                                                v = {};
                                            if (f < 0) return s;
                                            for (l = 0; l <= f; l++) u = n(t, p[l], a, s, c, f !== l), m[l] = u.end;
                                            for (h in e) v[h] = e[h];
                                            return v.values = m, (s = new r(t, "bezier", 0, 0, u.pt, 2)).data = u, s.plugin = c, s.setRatio = i, 0 === v.autoRotate && (v.autoRotate = !0), !v.autoRotate || v.autoRotate instanceof Array || (l = !0 === v.autoRotate ? 0 : Number(v.autoRotate), v.autoRotate = null != u.end.left ? [
                                                ["left", "top", "rotation", l, !1]
                                            ] : null != u.end.x && [
                                                ["x", "y", "rotation", l, !1]
                                            ]), v.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), c._onInitTween(u.proxy, v, a._tween), s
                                        }
                                    })
                                }
                            }, f._mod = function(t) {
                                for (var e, n = this._overwriteProps, i = n.length; --i > -1;)(e = t[n[i]]) && "function" == typeof e && (this._mod[n[i]] = e)
                            }, f._kill = function(t) {
                                var e, n, i = this._props;
                                for (e in this._beziers)
                                    if (e in t)
                                        for (delete this._beziers[e], delete this._func[e], n = i.length; --n > -1;) i[n] === e && i.splice(n, 1);
                                if (i = this._autoRotate)
                                    for (n = i.length; --n > -1;) t[i[n][2]] && i.splice(n, 1);
                                return this._super._kill.call(this, t)
                            }
                        }(), r._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
                            var n, i, o, a, s = function() {
                                    t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = s.prototype.setRatio
                                },
                                c = r._gsDefine.globals,
                                l = {},
                                h = s.prototype = new t("css");
                            h.constructor = s, s.version = "2.1.3", s.API = 2, s.defaultTransformPerspective = 0, s.defaultSkewType = "compensated", s.defaultSmoothOrigin = !0, h = "px", s.suffixMap = {
                                top: h,
                                right: h,
                                bottom: h,
                                left: h,
                                width: h,
                                height: h,
                                fontSize: h,
                                padding: h,
                                margin: h,
                                perspective: h,
                                lineHeight: ""
                            };
                            var u, p, d, f, m, v, g, y, _ = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                                x = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                                b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                                w = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b),?/gi,
                                M = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                                T = /(?:\d|\-|\+|=|#|\.)*/g,
                                E = /opacity *= *([^)]*)/i,
                                S = /opacity:([^;]*)/i,
                                A = /alpha\(opacity *=.+?\)/i,
                                P = /^(rgb|hsl)/,
                                L = /([A-Z])/g,
                                R = /-([a-z])/gi,
                                C = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                                O = function(t, e) {
                                    return e.toUpperCase()
                                },
                                I = /(?:Left|Right|Width)/i,
                                D = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                                N = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                                B = /,(?=[^\)]*(?:\(|$))/gi,
                                H = /[\s,\(]/i,
                                F = Math.PI / 180,
                                k = 180 / Math.PI,
                                U = {},
                                z = {
                                    style: {}
                                },
                                G = r.document || {
                                    createElement: function() {
                                        return z
                                    }
                                },
                                j = function(t, e) {
                                    var n = G.createElementNS ? G.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : G.createElement(t);
                                    return n.style ? n : G.createElement(t)
                                },
                                V = j("div"),
                                W = j("img"),
                                X = s._internals = {
                                    _specialProps: l
                                },
                                q = (r.navigator || {}).userAgent || "",
                                Y = function() {
                                    var t = q.indexOf("Android"),
                                        e = j("a");
                                    return d = -1 !== q.indexOf("Safari") && -1 === q.indexOf("Chrome") && (-1 === t || parseFloat(q.substr(t + 8, 2)) > 3), m = d && parseFloat(q.substr(q.indexOf("Version/") + 8, 2)) < 6, f = -1 !== q.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(q) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(q)) && (v = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
                                }(),
                                Z = function(t) {
                                    return E.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                                },
                                J = function(t) {
                                    r.console && console.log(t)
                                },
                                K = "",
                                Q = "",
                                $ = function(t, e) {
                                    var n, i, r = (e = e || V).style;
                                    if (void 0 !== r[t]) return t;
                                    for (t = t.charAt(0).toUpperCase() + t.substr(1), n = ["O", "Moz", "ms", "Ms", "Webkit"], i = 5; --i > -1 && void 0 === r[n[i] + t];);
                                    return i >= 0 ? (K = "-" + (Q = 3 === i ? "ms" : n[i]).toLowerCase() + "-", Q + t) : null
                                },
                                tt = "undefined" != typeof window ? window : G.defaultView || {
                                    getComputedStyle: function() {}
                                },
                                et = function(t) {
                                    return tt.getComputedStyle(t)
                                },
                                nt = s.getStyle = function(t, e, n, i, r) {
                                    var o;
                                    return Y || "opacity" !== e ? (!i && t.style[e] ? o = t.style[e] : (n = n || et(t)) ? o = n[e] || n.getPropertyValue(e) || n.getPropertyValue(e.replace(L, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : Z(t)
                                },
                                it = X.convertToPixels = function(t, n, i, r, o) {
                                    if ("px" === r || !r && "lineHeight" !== n) return i;
                                    if ("auto" === r || !i) return 0;
                                    var a, c, l, h = I.test(n),
                                        u = t,
                                        p = V.style,
                                        d = i < 0,
                                        f = 1 === i;
                                    if (d && (i = -i), f && (i *= 100), "lineHeight" !== n || r)
                                        if ("%" === r && -1 !== n.indexOf("border")) a = i / 100 * (h ? t.clientWidth : t.clientHeight);
                                        else {
                                            if (p.cssText = "border:0 solid red;position:" + nt(t, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) p[h ? "borderLeftWidth" : "borderTopWidth"] = i + r;
                                            else {
                                                if (u = t.parentNode || G.body, -1 !== nt(u, "display").indexOf("flex") && (p.position = "absolute"), c = u._gsCache, l = e.ticker.frame, c && h && c.time === l) return c.width * i / 100;
                                                p[h ? "width" : "height"] = i + r
                                            }
                                            u.appendChild(V), a = parseFloat(V[h ? "offsetWidth" : "offsetHeight"]), u.removeChild(V), h && "%" === r && !1 !== s.cacheWidths && ((c = u._gsCache = u._gsCache || {}).time = l, c.width = a / i * 100), 0 !== a || o || (a = it(t, n, i, r, !0))
                                        }
                                    else c = et(t).lineHeight, t.style.lineHeight = i, a = parseFloat(et(t).lineHeight), t.style.lineHeight = c;
                                    return f && (a /= 100), d ? -a : a
                                },
                                rt = X.calculateOffset = function(t, e, n) {
                                    if ("absolute" !== nt(t, "position", n)) return 0;
                                    var i = "left" === e ? "Left" : "Top",
                                        r = nt(t, "margin" + i, n);
                                    return t["offset" + i] - (it(t, e, parseFloat(r), r.replace(T, "")) || 0)
                                },
                                ot = function(t, e) {
                                    var n, i, r, o = {};
                                    if (e = e || et(t))
                                        if (n = e.length)
                                            for (; --n > -1;) - 1 !== (r = e[n]).indexOf("-transform") && Ot !== r || (o[r.replace(R, O)] = e.getPropertyValue(r));
                                        else
                                            for (n in e) - 1 !== n.indexOf("Transform") && Ct !== n || (o[n] = e[n]);
                                    else if (e = t.currentStyle || t.style)
                                        for (n in e) "string" == typeof n && void 0 === o[n] && (o[n.replace(R, O)] = e[n]);
                                    return Y || (o.opacity = Z(t)), i = Wt(t, e, !1), o.rotation = i.rotation, o.skewX = i.skewX, o.scaleX = i.scaleX, o.scaleY = i.scaleY, o.x = i.x, o.y = i.y, Dt && (o.z = i.z, o.rotationX = i.rotationX, o.rotationY = i.rotationY, o.scaleZ = i.scaleZ), o.filters && delete o.filters, o
                                },
                                at = function(t, e, n, i, r) {
                                    var o, a, s, c = {},
                                        l = t.style;
                                    for (a in n) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (o = n[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (c[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[a] || "" === e[a].replace(M, "") ? o : 0 : rt(t, a), void 0 !== l[a] && (s = new bt(l, a, l[a], s))));
                                    if (i)
                                        for (a in i) "className" !== a && (c[a] = i[a]);
                                    return {
                                        difs: c,
                                        firstMPT: s
                                    }
                                },
                                st = {
                                    width: ["Left", "Right"],
                                    height: ["Top", "Bottom"]
                                },
                                ct = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                                lt = function(t, e, n) {
                                    if ("svg" === (t.nodeName + "").toLowerCase()) return (n || et(t))[e] || 0;
                                    if (t.getCTM && Gt(t)) return t.getBBox()[e] || 0;
                                    var i = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                                        r = st[e],
                                        o = r.length;
                                    for (n = n || et(t); --o > -1;) i -= parseFloat(nt(t, "padding" + r[o], n, !0)) || 0, i -= parseFloat(nt(t, "border" + r[o] + "Width", n, !0)) || 0;
                                    return i
                                },
                                ht = function(t, e) {
                                    if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                                    null != t && "" !== t || (t = "0 0");
                                    var n, i = t.split(" "),
                                        r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0],
                                        o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1];
                                    if (i.length > 3 && !e) {
                                        for (i = t.split(", ").join(",").split(","), t = [], n = 0; n < i.length; n++) t.push(ht(i[n]));
                                        return t.join(",")
                                    }
                                    return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + o + (i.length > 2 ? " " + i[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== o.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(r.replace(M, "")), e.oy = parseFloat(o.replace(M, "")), e.v = t), e || t
                                },
                                ut = function(t, e) {
                                    return "function" == typeof t && (t = t(y, g)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
                                },
                                pt = function(t, e) {
                                    "function" == typeof t && (t = t(y, g));
                                    var n = "string" == typeof t && "=" === t.charAt(1);
                                    return "string" == typeof t && "v" === t.charAt(t.length - 2) && (t = (n ? t.substr(0, 2) : 0) + window["inner" + ("vh" === t.substr(-2) ? "Height" : "Width")] * (parseFloat(n ? t.substr(2) : t) / 100)), null == t ? e : n ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
                                },
                                dt = function(t, e, n, i) {
                                    var r, o, a, s, c;
                                    return "function" == typeof t && (t = t(y, g)), null == t ? s = e : "number" == typeof t ? s = t : (r = 360, o = t.split("_"), a = ((c = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === t.indexOf("rad") ? 1 : k) - (c ? 0 : e), o.length && (i && (i[n] = e + a), -1 !== t.indexOf("short") && (a %= r) !== a % (r / 2) && (a = a < 0 ? a + r : a - r), -1 !== t.indexOf("_cw") && a < 0 ? a = (a + 9999999999 * r) % r - (a / r | 0) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (a / r | 0) * r)), s = e + a), s < 1e-6 && s > -1e-6 && (s = 0), s
                                },
                                ft = {
                                    aqua: [0, 255, 255],
                                    lime: [0, 255, 0],
                                    silver: [192, 192, 192],
                                    black: [0, 0, 0],
                                    maroon: [128, 0, 0],
                                    teal: [0, 128, 128],
                                    blue: [0, 0, 255],
                                    navy: [0, 0, 128],
                                    white: [255, 255, 255],
                                    fuchsia: [255, 0, 255],
                                    olive: [128, 128, 0],
                                    yellow: [255, 255, 0],
                                    orange: [255, 165, 0],
                                    gray: [128, 128, 128],
                                    purple: [128, 0, 128],
                                    green: [0, 128, 0],
                                    red: [255, 0, 0],
                                    pink: [255, 192, 203],
                                    cyan: [0, 255, 255],
                                    transparent: [255, 255, 255, 0]
                                },
                                mt = function(t, e, n) {
                                    return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                                },
                                vt = s.parseColor = function(t, e) {
                                    var n, i, r, o, a, s, c, l, h, u, p;
                                    if (t)
                                        if ("number" == typeof t) n = [t >> 16, t >> 8 & 255, 255 & t];
                                        else {
                                            if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ft[t]) n = ft[t];
                                            else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (i = t.charAt(1)) + i + (r = t.charAt(2)) + r + (o = t.charAt(3)) + o), n = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                                            else if ("hsl" === t.substr(0, 3))
                                                if (n = p = t.match(_), e) {
                                                    if (-1 !== t.indexOf("=")) return t.match(x)
                                                } else a = Number(n[0]) % 360 / 360, s = Number(n[1]) / 100, i = 2 * (c = Number(n[2]) / 100) - (r = c <= .5 ? c * (s + 1) : c + s - c * s), n.length > 3 && (n[3] = Number(n[3])), n[0] = mt(a + 1 / 3, i, r), n[1] = mt(a, i, r), n[2] = mt(a - 1 / 3, i, r);
                                            else n = t.match(_) || ft.transparent;
                                            n[0] = Number(n[0]), n[1] = Number(n[1]), n[2] = Number(n[2]), n.length > 3 && (n[3] = Number(n[3]))
                                        }
                                    else n = ft.black;
                                    return e && !p && (i = n[0] / 255, r = n[1] / 255, o = n[2] / 255, c = ((l = Math.max(i, r, o)) + (h = Math.min(i, r, o))) / 2, l === h ? a = s = 0 : (u = l - h, s = c > .5 ? u / (2 - l - h) : u / (l + h), a = l === i ? (r - o) / u + (r < o ? 6 : 0) : l === r ? (o - i) / u + 2 : (i - r) / u + 4, a *= 60), n[0] = a + .5 | 0, n[1] = 100 * s + .5 | 0, n[2] = 100 * c + .5 | 0), n
                                },
                                gt = function(t, e) {
                                    var n, i, r, o = t.match(yt) || [],
                                        a = 0,
                                        s = "";
                                    if (!o.length) return t;
                                    for (n = 0; n < o.length; n++) i = o[n], a += (r = t.substr(a, t.indexOf(i, a) - a)).length + i.length, 3 === (i = vt(i, e)).length && i.push(1), s += r + (e ? "hsla(" + i[0] + "," + i[1] + "%," + i[2] + "%," + i[3] : "rgba(" + i.join(",")) + ")";
                                    return s + t.substr(a)
                                },
                                yt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                            for (h in ft) yt += "|" + h + "\\b";
                            yt = new RegExp(yt + ")", "gi"), s.colorStringFilter = function(t) {
                                var e, n = t[0] + " " + t[1];
                                yt.test(n) && (e = -1 !== n.indexOf("hsl(") || -1 !== n.indexOf("hsla("), t[0] = gt(t[0], e), t[1] = gt(t[1], e)), yt.lastIndex = 0
                            }, e.defaultStringFilter || (e.defaultStringFilter = s.colorStringFilter);
                            var _t = function(t, e, n, i) {
                                    if (null == t) return function(t) {
                                        return t
                                    };
                                    var r, o = e ? (t.match(yt) || [""])[0] : "",
                                        a = t.split(o).join("").match(b) || [],
                                        s = t.substr(0, t.indexOf(a[0])),
                                        c = ")" === t.charAt(t.length - 1) ? ")" : "",
                                        l = -1 !== t.indexOf(" ") ? " " : ",",
                                        h = a.length,
                                        u = h > 0 ? a[0].replace(_, "") : "";
                                    return h ? r = e ? function(t) {
                                        var e, p, d, f;
                                        if ("number" == typeof t) t += u;
                                        else if (i && B.test(t)) {
                                            for (f = t.replace(B, "|").split("|"), d = 0; d < f.length; d++) f[d] = r(f[d]);
                                            return f.join(",")
                                        }
                                        if (e = (t.match(yt) || [o])[0], d = (p = t.split(e).join("").match(b) || []).length, h > d--)
                                            for (; ++d < h;) p[d] = n ? p[(d - 1) / 2 | 0] : a[d];
                                        return s + p.join(l) + l + e + c + (-1 !== t.indexOf("inset") ? " inset" : "")
                                    } : function(t) {
                                        var e, o, p;
                                        if ("number" == typeof t) t += u;
                                        else if (i && B.test(t)) {
                                            for (o = t.replace(B, "|").split("|"), p = 0; p < o.length; p++) o[p] = r(o[p]);
                                            return o.join(",")
                                        }
                                        if (p = (e = t.match("," === l ? b : w) || []).length, h > p--)
                                            for (; ++p < h;) e[p] = n ? e[(p - 1) / 2 | 0] : a[p];
                                        return (s && "none" !== t && t.substr(0, t.indexOf(e[0])) || s) + e.join(l) + c
                                    } : function(t) {
                                        return t
                                    }
                                },
                                xt = function(t) {
                                    return t = t.split(","),
                                        function(e, n, i, r, o, a, s) {
                                            var c, l = (n + "").split(" ");
                                            for (s = {}, c = 0; c < 4; c++) s[t[c]] = l[c] = l[c] || l[(c - 1) / 2 >> 0];
                                            return r.parse(e, s, o, a)
                                        }
                                },
                                bt = (X._setPluginRatio = function(t) {
                                    this.plugin.setRatio(t);
                                    for (var e, n, i, r, o, a = this.data, s = a.proxy, c = a.firstMPT; c;) e = s[c.v], c.r ? e = c.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), c.t[c.p] = e, c = c._next;
                                    if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === t || 0 === t)
                                        for (c = a.firstMPT, o = 1 === t ? "e" : "b"; c;) {
                                            if ((n = c.t).type) {
                                                if (1 === n.type) {
                                                    for (r = n.xs0 + n.s + n.xs1, i = 1; i < n.l; i++) r += n["xn" + i] + n["xs" + (i + 1)];
                                                    n[o] = r
                                                }
                                            } else n[o] = n.s + n.xs0;
                                            c = c._next
                                        }
                                }, function(t, e, n, i, r) {
                                    this.t = t, this.p = e, this.v = n, this.r = r, i && (i._prev = this, this._next = i)
                                }),
                                wt = (X._parseToProxy = function(t, e, n, i, r, o) {
                                    var a, s, c, l, h, u = i,
                                        p = {},
                                        d = {},
                                        f = n._transform,
                                        m = U;
                                    for (n._transform = null, U = e, i = h = n.parse(t, e, i, r), U = m, o && (n._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); i && i !== u;) {
                                        if (i.type <= 1 && (d[s = i.p] = i.s + i.c, p[s] = i.s, o || (l = new bt(i, "s", s, l, i.r), i.c = 0), 1 === i.type))
                                            for (a = i.l; --a > 0;) c = "xn" + a, d[s = i.p + "_" + c] = i.data[c], p[s] = i[c], o || (l = new bt(i, c, s, l, i.rxp[c]));
                                        i = i._next
                                    }
                                    return {
                                        proxy: p,
                                        end: d,
                                        firstMPT: l,
                                        pt: h
                                    }
                                }, X.CSSPropTween = function(t, e, i, r, o, s, c, l, h, u, p) {
                                    this.t = t, this.p = e, this.s = i, this.c = r, this.n = c || e, t instanceof wt || a.push(this.n), this.r = l ? "function" == typeof l ? l : Math.round : l, this.type = s || 0, h && (this.pr = h, n = !0), this.b = void 0 === u ? i : u, this.e = void 0 === p ? i + r : p, o && (this._next = o, o._prev = this)
                                }),
                                Mt = function(t, e, n, i, r, o) {
                                    var a = new wt(t, e, n, i - n, r, -1, o);
                                    return a.b = n, a.e = a.xs0 = i, a
                                },
                                Tt = s.parseComplex = function(t, e, n, i, r, o, a, c, l, h) {
                                    n = n || o || "", "function" == typeof i && (i = i(y, g)), a = new wt(t, e, 0, 0, a, h ? 2 : 1, null, !1, c, n, i), i += "", r && yt.test(i + n) && (i = [n, i], s.colorStringFilter(i), n = i[0], i = i[1]);
                                    var p, d, f, m, v, b, w, M, T, E, S, A, P, L = n.split(", ").join(",").split(" "),
                                        R = i.split(", ").join(",").split(" "),
                                        C = L.length,
                                        O = !1 !== u;
                                    for (-1 === i.indexOf(",") && -1 === n.indexOf(",") || (-1 !== (i + n).indexOf("rgb") || -1 !== (i + n).indexOf("hsl") ? (L = L.join(" ").replace(B, ", ").split(" "), R = R.join(" ").replace(B, ", ").split(" ")) : (L = L.join(" ").split(",").join(", ").split(" "), R = R.join(" ").split(",").join(", ").split(" ")), C = L.length), C !== R.length && (C = (L = (o || "").split(" ")).length), a.plugin = l, a.setRatio = h, yt.lastIndex = 0, p = 0; p < C; p++)
                                        if (m = L[p], v = R[p] + "", (M = parseFloat(m)) || 0 === M) a.appendXtra("", M, ut(v, M), v.replace(x, ""), !(!O || -1 === v.indexOf("px")) && Math.round, !0);
                                        else if (r && yt.test(m)) A = ")" + ((A = v.indexOf(")") + 1) ? v.substr(A) : ""), P = -1 !== v.indexOf("hsl") && Y, E = v, m = vt(m, P), v = vt(v, P), (T = m.length + v.length > 6) && !Y && 0 === v[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[p]).join("transparent")) : (Y || (T = !1), P ? a.appendXtra(E.substr(0, E.indexOf("hsl")) + (T ? "hsla(" : "hsl("), m[0], ut(v[0], m[0]), ",", !1, !0).appendXtra("", m[1], ut(v[1], m[1]), "%,", !1).appendXtra("", m[2], ut(v[2], m[2]), T ? "%," : "%" + A, !1) : a.appendXtra(E.substr(0, E.indexOf("rgb")) + (T ? "rgba(" : "rgb("), m[0], v[0] - m[0], ",", Math.round, !0).appendXtra("", m[1], v[1] - m[1], ",", Math.round).appendXtra("", m[2], v[2] - m[2], T ? "," : A, Math.round), T && (m = m.length < 4 ? 1 : m[3], a.appendXtra("", m, (v.length < 4 ? 1 : v[3]) - m, A, !1))), yt.lastIndex = 0;
                                    else if (b = m.match(_)) {
                                        if (!(w = v.match(x)) || w.length !== b.length) return a;
                                        for (f = 0, d = 0; d < b.length; d++) S = b[d], E = m.indexOf(S, f), a.appendXtra(m.substr(f, E - f), Number(S), ut(w[d], S), "", !(!O || "px" !== m.substr(E + S.length, 2)) && Math.round, 0 === d), f = E + S.length;
                                        a["xs" + a.l] += m.substr(f)
                                    } else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + v : v;
                                    if (-1 !== i.indexOf("=") && a.data) {
                                        for (A = a.xs0 + a.data.s, p = 1; p < a.l; p++) A += a["xs" + p] + a.data["xn" + p];
                                        a.e = A + a["xs" + p]
                                    }
                                    return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                                },
                                Et = 9;
                            for ((h = wt.prototype).l = h.pr = 0; --Et > 0;) h["xn" + Et] = 0, h["xs" + Et] = "";
                            h.xs0 = "", h._next = h._prev = h.xfirst = h.data = h.plugin = h.setRatio = h.rxp = null, h.appendXtra = function(t, e, n, i, r, o) {
                                var a = this,
                                    s = a.l;
                                return a["xs" + s] += o && (s || a["xs" + s]) ? " " + t : t || "", n || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = i || "", s > 0 ? (a.data["xn" + s] = e + n, a.rxp["xn" + s] = r, a["xn" + s] = e, a.plugin || (a.xfirst = new wt(a, "xn" + s, e, n, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                                    s: e + n
                                }, a.rxp = {}, a.s = e, a.c = n, a.r = r, a)) : (a["xs" + s] += e + (i || ""), a)
                            };
                            var St = function(t, e) {
                                    e = e || {}, this.p = e.prefix && $(t) || t, l[t] = l[this.p] = this, this.format = e.formatter || _t(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.allowFunc = e.allowFunc, this.pr = e.priority || 0
                                },
                                At = X._registerComplexSpecialProp = function(t, e, n) {
                                    "object" != typeof e && (e = {
                                        parser: n
                                    });
                                    var i, r = t.split(","),
                                        o = e.defaultValue;
                                    for (n = n || [o], i = 0; i < r.length; i++) e.prefix = 0 === i && e.prefix, e.defaultValue = n[i] || o, new St(r[i], e)
                                },
                                Pt = X._registerPluginProp = function(t) {
                                    if (!l[t]) {
                                        var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                                        At(t, {
                                            parser: function(t, n, i, r, o, a, s) {
                                                var h = c.com.greensock.plugins[e];
                                                return h ? (h._cssRegister(), l[i].parse(t, n, i, r, o, a, s)) : (J("Error: " + e + " js file not loaded."), o)
                                            }
                                        })
                                    }
                                };
                            (h = St.prototype).parseComplex = function(t, e, n, i, r, o) {
                                var a, s, c, l, h, u, p = this.keyword;
                                if (this.multi && (B.test(n) || B.test(e) ? (s = e.replace(B, "|").split("|"), c = n.replace(B, "|").split("|")) : p && (s = [e], c = [n])), c) {
                                    for (l = c.length > s.length ? c.length : s.length, a = 0; a < l; a++) e = s[a] = s[a] || this.dflt, n = c[a] = c[a] || this.dflt, p && (h = e.indexOf(p)) !== (u = n.indexOf(p)) && (-1 === u ? s[a] = s[a].split(p).join("") : -1 === h && (s[a] += " " + p));
                                    e = s.join(", "), n = c.join(", ")
                                }
                                return Tt(t, this.p, e, n, this.clrs, this.dflt, i, this.pr, r, o)
                            }, h.parse = function(t, e, n, i, r, a, s) {
                                return this.parseComplex(t.style, this.format(nt(t, this.p, o, !1, this.dflt)), this.format(e), r, a)
                            }, s.registerSpecialProp = function(t, e, n) {
                                At(t, {
                                    parser: function(t, i, r, o, a, s, c) {
                                        var l = new wt(t, r, 0, 0, a, 2, r, !1, n);
                                        return l.plugin = s, l.setRatio = e(t, i, o._tween, r), l
                                    },
                                    priority: n
                                })
                            }, s.useSVGTransformAttr = !0;
                            var Lt, Rt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                                Ct = $("transform"),
                                Ot = K + "transform",
                                It = $("transformOrigin"),
                                Dt = null !== $("perspective"),
                                Nt = X.Transform = function() {
                                    this.perspective = parseFloat(s.defaultTransformPerspective) || 0, this.force3D = !(!1 === s.defaultForce3D || !Dt) && (s.defaultForce3D || "auto")
                                },
                                Bt = r.SVGElement,
                                Ht = function(t, e, n) {
                                    var i, r = G.createElementNS("http://www.w3.org/2000/svg", t),
                                        o = /([a-z])([A-Z])/g;
                                    for (i in n) r.setAttributeNS(null, i.replace(o, "$1-$2").toLowerCase(), n[i]);
                                    return e.appendChild(r), r
                                },
                                Ft = G.documentElement || {},
                                kt = function() {
                                    var t, e, n, i = v || /Android/i.test(q) && !r.chrome;
                                    return G.createElementNS && Ft.appendChild && !i && (t = Ht("svg", Ft), n = (e = Ht("rect", t, {
                                        width: 100,
                                        height: 50,
                                        x: 100
                                    })).getBoundingClientRect().width, e.style[It] = "50% 50%", e.style[Ct] = "scaleX(0.5)", i = n === e.getBoundingClientRect().width && !(f && Dt), Ft.removeChild(t)), i
                                }(),
                                Ut = function(t, e, n, i, r, o) {
                                    var a, c, l, h, u, p, d, f, m, v, g, y, _, x, b = t._gsTransform,
                                        w = Vt(t, !0);
                                    b && (_ = b.xOrigin, x = b.yOrigin), (!i || (a = i.split(" ")).length < 2) && (0 === (d = t.getBBox()).x && 0 === d.y && d.width + d.height === 0 && (d = {
                                        x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                                        y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                                        width: 0,
                                        height: 0
                                    }), a = [(-1 !== (e = ht(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * d.width : parseFloat(e[0])) + d.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * d.height : parseFloat(e[1])) + d.y]), n.xOrigin = h = parseFloat(a[0]), n.yOrigin = u = parseFloat(a[1]), i && w !== jt && (p = w[0], d = w[1], f = w[2], m = w[3], v = w[4], g = w[5], (y = p * m - d * f) && (c = h * (m / y) + u * (-f / y) + (f * g - m * v) / y, l = h * (-d / y) + u * (p / y) - (p * g - d * v) / y, h = n.xOrigin = a[0] = c, u = n.yOrigin = a[1] = l)), b && (o && (n.xOffset = b.xOffset, n.yOffset = b.yOffset, b = n), r || !1 !== r && !1 !== s.defaultSmoothOrigin ? (c = h - _, l = u - x, b.xOffset += c * w[0] + l * w[2] - c, b.yOffset += c * w[1] + l * w[3] - l) : b.xOffset = b.yOffset = 0), o || t.setAttribute("data-svg-origin", a.join(" "))
                                },
                                zt = function(t) {
                                    var e, n = j("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                        i = this.parentNode,
                                        r = this.nextSibling,
                                        o = this.style.cssText;
                                    if (Ft.appendChild(n), n.appendChild(this), this.style.display = "block", t) try {
                                        e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = zt
                                    } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
                                    return r ? i.insertBefore(this, r) : i.appendChild(this), Ft.removeChild(n), this.style.cssText = o, e
                                },
                                Gt = function(t) {
                                    return !(!Bt || !t.getCTM || t.parentNode && !t.ownerSVGElement || ! function(t) {
                                        try {
                                            return t.getBBox()
                                        } catch (e) {
                                            return zt.call(t, !0)
                                        }
                                    }(t))
                                },
                                jt = [1, 0, 0, 1, 0, 0],
                                Vt = function(t, e) {
                                    var n, i, r, o, a, s, c, l = t._gsTransform || new Nt,
                                        h = t.style;
                                    if (Ct ? i = nt(t, Ot, null, !0) : t.currentStyle && (i = (i = t.currentStyle.filter.match(D)) && 4 === i.length ? [i[0].substr(4), Number(i[2].substr(4)), Number(i[1].substr(4)), i[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), n = !i || "none" === i || "matrix(1, 0, 0, 1, 0, 0)" === i, Ct && n && !t.offsetParent && t !== Ft && (o = h.display, h.display = "block", (c = t.parentNode) && t.offsetParent || (a = 1, s = t.nextSibling, Ft.appendChild(t)), n = !(i = nt(t, Ot, null, !0)) || "none" === i || "matrix(1, 0, 0, 1, 0, 0)" === i, o ? h.display = o : Zt(h, "display"), a && (s ? c.insertBefore(t, s) : c ? c.appendChild(t) : Ft.removeChild(t))), (l.svg || t.getCTM && Gt(t)) && (n && -1 !== (h[Ct] + "").indexOf("matrix") && (i = h[Ct], n = 0), r = t.getAttribute("transform"), n && r && (i = "matrix(" + (r = t.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", n = 0)), n) return jt;
                                    for (r = (i || "").match(_) || [], Et = r.length; --Et > -1;) o = Number(r[Et]), r[Et] = (a = o - (o |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + o : o;
                                    return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                                },
                                Wt = X.getTransform = function(t, n, i, r) {
                                    if (t._gsTransform && i && !r) return t._gsTransform;
                                    var o, a, c, l, h, u, p = i && t._gsTransform || new Nt,
                                        d = p.scaleX < 0,
                                        f = Dt && (parseFloat(nt(t, It, n, !1, "0 0 0").split(" ")[2]) || p.zOrigin) || 0,
                                        m = parseFloat(s.defaultTransformPerspective) || 0;
                                    if (p.svg = !(!t.getCTM || !Gt(t)), p.svg && (Ut(t, nt(t, It, n, !1, "50% 50%") + "", p, t.getAttribute("data-svg-origin")), Lt = s.useSVGTransformAttr || kt), (o = Vt(t)) !== jt) {
                                        if (16 === o.length) {
                                            var v, g, y, _, x, b = o[0],
                                                w = o[1],
                                                M = o[2],
                                                T = o[3],
                                                E = o[4],
                                                S = o[5],
                                                A = o[6],
                                                P = o[7],
                                                L = o[8],
                                                R = o[9],
                                                C = o[10],
                                                O = o[12],
                                                I = o[13],
                                                D = o[14],
                                                N = o[11],
                                                B = Math.atan2(A, C);
                                            p.zOrigin && (O = L * (D = -p.zOrigin) - o[12], I = R * D - o[13], D = C * D + p.zOrigin - o[14]), p.rotationX = B * k, B && (v = E * (_ = Math.cos(-B)) + L * (x = Math.sin(-B)), g = S * _ + R * x, y = A * _ + C * x, L = E * -x + L * _, R = S * -x + R * _, C = A * -x + C * _, N = P * -x + N * _, E = v, S = g, A = y), B = Math.atan2(-M, C), p.rotationY = B * k, B && (g = w * (_ = Math.cos(-B)) - R * (x = Math.sin(-B)), y = M * _ - C * x, R = w * x + R * _, C = M * x + C * _, N = T * x + N * _, b = v = b * _ - L * x, w = g, M = y), B = Math.atan2(w, b), p.rotation = B * k, B && (v = b * (_ = Math.cos(B)) + w * (x = Math.sin(B)), g = E * _ + S * x, y = L * _ + R * x, w = w * _ - b * x, S = S * _ - E * x, R = R * _ - L * x, b = v, E = g, L = y), p.rotationX && Math.abs(p.rotationX) + Math.abs(p.rotation) > 359.9 && (p.rotationX = p.rotation = 0, p.rotationY = 180 - p.rotationY), B = Math.atan2(E, S), p.scaleX = (1e5 * Math.sqrt(b * b + w * w + M * M) + .5 | 0) / 1e5, p.scaleY = (1e5 * Math.sqrt(S * S + A * A) + .5 | 0) / 1e5, p.scaleZ = (1e5 * Math.sqrt(L * L + R * R + C * C) + .5 | 0) / 1e5, b /= p.scaleX, E /= p.scaleY, w /= p.scaleX, S /= p.scaleY, Math.abs(B) > 2e-5 ? (p.skewX = B * k, E = 0, "simple" !== p.skewType && (p.scaleY *= 1 / Math.cos(B))) : p.skewX = 0, p.perspective = N ? 1 / (N < 0 ? -N : N) : 0, p.x = O, p.y = I, p.z = D, p.svg && (p.x -= p.xOrigin - (p.xOrigin * b - p.yOrigin * E), p.y -= p.yOrigin - (p.yOrigin * w - p.xOrigin * S))
                                        } else if (!Dt || r || !o.length || p.x !== o[4] || p.y !== o[5] || !p.rotationX && !p.rotationY) {
                                            var H = o.length >= 6,
                                                F = H ? o[0] : 1,
                                                U = o[1] || 0,
                                                z = o[2] || 0,
                                                G = H ? o[3] : 1;
                                            p.x = o[4] || 0, p.y = o[5] || 0, c = Math.sqrt(F * F + U * U), l = Math.sqrt(G * G + z * z), h = F || U ? Math.atan2(U, F) * k : p.rotation || 0, u = z || G ? Math.atan2(z, G) * k + h : p.skewX || 0, p.scaleX = c, p.scaleY = l, p.rotation = h, p.skewX = u, Dt && (p.rotationX = p.rotationY = p.z = 0, p.perspective = m, p.scaleZ = 1), p.svg && (p.x -= p.xOrigin - (p.xOrigin * F + p.yOrigin * z), p.y -= p.yOrigin - (p.xOrigin * U + p.yOrigin * G))
                                        }
                                        for (a in Math.abs(p.skewX) > 90 && Math.abs(p.skewX) < 270 && (d ? (p.scaleX *= -1, p.skewX += p.rotation <= 0 ? 180 : -180, p.rotation += p.rotation <= 0 ? 180 : -180) : (p.scaleY *= -1, p.skewX += p.skewX <= 0 ? 180 : -180)), p.zOrigin = f, p) p[a] < 2e-5 && p[a] > -2e-5 && (p[a] = 0)
                                    }
                                    return i && (t._gsTransform = p, p.svg && (Lt && t.style[Ct] ? e.delayedCall(.001, function() {
                                        Zt(t.style, Ct)
                                    }) : !Lt && t.getAttribute("transform") && e.delayedCall(.001, function() {
                                        t.removeAttribute("transform")
                                    }))), p
                                },
                                Xt = function(t) {
                                    var e, n, i = this.data,
                                        r = -i.rotation * F,
                                        o = r + i.skewX * F,
                                        a = (Math.cos(r) * i.scaleX * 1e5 | 0) / 1e5,
                                        s = (Math.sin(r) * i.scaleX * 1e5 | 0) / 1e5,
                                        c = (Math.sin(o) * -i.scaleY * 1e5 | 0) / 1e5,
                                        l = (Math.cos(o) * i.scaleY * 1e5 | 0) / 1e5,
                                        h = this.t.style,
                                        u = this.t.currentStyle;
                                    if (u) {
                                        n = s, s = -c, c = -n, e = u.filter, h.filter = "";
                                        var p, d, f = this.t.offsetWidth,
                                            m = this.t.offsetHeight,
                                            g = "absolute" !== u.position,
                                            y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + s + ", M21=" + c + ", M22=" + l,
                                            _ = i.x + f * i.xPercent / 100,
                                            x = i.y + m * i.yPercent / 100;
                                        if (null != i.ox && (_ += (p = (i.oxp ? f * i.ox * .01 : i.ox) - f / 2) - (p * a + (d = (i.oyp ? m * i.oy * .01 : i.oy) - m / 2) * s), x += d - (p * c + d * l)), y += g ? ", Dx=" + ((p = f / 2) - (p * a + (d = m / 2) * s) + _) + ", Dy=" + (d - (p * c + d * l) + x) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? h.filter = e.replace(N, y) : h.filter = y + " " + e, 0 !== t && 1 !== t || 1 === a && 0 === s && 0 === c && 1 === l && (g && -1 === y.indexOf("Dx=0, Dy=0") || E.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && h.removeAttribute("filter")), !g) {
                                            var b, w, M, S = v < 8 ? 1 : -1;
                                            for (p = i.ieOffsetX || 0, d = i.ieOffsetY || 0, i.ieOffsetX = Math.round((f - ((a < 0 ? -a : a) * f + (s < 0 ? -s : s) * m)) / 2 + _), i.ieOffsetY = Math.round((m - ((l < 0 ? -l : l) * m + (c < 0 ? -c : c) * f)) / 2 + x), Et = 0; Et < 4; Et++) M = (n = -1 !== (b = u[w = ct[Et]]).indexOf("px") ? parseFloat(b) : it(this.t, w, parseFloat(b), b.replace(T, "")) || 0) !== i[w] ? Et < 2 ? -i.ieOffsetX : -i.ieOffsetY : Et < 2 ? p - i.ieOffsetX : d - i.ieOffsetY, h[w] = (i[w] = Math.round(n - M * (0 === Et || 2 === Et ? 1 : S))) + "px"
                                        }
                                    }
                                },
                                qt = X.set3DTransformRatio = X.setTransformRatio = function(t) {
                                    var e, n, i, r, o, a, s, c, l, h, u, p, d, m, v, g, y, _, x, b, w, M = this.data,
                                        T = this.t.style,
                                        E = M.rotation,
                                        S = M.rotationX,
                                        A = M.rotationY,
                                        P = M.scaleX,
                                        L = M.scaleY,
                                        R = M.scaleZ,
                                        C = M.x,
                                        O = M.y,
                                        I = M.z,
                                        D = M.svg,
                                        N = M.perspective,
                                        B = M.force3D,
                                        H = M.skewY,
                                        k = M.skewX;
                                    if (H && (k += H, E += H), !((1 !== t && 0 !== t || "auto" !== B || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && B || I || N || A || S || 1 !== R) || Lt && D || !Dt) E || k || D ? (E *= F, b = k * F, w = 1e5, n = Math.cos(E) * P, o = Math.sin(E) * P, i = Math.sin(E - b) * -L, a = Math.cos(E - b) * L, b && "simple" === M.skewType && (e = Math.tan(b - H * F), i *= e = Math.sqrt(1 + e * e), a *= e, H && (e = Math.tan(H * F), n *= e = Math.sqrt(1 + e * e), o *= e)), D && (C += M.xOrigin - (M.xOrigin * n + M.yOrigin * i) + M.xOffset, O += M.yOrigin - (M.xOrigin * o + M.yOrigin * a) + M.yOffset, Lt && (M.xPercent || M.yPercent) && (v = this.t.getBBox(), C += .01 * M.xPercent * v.width, O += .01 * M.yPercent * v.height), C < (v = 1e-6) && C > -v && (C = 0), O < v && O > -v && (O = 0)), x = (n * w | 0) / w + "," + (o * w | 0) / w + "," + (i * w | 0) / w + "," + (a * w | 0) / w + "," + C + "," + O + ")", D && Lt ? this.t.setAttribute("transform", "matrix(" + x) : T[Ct] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + x) : T[Ct] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + P + ",0,0," + L + "," + C + "," + O + ")";
                                    else {
                                        if (f && (P < (v = 1e-4) && P > -v && (P = R = 2e-5), L < v && L > -v && (L = R = 2e-5), !N || M.z || M.rotationX || M.rotationY || (N = 0)), E || k) E *= F, g = n = Math.cos(E), y = o = Math.sin(E), k && (E -= k * F, g = Math.cos(E), y = Math.sin(E), "simple" === M.skewType && (e = Math.tan((k - H) * F), g *= e = Math.sqrt(1 + e * e), y *= e, M.skewY && (e = Math.tan(H * F), n *= e = Math.sqrt(1 + e * e), o *= e))), i = -y, a = g;
                                        else {
                                            if (!(A || S || 1 !== R || N || D)) return void(T[Ct] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) translate3d(" : "translate3d(") + C + "px," + O + "px," + I + "px)" + (1 !== P || 1 !== L ? " scale(" + P + "," + L + ")" : ""));
                                            n = a = 1, i = o = 0
                                        }
                                        h = 1, r = s = c = l = u = p = 0, d = N ? -1 / N : 0, m = M.zOrigin, v = 1e-6, ",", "0", (E = A * F) && (g = Math.cos(E), c = -(y = Math.sin(E)), u = d * -y, r = n * y, s = o * y, h = g, d *= g, n *= g, o *= g), (E = S * F) && (e = i * (g = Math.cos(E)) + r * (y = Math.sin(E)), _ = a * g + s * y, l = h * y, p = d * y, r = i * -y + r * g, s = a * -y + s * g, h *= g, d *= g, i = e, a = _), 1 !== R && (r *= R, s *= R, h *= R, d *= R), 1 !== L && (i *= L, a *= L, l *= L, p *= L), 1 !== P && (n *= P, o *= P, c *= P, u *= P), (m || D) && (m && (C += r * -m, O += s * -m, I += h * -m + m), D && (C += M.xOrigin - (M.xOrigin * n + M.yOrigin * i) + M.xOffset, O += M.yOrigin - (M.xOrigin * o + M.yOrigin * a) + M.yOffset), C < v && C > -v && (C = "0"), O < v && O > -v && (O = "0"), I < v && I > -v && (I = 0)), x = M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix3d(" : "matrix3d(", x += (n < v && n > -v ? "0" : n) + "," + (o < v && o > -v ? "0" : o) + "," + (c < v && c > -v ? "0" : c), x += "," + (u < v && u > -v ? "0" : u) + "," + (i < v && i > -v ? "0" : i) + "," + (a < v && a > -v ? "0" : a), S || A || 1 !== R ? (x += "," + (l < v && l > -v ? "0" : l) + "," + (p < v && p > -v ? "0" : p) + "," + (r < v && r > -v ? "0" : r), x += "," + (s < v && s > -v ? "0" : s) + "," + (h < v && h > -v ? "0" : h) + "," + (d < v && d > -v ? "0" : d) + ",") : x += ",0,0,0,0,1,0,", x += C + "," + O + "," + I + "," + (N ? 1 + -I / N : 1) + ")", T[Ct] = x
                                    }
                                };
                            (h = Nt.prototype).x = h.y = h.z = h.skewX = h.skewY = h.rotation = h.rotationX = h.rotationY = h.zOrigin = h.xPercent = h.yPercent = h.xOffset = h.yOffset = 0, h.scaleX = h.scaleY = h.scaleZ = 1, At("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                                parser: function(t, e, n, i, r, a, c) {
                                    if (i._lastParsedTransform === c) return r;
                                    i._lastParsedTransform = c;
                                    var l = c.scale && "function" == typeof c.scale ? c.scale : 0;
                                    l && (c.scale = l(y, t));
                                    var h, u, p, d, f, m, v, _, x, b = t._gsTransform,
                                        w = t.style,
                                        M = Rt.length,
                                        T = c,
                                        E = {},
                                        S = Wt(t, o, !0, T.parseTransform),
                                        A = T.transform && ("function" == typeof T.transform ? T.transform(y, g) : T.transform);
                                    if (S.skewType = T.skewType || S.skewType || s.defaultSkewType, i._transform = S, "rotationZ" in T && (T.rotation = T.rotationZ), A && "string" == typeof A && Ct)(u = V.style)[Ct] = A, u.display = "block", u.position = "absolute", -1 !== A.indexOf("%") && (u.width = nt(t, "width"), u.height = nt(t, "height")), G.body.appendChild(V), h = Wt(V, null, !1), "simple" === S.skewType && (h.scaleY *= Math.cos(h.skewX * F)), S.svg && (m = S.xOrigin, v = S.yOrigin, h.x -= S.xOffset, h.y -= S.yOffset, (T.transformOrigin || T.svgOrigin) && (A = {}, Ut(t, ht(T.transformOrigin), A, T.svgOrigin, T.smoothOrigin, !0), m = A.xOrigin, v = A.yOrigin, h.x -= A.xOffset - S.xOffset, h.y -= A.yOffset - S.yOffset), (m || v) && (_ = Vt(V, !0), h.x -= m - (m * _[0] + v * _[2]), h.y -= v - (m * _[1] + v * _[3]))), G.body.removeChild(V), h.perspective || (h.perspective = S.perspective), null != T.xPercent && (h.xPercent = pt(T.xPercent, S.xPercent)), null != T.yPercent && (h.yPercent = pt(T.yPercent, S.yPercent));
                                    else if ("object" == typeof T) {
                                        if (h = {
                                                scaleX: pt(null != T.scaleX ? T.scaleX : T.scale, S.scaleX),
                                                scaleY: pt(null != T.scaleY ? T.scaleY : T.scale, S.scaleY),
                                                scaleZ: pt(T.scaleZ, S.scaleZ),
                                                x: pt(T.x, S.x),
                                                y: pt(T.y, S.y),
                                                z: pt(T.z, S.z),
                                                xPercent: pt(T.xPercent, S.xPercent),
                                                yPercent: pt(T.yPercent, S.yPercent),
                                                perspective: pt(T.transformPerspective, S.perspective)
                                            }, null != (f = T.directionalRotation))
                                            if ("object" == typeof f)
                                                for (u in f) T[u] = f[u];
                                            else T.rotation = f;
                                        "string" == typeof T.x && -1 !== T.x.indexOf("%") && (h.x = 0, h.xPercent = pt(T.x, S.xPercent)), "string" == typeof T.y && -1 !== T.y.indexOf("%") && (h.y = 0, h.yPercent = pt(T.y, S.yPercent)), h.rotation = dt("rotation" in T ? T.rotation : "shortRotation" in T ? T.shortRotation + "_short" : S.rotation, S.rotation, "rotation", E), Dt && (h.rotationX = dt("rotationX" in T ? T.rotationX : "shortRotationX" in T ? T.shortRotationX + "_short" : S.rotationX || 0, S.rotationX, "rotationX", E), h.rotationY = dt("rotationY" in T ? T.rotationY : "shortRotationY" in T ? T.shortRotationY + "_short" : S.rotationY || 0, S.rotationY, "rotationY", E)), h.skewX = dt(T.skewX, S.skewX), h.skewY = dt(T.skewY, S.skewY)
                                    }
                                    for (Dt && null != T.force3D && (S.force3D = T.force3D, d = !0), (p = S.force3D || S.z || S.rotationX || S.rotationY || h.z || h.rotationX || h.rotationY || h.perspective) || null == T.scale || (h.scaleZ = 1); --M > -1;)((A = h[x = Rt[M]] - S[x]) > 1e-6 || A < -1e-6 || null != T[x] || null != U[x]) && (d = !0, r = new wt(S, x, S[x], A, r), x in E && (r.e = E[x]), r.xs0 = 0, r.plugin = a, i._overwriteProps.push(r.n));
                                    return A = "function" == typeof T.transformOrigin ? T.transformOrigin(y, g) : T.transformOrigin, S.svg && (A || T.svgOrigin) && (m = S.xOffset, v = S.yOffset, Ut(t, ht(A), h, T.svgOrigin, T.smoothOrigin), r = Mt(S, "xOrigin", (b ? S : h).xOrigin, h.xOrigin, r, "transformOrigin"), r = Mt(S, "yOrigin", (b ? S : h).yOrigin, h.yOrigin, r, "transformOrigin"), m === S.xOffset && v === S.yOffset || (r = Mt(S, "xOffset", b ? m : S.xOffset, S.xOffset, r, "transformOrigin"), r = Mt(S, "yOffset", b ? v : S.yOffset, S.yOffset, r, "transformOrigin")), A = "0px 0px"), (A || Dt && p && S.zOrigin) && (Ct ? (d = !0, x = It, A || (A = (A = (nt(t, x, o, !1, "50% 50%") + "").split(" "))[0] + " " + A[1] + " " + S.zOrigin + "px"), A += "", (r = new wt(w, x, 0, 0, r, -1, "transformOrigin")).b = w[x], r.plugin = a, Dt ? (u = S.zOrigin, A = A.split(" "), S.zOrigin = (A.length > 2 ? parseFloat(A[2]) : u) || 0, r.xs0 = r.e = A[0] + " " + (A[1] || "50%") + " 0px", (r = new wt(S, "zOrigin", 0, 0, r, -1, r.n)).b = u, r.xs0 = r.e = S.zOrigin) : r.xs0 = r.e = A) : ht(A + "", S)), d && (i._transformType = S.svg && Lt || !p && 3 !== this._transformType ? 2 : 3), l && (c.scale = l), r
                                },
                                allowFunc: !0,
                                prefix: !0
                            }), At("boxShadow", {
                                defaultValue: "0px 0px 0px 0px #999",
                                prefix: !0,
                                color: !0,
                                multi: !0,
                                keyword: "inset"
                            }), At("clipPath", {
                                defaultValue: "inset(0%)",
                                prefix: !0,
                                multi: !0,
                                formatter: _t("inset(0% 0% 0% 0%)", !1, !0)
                            }), At("borderRadius", {
                                defaultValue: "0px",
                                parser: function(t, e, n, r, a, s) {
                                    e = this.format(e);
                                    var c, l, h, u, p, d, f, m, v, g, y, _, x, b, w, M, T = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                        E = t.style;
                                    for (v = parseFloat(t.offsetWidth), g = parseFloat(t.offsetHeight), c = e.split(" "), l = 0; l < T.length; l++) this.p.indexOf("border") && (T[l] = $(T[l])), -1 !== (p = u = nt(t, T[l], o, !1, "0px")).indexOf(" ") && (p = (u = p.split(" "))[0], u = u[1]), d = h = c[l], f = parseFloat(p), _ = p.substr((f + "").length), (x = "=" === d.charAt(1)) ? (m = parseInt(d.charAt(0) + "1", 10), d = d.substr(2), m *= parseFloat(d), y = d.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(d), y = d.substr((m + "").length)), "" === y && (y = i[n] || _), y !== _ && (b = it(t, "borderLeft", f, _), w = it(t, "borderTop", f, _), "%" === y ? (p = b / v * 100 + "%", u = w / g * 100 + "%") : "em" === y ? (p = b / (M = it(t, "borderLeft", 1, "em")) + "em", u = w / M + "em") : (p = b + "px", u = w + "px"), x && (d = parseFloat(p) + m + y, h = parseFloat(u) + m + y)), a = Tt(E, T[l], p + " " + u, d + " " + h, !1, "0px", a);
                                    return a
                                },
                                prefix: !0,
                                formatter: _t("0px 0px 0px 0px", !1, !0)
                            }), At("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                                defaultValue: "0px",
                                parser: function(t, e, n, i, r, a) {
                                    return Tt(t.style, n, this.format(nt(t, n, o, !1, "0px 0px")), this.format(e), !1, "0px", r)
                                },
                                prefix: !0,
                                formatter: _t("0px 0px", !1, !0)
                            }), At("backgroundPosition", {
                                defaultValue: "0 0",
                                parser: function(t, e, n, i, r, a) {
                                    var s, c, l, h, u, p, d = "background-position",
                                        f = o || et(t),
                                        m = this.format((f ? v ? f.getPropertyValue(d + "-x") + " " + f.getPropertyValue(d + "-y") : f.getPropertyValue(d) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                                        g = this.format(e);
                                    if (-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && g.split(",").length < 2 && (p = nt(t, "backgroundImage").replace(C, "")) && "none" !== p) {
                                        for (s = m.split(" "), c = g.split(" "), W.setAttribute("src", p), l = 2; --l > -1;)(h = -1 !== (m = s[l]).indexOf("%")) !== (-1 !== c[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - W.width : t.offsetHeight - W.height, s[l] = h ? parseFloat(m) / 100 * u + "px" : parseFloat(m) / u * 100 + "%");
                                        m = s.join(" ")
                                    }
                                    return this.parseComplex(t.style, m, g, r, a)
                                },
                                formatter: ht
                            }), At("backgroundSize", {
                                defaultValue: "0 0",
                                formatter: function(t) {
                                    return "co" === (t += "").substr(0, 2) ? t : ht(-1 === t.indexOf(" ") ? t + " " + t : t)
                                }
                            }), At("perspective", {
                                defaultValue: "0px",
                                prefix: !0
                            }), At("perspectiveOrigin", {
                                defaultValue: "50% 50%",
                                prefix: !0
                            }), At("transformStyle", {
                                prefix: !0
                            }), At("backfaceVisibility", {
                                prefix: !0
                            }), At("userSelect", {
                                prefix: !0
                            }), At("margin", {
                                parser: xt("marginTop,marginRight,marginBottom,marginLeft")
                            }), At("padding", {
                                parser: xt("paddingTop,paddingRight,paddingBottom,paddingLeft")
                            }), At("clip", {
                                defaultValue: "rect(0px,0px,0px,0px)",
                                parser: function(t, e, n, i, r, a) {
                                    var s, c, l;
                                    return v < 9 ? (c = t.currentStyle, l = v < 8 ? " " : ",", s = "rect(" + c.clipTop + l + c.clipRight + l + c.clipBottom + l + c.clipLeft + ")", e = this.format(e).split(",").join(l)) : (s = this.format(nt(t, this.p, o, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, r, a)
                                }
                            }), At("textShadow", {
                                defaultValue: "0px 0px 0px #999",
                                color: !0,
                                multi: !0
                            }), At("autoRound,strictUnits", {
                                parser: function(t, e, n, i, r) {
                                    return r
                                }
                            }), At("border", {
                                defaultValue: "0px solid #000",
                                parser: function(t, e, n, i, r, a) {
                                    var s = nt(t, "borderTopWidth", o, !1, "0px"),
                                        c = this.format(e).split(" "),
                                        l = c[0].replace(T, "");
                                    return "px" !== l && (s = parseFloat(s) / it(t, "borderTopWidth", 1, l) + l), this.parseComplex(t.style, this.format(s + " " + nt(t, "borderTopStyle", o, !1, "solid") + " " + nt(t, "borderTopColor", o, !1, "#000")), c.join(" "), r, a)
                                },
                                color: !0,
                                formatter: function(t) {
                                    var e = t.split(" ");
                                    return e[0] + " " + (e[1] || "solid") + " " + (t.match(yt) || ["#000"])[0]
                                }
                            }), At("borderWidth", {
                                parser: xt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                            }), At("float,cssFloat,styleFloat", {
                                parser: function(t, e, n, i, r, o) {
                                    var a = t.style,
                                        s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                                    return new wt(a, s, 0, 0, r, -1, n, !1, 0, a[s], e)
                                }
                            });
                            var Yt = function(t) {
                                var e, n = this.t,
                                    i = n.filter || nt(this.data, "filter") || "",
                                    r = this.s + this.c * t | 0;
                                100 === r && (-1 === i.indexOf("atrix(") && -1 === i.indexOf("radient(") && -1 === i.indexOf("oader(") ? (n.removeAttribute("filter"), e = !nt(this.data, "filter")) : (n.filter = i.replace(A, ""), e = !0)), e || (this.xn1 && (n.filter = i = i || "alpha(opacity=" + r + ")"), -1 === i.indexOf("pacity") ? 0 === r && this.xn1 || (n.filter = i + " alpha(opacity=" + r + ")") : n.filter = i.replace(E, "opacity=" + r))
                            };
                            At("opacity,alpha,autoAlpha", {
                                defaultValue: "1",
                                parser: function(t, e, n, i, r, a) {
                                    var s = parseFloat(nt(t, "opacity", o, !1, "1")),
                                        c = t.style,
                                        l = "autoAlpha" === n;
                                    return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s), l && 1 === s && "hidden" === nt(t, "visibility", o) && 0 !== e && (s = 0), Y ? r = new wt(c, "opacity", s, e - s, r) : ((r = new wt(c, "opacity", 100 * s, 100 * (e - s), r)).xn1 = l ? 1 : 0, c.zoom = 1, r.type = 2, r.b = "alpha(opacity=" + r.s + ")", r.e = "alpha(opacity=" + (r.s + r.c) + ")", r.data = t, r.plugin = a, r.setRatio = Yt), l && ((r = new wt(c, "visibility", 0, 0, r, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", i._overwriteProps.push(r.n), i._overwriteProps.push(n)), r
                                }
                            });
                            var Zt = function(t, e) {
                                    e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(L, "-$1").toLowerCase())) : t.removeAttribute(e))
                                },
                                Jt = function(t) {
                                    if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                                        this.t.setAttribute("class", 0 === t ? this.b : this.e);
                                        for (var e = this.data, n = this.t.style; e;) e.v ? n[e.p] = e.v : Zt(n, e.p), e = e._next;
                                        1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                    } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                                };
                            At("className", {
                                parser: function(t, e, i, r, a, s, c) {
                                    var l, h, u, p, d, f = t.getAttribute("class") || "",
                                        m = t.style.cssText;
                                    if ((a = r._classNamePT = new wt(t, i, 0, 0, a, 2)).setRatio = Jt, a.pr = -11, n = !0, a.b = f, h = ot(t, o), u = t._gsClassPT) {
                                        for (p = {}, d = u.data; d;) p[d.p] = 1, d = d._next;
                                        u.setRatio(1)
                                    }
                                    return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : f.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", a.e), l = at(t, h, ot(t), c, p), t.setAttribute("class", f), a.data = l.firstMPT, t.style.cssText !== m && (t.style.cssText = m), a = a.xfirst = r.parse(t, l.difs, a, s)
                                }
                            });
                            var Kt = function(t) {
                                if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                    var e, n, i, r, o, a = this.t.style,
                                        s = l.transform.parse;
                                    if ("all" === this.e) a.cssText = "", r = !0;
                                    else
                                        for (i = (e = this.e.split(" ").join("").split(",")).length; --i > -1;) n = e[i], l[n] && (l[n].parse === s ? r = !0 : n = "transformOrigin" === n ? It : l[n].p), Zt(a, n);
                                    r && (Zt(a, Ct), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                                }
                            };
                            for (At("clearProps", {
                                    parser: function(t, e, i, r, o) {
                                        return (o = new wt(t, i, 0, 0, o, 2)).setRatio = Kt, o.e = e, o.pr = -10, o.data = r._tween, n = !0, o
                                    }
                                }), h = "bezier,throwProps,physicsProps,physics2D".split(","), Et = h.length; Et--;) Pt(h[Et]);
                            (h = s.prototype)._firstPT = h._lastParsedTransform = h._transform = null, h._onInitTween = function(t, e, r, c) {
                                if (!t.nodeType) return !1;
                                this._target = g = t, this._tween = r, this._vars = e, y = c, u = e.autoRound, n = !1, i = e.suffixMap || s.suffixMap, o = et(t), a = this._overwriteProps;
                                var h, f, v, _, x, b, w, M, T, E = t.style;
                                if (p && "" === E.zIndex && ("auto" !== (h = nt(t, "zIndex", o)) && "" !== h || this._addLazySet(E, "zIndex", 0)), "string" == typeof e && (_ = E.cssText, h = ot(t, o), E.cssText = _ + ";" + e, h = at(t, h, ot(t)).difs, !Y && S.test(e) && (h.opacity = parseFloat(RegExp.$1)), e = h, E.cssText = _), e.className ? this._firstPT = f = l.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = f = this.parse(t, e, null), this._transformType) {
                                    for (T = 3 === this._transformType, Ct ? d && (p = !0, "" === E.zIndex && ("auto" !== (w = nt(t, "zIndex", o)) && "" !== w || this._addLazySet(E, "zIndex", 0)), m && this._addLazySet(E, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : E.zoom = 1, v = f; v && v._next;) v = v._next;
                                    M = new wt(t, "transform", 0, 0, null, 2), this._linkCSSP(M, null, v), M.setRatio = Ct ? qt : Xt, M.data = this._transform || Wt(t, o, !0), M.tween = r, M.pr = -1, a.pop()
                                }
                                if (n) {
                                    for (; f;) {
                                        for (b = f._next, v = _; v && v.pr > f.pr;) v = v._next;
                                        (f._prev = v ? v._prev : x) ? f._prev._next = f: _ = f, (f._next = v) ? v._prev = f : x = f, f = b
                                    }
                                    this._firstPT = _
                                }
                                return !0
                            }, h.parse = function(t, e, n, r) {
                                var a, s, c, h, p, d, f, m, v, _, x = t.style;
                                for (a in e) {
                                    if (d = e[a], s = l[a], "function" != typeof d || s && s.allowFunc || (d = d(y, g)), s) n = s.parse(t, d, a, this, n, r, e);
                                    else {
                                        if ("--" === a.substr(0, 2)) {
                                            this._tween._propLookup[a] = this._addTween.call(this._tween, t.style, "setProperty", et(t).getPropertyValue(a) + "", d + "", a, !1, a);
                                            continue
                                        }
                                        p = nt(t, a, o) + "", v = "string" == typeof d, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || v && P.test(d) ? (v || (d = ((d = vt(d)).length > 3 ? "rgba(" : "rgb(") + d.join(",") + ")"), n = Tt(x, a, p, d, !0, "transparent", n, 0, r)) : v && H.test(d) ? n = Tt(x, a, p, d, !0, null, n, 0, r) : (f = (c = parseFloat(p)) || 0 === c ? p.substr((c + "").length) : "", "" !== p && "auto" !== p || ("width" === a || "height" === a ? (c = lt(t, a, o), f = "px") : "left" === a || "top" === a ? (c = rt(t, a, o), f = "px") : (c = "opacity" !== a ? 0 : 1, f = "")), (_ = v && "=" === d.charAt(1)) ? (h = parseInt(d.charAt(0) + "1", 10), d = d.substr(2), h *= parseFloat(d), m = d.replace(T, "")) : (h = parseFloat(d), m = v ? d.replace(T, "") : ""), "" === m && (m = a in i ? i[a] : f), d = h || 0 === h ? (_ ? h + c : h) + m : e[a], f !== m && ("" === m && "lineHeight" !== a || (h || 0 === h) && c && (c = it(t, a, c, f), "%" === m ? (c /= it(t, a, 100, "%") / 100, !0 !== e.strictUnits && (p = c + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? c /= it(t, a, 1, m) : "px" !== m && (h = it(t, a, h, m), m = "px"), _ && (h || 0 === h) && (d = h + c + m))), _ && (h += c), !c && 0 !== c || !h && 0 !== h ? void 0 !== x[a] && (d || d + "" != "NaN" && null != d) ? (n = new wt(x, a, h || c || 0, 0, n, -1, a, !1, 0, p, d)).xs0 = "none" !== d || "display" !== a && -1 === a.indexOf("Style") ? d : p : J("invalid " + a + " tween value: " + e[a]) : (n = new wt(x, a, c, h - c, n, 0, a, !1 !== u && ("px" === m || "zIndex" === a), 0, p, d)).xs0 = m)
                                    }
                                    r && n && !n.plugin && (n.plugin = r)
                                }
                                return n
                            }, h.setRatio = function(t) {
                                var e, n, i, r = this._firstPT;
                                if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                    if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                                        for (; r;) {
                                            if (e = r.c * t + r.s, r.r ? e = r.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), r.type)
                                                if (1 === r.type)
                                                    if (2 === (i = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                                    else if (3 === i) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                            else if (4 === i) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                            else if (5 === i) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                            else {
                                                for (n = r.xs0 + e + r.xs1, i = 1; i < r.l; i++) n += r["xn" + i] + r["xs" + (i + 1)];
                                                r.t[r.p] = n
                                            } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                                            else r.t[r.p] = e + r.xs0;
                                            r = r._next
                                        } else
                                            for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                                    else
                                        for (; r;) {
                                            if (2 !== r.type)
                                                if (r.r && -1 !== r.type)
                                                    if (e = r.r(r.s + r.c), r.type) {
                                                        if (1 === r.type) {
                                                            for (i = r.l, n = r.xs0 + e + r.xs1, i = 1; i < r.l; i++) n += r["xn" + i] + r["xs" + (i + 1)];
                                                            r.t[r.p] = n
                                                        }
                                                    } else r.t[r.p] = e + r.xs0;
                                            else r.t[r.p] = r.e;
                                            else r.setRatio(t);
                                            r = r._next
                                        }
                            }, h._enableTransforms = function(t) {
                                this._transform = this._transform || Wt(this._target, o, !0), this._transformType = this._transform.svg && Lt || !t && 3 !== this._transformType ? 2 : 3
                            };
                            var Qt = function(t) {
                                this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                            };
                            h._addLazySet = function(t, e, n) {
                                var i = this._firstPT = new wt(t, e, 0, 0, this._firstPT, 2);
                                i.e = n, i.setRatio = Qt, i.data = this
                            }, h._linkCSSP = function(t, e, n, i) {
                                return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, i = !0), n ? n._next = t : i || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = n), t
                            }, h._mod = function(t) {
                                for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
                            }, h._kill = function(e) {
                                var n, i, r, o = e;
                                if (e.autoAlpha || e.alpha) {
                                    for (i in o = {}, e) o[i] = e[i];
                                    o.opacity = 1, o.autoAlpha && (o.visibility = 1)
                                }
                                for (e.className && (n = this._classNamePT) && ((r = n.xfirst) && r._prev ? this._linkCSSP(r._prev, n._next, r._prev._prev) : r === this._firstPT && (this._firstPT = n._next), n._next && this._linkCSSP(n._next, n._next._next, r._prev), this._classNamePT = null), n = this._firstPT; n;) n.plugin && n.plugin !== i && n.plugin._kill && (n.plugin._kill(e), i = n.plugin), n = n._next;
                                return t.prototype._kill.call(this, o)
                            };
                            var $t = function(t, e, n) {
                                var i, r, o, a;
                                if (t.slice)
                                    for (r = t.length; --r > -1;) $t(t[r], e, n);
                                else
                                    for (r = (i = t.childNodes).length; --r > -1;) a = (o = i[r]).type, o.style && (e.push(ot(o)), n && n.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || $t(o, e, n)
                            };
                            return s.cascadeTo = function(t, n, i) {
                                var r, o, a, s, c = e.to(t, n, i),
                                    l = [c],
                                    h = [],
                                    u = [],
                                    p = [],
                                    d = e._internals.reservedProps;
                                for (t = c._targets || c.target, $t(t, h, p), c.render(n, !0, !0), $t(t, u), c.render(0, !0, !0), c._enabled(!0), r = p.length; --r > -1;)
                                    if ((o = at(p[r], h[r], u[r])).firstMPT) {
                                        for (a in o = o.difs, i) d[a] && (o[a] = i[a]);
                                        for (a in s = {}, o) s[a] = h[r][a];
                                        l.push(e.fromTo(p[r], n, s, o))
                                    }
                                return l
                            }, t.activate([s]), s
                        }, !0),
                        function() {
                            var t = function(t) {
                                    var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                                    return function(n) {
                                        return (Math.round(n / t) * t * e | 0) / e
                                    }
                                },
                                e = function(t, e) {
                                    for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
                                },
                                n = r._gsDefine.plugin({
                                    propName: "roundProps",
                                    version: "1.7.0",
                                    priority: -1,
                                    API: 2,
                                    init: function(t, e, n) {
                                        return this._tween = n, !0
                                    }
                                }).prototype;
                            n._onInitAllProps = function() {
                                var n, i, r, o, a = this._tween,
                                    s = a.vars.roundProps,
                                    c = {},
                                    l = a._propLookup.roundProps;
                                if ("object" != typeof s || s.push)
                                    for ("string" == typeof s && (s = s.split(",")), r = s.length; --r > -1;) c[s[r]] = Math.round;
                                else
                                    for (o in s) c[o] = t(s[o]);
                                for (o in c)
                                    for (n = a._firstPT; n;) i = n._next, n.pg ? n.t._mod(c) : n.n === o && (2 === n.f && n.t ? e(n.t._firstPT, c[o]) : (this._add(n.t, o, n.s, n.c, c[o]), i && (i._prev = n._prev), n._prev ? n._prev._next = i : a._firstPT === n && (a._firstPT = i), n._next = n._prev = null, a._propLookup[o] = l)), n = i;
                                return !1
                            }, n._add = function(t, e, n, i, r) {
                                this._addTween(t, e, n, n + i, e, r || Math.round), this._overwriteProps.push(e)
                            }
                        }(), r._gsDefine.plugin({
                            propName: "attr",
                            API: 2,
                            version: "0.6.1",
                            init: function(t, e, n, i) {
                                var r, o;
                                if ("function" != typeof t.setAttribute) return !1;
                                for (r in e) "function" == typeof(o = e[r]) && (o = o(i, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r), this._overwriteProps.push(r);
                                return !0
                            }
                        }), r._gsDefine.plugin({
                            propName: "directionalRotation",
                            version: "0.3.1",
                            API: 2,
                            init: function(t, e, n, i) {
                                "object" != typeof e && (e = {
                                    rotation: e
                                }), this.finals = {};
                                var r, o, a, s, c, l, h = !0 === e.useRadians ? 2 * Math.PI : 360;
                                for (r in e) "useRadians" !== r && ("function" == typeof(s = e[r]) && (s = s(i, t)), o = (l = (s + "").split("_"))[0], a = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), c = (s = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - a, l.length && (-1 !== (o = l.join("_")).indexOf("short") && (c %= h) !== c % (h / 2) && (c = c < 0 ? c + h : c - h), -1 !== o.indexOf("_cw") && c < 0 ? c = (c + 9999999999 * h) % h - (c / h | 0) * h : -1 !== o.indexOf("ccw") && c > 0 && (c = (c - 9999999999 * h) % h - (c / h | 0) * h)), (c > 1e-6 || c < -1e-6) && (this._addTween(t, r, a, a + c, r), this._overwriteProps.push(r)));
                                return !0
                            },
                            set: function(t) {
                                var e;
                                if (1 !== t) this._super.setRatio.call(this, t);
                                else
                                    for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
                            }
                        })._autoCSS = !0, r._gsDefine("easing.Back", ["easing.Ease"], function(t) {
                            var e, n, i, o, a = r.GreenSockGlobals || r,
                                s = a.com.greensock,
                                c = 2 * Math.PI,
                                l = Math.PI / 2,
                                h = s._class,
                                u = function(e, n) {
                                    var i = h("easing." + e, function() {}, !0),
                                        r = i.prototype = new t;
                                    return r.constructor = i, r.getRatio = n, i
                                },
                                p = t.register || function() {},
                                d = function(t, e, n, i, r) {
                                    var o = h("easing." + t, {
                                        easeOut: new e,
                                        easeIn: new n,
                                        easeInOut: new i
                                    }, !0);
                                    return p(o, t), o
                                },
                                f = function(t, e, n) {
                                    this.t = t, this.v = e, n && (this.next = n, n.prev = this, this.c = n.v - e, this.gap = n.t - t)
                                },
                                m = function(e, n) {
                                    var i = h("easing." + e, function(t) {
                                            this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                                        }, !0),
                                        r = i.prototype = new t;
                                    return r.constructor = i, r.getRatio = n, r.config = function(t) {
                                        return new i(t)
                                    }, i
                                },
                                v = d("Back", m("BackOut", function(t) {
                                    return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                                }), m("BackIn", function(t) {
                                    return t * t * ((this._p1 + 1) * t - this._p1)
                                }), m("BackInOut", function(t) {
                                    return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                                })),
                                g = h("easing.SlowMo", function(t, e, n) {
                                    e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === n
                                }, !0),
                                y = g.prototype = new t;
                            return y.constructor = g, y.getRatio = function(t) {
                                var e = t + (.5 - t) * this._p;
                                return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                            }, g.ease = new g(.7, .7), y.config = g.config = function(t, e, n) {
                                return new g(t, e, n)
                            }, (y = (e = h("easing.SteppedEase", function(t, e) {
                                t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
                            }, !0)).prototype = new t).constructor = e, y.getRatio = function(t) {
                                return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
                            }, y.config = e.config = function(t, n) {
                                return new e(t, n)
                            }, (y = (n = h("easing.ExpoScaleEase", function(t, e, n) {
                                this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = n
                            }, !0)).prototype = new t).constructor = n, y.getRatio = function(t) {
                                return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
                            }, y.config = n.config = function(t, e, i) {
                                return new n(t, e, i)
                            }, (y = (i = h("easing.RoughEase", function(e) {
                                for (var n, i, r, o, a, s, c = (e = e || {}).taper || "none", l = [], h = 0, u = 0 | (e.points || 20), p = u, d = !1 !== e.randomize, m = !0 === e.clamp, v = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --p > -1;) n = d ? Math.random() : 1 / u * p, i = v ? v.getRatio(n) : n, r = "none" === c ? g : "out" === c ? (o = 1 - n) * o * g : "in" === c ? n * n * g : n < .5 ? (o = 2 * n) * o * .5 * g : (o = 2 * (1 - n)) * o * .5 * g, d ? i += Math.random() * r - .5 * r : p % 2 ? i += .5 * r : i -= .5 * r, m && (i > 1 ? i = 1 : i < 0 && (i = 0)), l[h++] = {
                                    x: n,
                                    y: i
                                };
                                for (l.sort(function(t, e) {
                                        return t.x - e.x
                                    }), s = new f(1, 1, null), p = u; --p > -1;) a = l[p], s = new f(a.x, a.y, s);
                                this._prev = new f(0, 0, 0 !== s.t ? s : s.next)
                            }, !0)).prototype = new t).constructor = i, y.getRatio = function(t) {
                                var e = this._prev;
                                if (t > e.t) {
                                    for (; e.next && t >= e.t;) e = e.next;
                                    e = e.prev
                                } else
                                    for (; e.prev && t <= e.t;) e = e.prev;
                                return this._prev = e, e.v + (t - e.t) / e.gap * e.c
                            }, y.config = function(t) {
                                return new i(t)
                            }, i.ease = new i, d("Bounce", u("BounceOut", function(t) {
                                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                            }), u("BounceIn", function(t) {
                                return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                            }), u("BounceInOut", function(t) {
                                var e = t < .5;
                                return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
                            })), d("Circ", u("CircOut", function(t) {
                                return Math.sqrt(1 - (t -= 1) * t)
                            }), u("CircIn", function(t) {
                                return -(Math.sqrt(1 - t * t) - 1)
                            }), u("CircInOut", function(t) {
                                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                            })), d("Elastic", (o = function(e, n, i) {
                                var r = h("easing." + e, function(t, e) {
                                        this._p1 = t >= 1 ? t : 1, this._p2 = (e || i) / (t < 1 ? t : 1), this._p3 = this._p2 / c * (Math.asin(1 / this._p1) || 0), this._p2 = c / this._p2
                                    }, !0),
                                    o = r.prototype = new t;
                                return o.constructor = r, o.getRatio = n, o.config = function(t, e) {
                                    return new r(t, e)
                                }, r
                            })("ElasticOut", function(t) {
                                return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
                            }, .3), o("ElasticIn", function(t) {
                                return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
                            }, .3), o("ElasticInOut", function(t) {
                                return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
                            }, .45)), d("Expo", u("ExpoOut", function(t) {
                                return 1 - Math.pow(2, -10 * t)
                            }), u("ExpoIn", function(t) {
                                return Math.pow(2, 10 * (t - 1)) - .001
                            }), u("ExpoInOut", function(t) {
                                return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                            })), d("Sine", u("SineOut", function(t) {
                                return Math.sin(t * l)
                            }), u("SineIn", function(t) {
                                return 1 - Math.cos(t * l)
                            }), u("SineInOut", function(t) {
                                return -.5 * (Math.cos(Math.PI * t) - 1)
                            })), h("easing.EaseLookup", {
                                find: function(e) {
                                    return t.map[e]
                                }
                            }, !0), p(a.SlowMo, "SlowMo", "ease,"), p(i, "RoughEase", "ease,"), p(e, "SteppedEase", "ease,"), v
                        }, !0)
                }), r._gsDefine && r._gsQueue.pop()(),
                function(n, r) {
                    "use strict";
                    var o = {},
                        a = n.document,
                        s = n.GreenSockGlobals = n.GreenSockGlobals || n,
                        c = s.TweenMax;
                    if (c) return void 0 !== t && t.exports && (t.exports = c), c;
                    var l, h, u, p, d, f = function(t) {
                            var e, n = t.split("."),
                                i = s;
                            for (e = 0; e < n.length; e++) i[n[e]] = i = i[n[e]] || {};
                            return i
                        },
                        m = f("com.greensock"),
                        v = function(t) {
                            var e, n = [],
                                i = t.length;
                            for (e = 0; e !== i; n.push(t[e++]));
                            return n
                        },
                        g = function() {},
                        y = function() {
                            var t = Object.prototype.toString,
                                e = t.call([]);
                            return function(n) {
                                return null != n && (n instanceof Array || "object" == typeof n && !!n.push && t.call(n) === e)
                            }
                        }(),
                        _ = {},
                        x = function(n, r, a, c) {
                            this.sc = _[n] ? _[n].sc : [], _[n] = this, this.gsClass = null, this.func = a;
                            var l = [];
                            this.check = function(h) {
                                for (var u, p, d, m, v = r.length, g = v; --v > -1;)(u = _[r[v]] || new x(r[v], [])).gsClass ? (l[v] = u.gsClass, g--) : h && u.sc.push(this);
                                if (0 === g && a) {
                                    if (d = (p = ("com.greensock." + n).split(".")).pop(), m = f(p.join("."))[d] = this.gsClass = a.apply(a, l), c)
                                        if (s[d] = o[d] = m, void 0 !== t && t.exports)
                                            if ("TweenMax" === n)
                                                for (v in t.exports = o.TweenMax = m, o) m[v] = o[v];
                                            else o.TweenMax && (o.TweenMax[d] = m);
                                    else void 0 === (i = function() {
                                        return m
                                    }.apply(e, [])) || (t.exports = i);
                                    for (v = 0; v < this.sc.length; v++) this.sc[v].check()
                                }
                            }, this.check(!0)
                        },
                        b = n._gsDefine = function(t, e, n, i) {
                            return new x(t, e, n, i)
                        },
                        w = m._class = function(t, e, n) {
                            return e = e || function() {}, b(t, [], function() {
                                return e
                            }, n), e
                        };
                    b.globals = s;
                    var M = [0, 0, 1, 1],
                        T = w("easing.Ease", function(t, e, n, i) {
                            this._func = t, this._type = n || 0, this._power = i || 0, this._params = e ? M.concat(e) : M
                        }, !0),
                        E = T.map = {},
                        S = T.register = function(t, e, n, i) {
                            for (var r, o, a, s, c = e.split(","), l = c.length, h = (n || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
                                for (o = c[l], r = i ? w("easing." + o, null, !0) : m.easing[o] || {}, a = h.length; --a > -1;) s = h[a], E[o + "." + s] = E[s + o] = r[s] = t.getRatio ? t : t[s] || new t
                        };
                    for ((u = T.prototype)._calcEnd = !1, u.getRatio = function(t) {
                            if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                            var e = this._type,
                                n = this._power,
                                i = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                            return 1 === n ? i *= i : 2 === n ? i *= i * i : 3 === n ? i *= i * i * i : 4 === n && (i *= i * i * i * i), 1 === e ? 1 - i : 2 === e ? i : t < .5 ? i / 2 : 1 - i / 2
                        }, h = (l = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --h > -1;) u = l[h] + ",Power" + h, S(new T(null, null, 1, h), u, "easeOut", !0), S(new T(null, null, 2, h), u, "easeIn" + (0 === h ? ",easeNone" : "")), S(new T(null, null, 3, h), u, "easeInOut");
                    E.linear = m.easing.Linear.easeIn, E.swing = m.easing.Quad.easeInOut;
                    var A = w("events.EventDispatcher", function(t) {
                        this._listeners = {}, this._eventTarget = t || this
                    });
                    (u = A.prototype).addEventListener = function(t, e, n, i, r) {
                        r = r || 0;
                        var o, a, s = this._listeners[t],
                            c = 0;
                        for (this !== p || d || p.wake(), null == s && (this._listeners[t] = s = []), a = s.length; --a > -1;)(o = s[a]).c === e && o.s === n ? s.splice(a, 1) : 0 === c && o.pr < r && (c = a + 1);
                        s.splice(c, 0, {
                            c: e,
                            s: n,
                            up: i,
                            pr: r
                        })
                    }, u.removeEventListener = function(t, e) {
                        var n, i = this._listeners[t];
                        if (i)
                            for (n = i.length; --n > -1;)
                                if (i[n].c === e) return void i.splice(n, 1)
                    }, u.dispatchEvent = function(t) {
                        var e, n, i, r = this._listeners[t];
                        if (r)
                            for ((e = r.length) > 1 && (r = r.slice(0)), n = this._eventTarget; --e > -1;)(i = r[e]) && (i.up ? i.c.call(i.s || n, {
                                type: t,
                                target: n
                            }) : i.c.call(i.s || n))
                    };
                    var P = n.requestAnimationFrame,
                        L = n.cancelAnimationFrame,
                        R = Date.now || function() {
                            return (new Date).getTime()
                        },
                        C = R();
                    for (h = (l = ["ms", "moz", "webkit", "o"]).length; --h > -1 && !P;) P = n[l[h] + "RequestAnimationFrame"], L = n[l[h] + "CancelAnimationFrame"] || n[l[h] + "CancelRequestAnimationFrame"];
                    w("Ticker", function(t, e) {
                        var n, i, r, o, s, c = this,
                            l = R(),
                            h = !(!1 === e || !P) && "auto",
                            u = 500,
                            f = 33,
                            m = function(t) {
                                var e, a, h = R() - C;
                                h > u && (l += h - f), C += h, c.time = (C - l) / 1e3, e = c.time - s, (!n || e > 0 || !0 === t) && (c.frame++, s += e + (e >= o ? .004 : o - e), a = !0), !0 !== t && (r = i(m)), a && c.dispatchEvent("tick")
                            };
                        A.call(c), c.time = c.frame = 0, c.tick = function() {
                            m(!0)
                        }, c.lagSmoothing = function(t, e) {
                            if (!arguments.length) return u < 1e8;
                            u = t || 1e8, f = Math.min(e, u, 0)
                        }, c.sleep = function() {
                            null != r && (h && L ? L(r) : clearTimeout(r), i = g, r = null, c === p && (d = !1))
                        }, c.wake = function(t) {
                            null !== r ? c.sleep() : t ? l += -C + (C = R()) : c.frame > 10 && (C = R() - u + 5), i = 0 === n ? g : h && P ? P : function(t) {
                                return setTimeout(t, 1e3 * (s - c.time) + 1 | 0)
                            }, c === p && (d = !0), m(2)
                        }, c.fps = function(t) {
                            if (!arguments.length) return n;
                            o = 1 / ((n = t) || 60), s = this.time + o, c.wake()
                        }, c.useRAF = function(t) {
                            if (!arguments.length) return h;
                            c.sleep(), h = t, c.fps(n)
                        }, c.fps(t), setTimeout(function() {
                            "auto" === h && c.frame < 5 && "hidden" !== (a || {}).visibilityState && c.useRAF(!1)
                        }, 1500)
                    }), (u = m.Ticker.prototype = new m.events.EventDispatcher).constructor = m.Ticker;
                    var O = w("core.Animation", function(t, e) {
                        if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !!e.immediateRender, this.data = e.data, this._reversed = !!e.reversed, Q) {
                            d || p.wake();
                            var n = this.vars.useFrames ? K : Q;
                            n.add(this, n._time), this.vars.paused && this.paused(!0)
                        }
                    });
                    p = O.ticker = new m.Ticker, (u = O.prototype)._dirty = u._gc = u._initted = u._paused = !1, u._totalTime = u._time = 0, u._rawPrevTime = -1, u._next = u._last = u._onUpdate = u._timeline = u.timeline = null, u._paused = !1;
                    var I = function() {
                        d && R() - C > 2e3 && ("hidden" !== (a || {}).visibilityState || !p.lagSmoothing()) && p.wake();
                        var t = setTimeout(I, 2e3);
                        t.unref && t.unref()
                    };
                    I(), u.play = function(t, e) {
                        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                    }, u.pause = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!0)
                    }, u.resume = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!1)
                    }, u.seek = function(t, e) {
                        return this.totalTime(Number(t), !1 !== e)
                    }, u.restart = function(t, e) {
                        return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                    }, u.reverse = function(t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                    }, u.render = function(t, e, n) {}, u.invalidate = function() {
                        return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                    }, u.isActive = function() {
                        var t, e = this._timeline,
                            n = this._startTime;
                        return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= n && t < n + this.totalDuration() / this._timeScale - 1e-8
                    }, u._enabled = function(t, e) {
                        return d || p.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                    }, u._kill = function(t, e) {
                        return this._enabled(!1, !1)
                    }, u.kill = function(t, e) {
                        return this._kill(t, e), this
                    }, u._uncache = function(t) {
                        for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                        return this
                    }, u._swapSelfInParams = function(t) {
                        for (var e = t.length, n = t.concat(); --e > -1;) "{self}" === t[e] && (n[e] = this);
                        return n
                    }, u._callback = function(t) {
                        var e = this.vars,
                            n = e[t],
                            i = e[t + "Params"],
                            r = e[t + "Scope"] || e.callbackScope || this;
                        switch (i ? i.length : 0) {
                            case 0:
                                n.call(r);
                                break;
                            case 1:
                                n.call(r, i[0]);
                                break;
                            case 2:
                                n.call(r, i[0], i[1]);
                                break;
                            default:
                                n.apply(r, i)
                        }
                    }, u.eventCallback = function(t, e, n, i) {
                        if ("on" === (t || "").substr(0, 2)) {
                            var r = this.vars;
                            if (1 === arguments.length) return r[t];
                            null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = y(n) && -1 !== n.join("").indexOf("{self}") ? this._swapSelfInParams(n) : n, r[t + "Scope"] = i), "onUpdate" === t && (this._onUpdate = e)
                        }
                        return this
                    }, u.delay = function(t) {
                        return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                    }, u.duration = function(t) {
                        return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                    }, u.totalDuration = function(t) {
                        return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                    }, u.time = function(t, e) {
                        return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                    }, u.totalTime = function(t, e, n) {
                        if (d || p.wake(), !arguments.length) return this._totalTime;
                        if (this._timeline) {
                            if (t < 0 && !n && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                                this._dirty && this.totalDuration();
                                var i = this._totalDuration,
                                    r = this._timeline;
                                if (t > i && !n && (t = i), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? i - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                    for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                            }
                            this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (H.length && tt(), this.render(t, e, !1), H.length && tt())
                        }
                        return this
                    }, u.progress = u.totalProgress = function(t, e) {
                        var n = this.duration();
                        return arguments.length ? this.totalTime(n * t, e) : n ? this._time / n : this.ratio
                    }, u.startTime = function(t) {
                        return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                    }, u.endTime = function(t) {
                        return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                    }, u.timeScale = function(t) {
                        if (!arguments.length) return this._timeScale;
                        var e, n;
                        for (t = t || 1e-8, this._timeline && this._timeline.smoothChildTiming && (n = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = n - (n - this._startTime) * this._timeScale / t), this._timeScale = t, n = this.timeline; n && n.timeline;) n._dirty = !0, n.totalDuration(), n = n.timeline;
                        return this
                    }, u.reversed = function(t) {
                        return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                    }, u.paused = function(t) {
                        if (!arguments.length) return this._paused;
                        var e, n, i = this._timeline;
                        return t != this._paused && i && (d || t || p.wake(), n = (e = i.rawTime()) - this._pauseTime, !t && i.smoothChildTiming && (this._startTime += n, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== n && this._initted && this.duration() && (e = i.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                    };
                    var D = w("core.SimpleTimeline", function(t) {
                        O.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                    });
                    (u = D.prototype = new O).constructor = D, u.kill()._gc = !1, u._first = u._last = u._recent = null, u._sortChildren = !1, u.add = u.insert = function(t, e, n, i) {
                        var r, o;
                        if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                            for (o = t._startTime; r && r._startTime > o;) r = r._prev;
                        return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                    }, u._remove = function(t, e) {
                        return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                    }, u.render = function(t, e, n) {
                        var i, r = this._first;
                        for (this._totalTime = this._time = this._rawPrevTime = t; r;) i = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, n) : r.render((t - r._startTime) * r._timeScale, e, n)), r = i
                    }, u.rawTime = function() {
                        return d || p.wake(), this._totalTime
                    };
                    var N = w("TweenLite", function(t, e, i) {
                            if (O.call(this, e, i), this.render = N.prototype.render, null == t) throw "Cannot tween a null target.";
                            this.target = t = "string" != typeof t ? t : N.selector(t) || t;
                            var r, o, a, s = t.jquery || t.length && t !== n && t[0] && (t[0] === n || t[0].nodeType && t[0].style && !t.nodeType),
                                c = this.vars.overwrite;
                            if (this._overwrite = c = null == c ? J[N.defaultOverwrite] : "number" == typeof c ? c >> 0 : J[c], (s || t instanceof Array || t.push && y(t)) && "number" != typeof t[0])
                                for (this._targets = a = v(t), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++)(o = a[r]) ? "string" != typeof o ? o.length && o !== n && o[0] && (o[0] === n || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(v(o))) : (this._siblings[r] = et(o, this, !1), 1 === c && this._siblings[r].length > 1 && it(o, this, null, 1, this._siblings[r])) : "string" == typeof(o = a[r--] = N.selector(o)) && a.splice(r + 1, 1) : a.splice(r--, 1);
                            else this._propLookup = {}, this._siblings = et(t, this, !1), 1 === c && this._siblings.length > 1 && it(t, this, null, 1, this._siblings);
                            (this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-8, this.render(Math.min(0, -this._delay)))
                        }, !0),
                        B = function(t) {
                            return t && t.length && t !== n && t[0] && (t[0] === n || t[0].nodeType && t[0].style && !t.nodeType)
                        };
                    (u = N.prototype = new O).constructor = N, u.kill()._gc = !1, u.ratio = 0, u._firstPT = u._targets = u._overwrittenProps = u._startAt = null, u._notifyPluginsOfEnabled = u._lazy = !1, N.version = "2.1.3", N.defaultEase = u._ease = new T(null, null, 1, 1), N.defaultOverwrite = "auto", N.ticker = p, N.autoSleep = 120, N.lagSmoothing = function(t, e) {
                        p.lagSmoothing(t, e)
                    }, N.selector = n.$ || n.jQuery || function(t) {
                        var e = n.$ || n.jQuery;
                        return e ? (N.selector = e, e(t)) : (a || (a = n.document), a ? a.querySelectorAll ? a.querySelectorAll(t) : a.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t)
                    };
                    var H = [],
                        F = {},
                        k = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                        U = /[\+-]=-?[\.\d]/,
                        z = function(t) {
                            for (var e, n = this._firstPT; n;) e = n.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : n.c * t + n.s, n.m ? e = n.m.call(this._tween, e, this._target || n.t, this._tween) : e < 1e-6 && e > -1e-6 && !n.blob && (e = 0), n.f ? n.fp ? n.t[n.p](n.fp, e) : n.t[n.p](e) : n.t[n.p] = e, n = n._next
                        },
                        G = function(t) {
                            return (1e3 * t | 0) / 1e3 + ""
                        },
                        j = function(t, e, n, i) {
                            var r, o, a, s, c, l, h, u = [],
                                p = 0,
                                d = "",
                                f = 0;
                            for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", n && (n(u), t = u[0], e = u[1]), u.length = 0, r = t.match(k) || [], o = e.match(k) || [], i && (i._next = null, i.blob = 1, u._firstPT = u._applyPT = i), c = o.length, s = 0; s < c; s++) h = o[s], d += (l = e.substr(p, e.indexOf(h, p) - p)) || !s ? l : ",", p += l.length, f ? f = (f + 1) % 5 : "rgba(" === l.substr(-5) && (f = 1), h === r[s] || r.length <= s ? d += h : (d && (u.push(d), d = ""), a = parseFloat(r[s]), u.push(a), u._firstPT = {
                                _next: u._firstPT,
                                t: u,
                                p: u.length - 1,
                                s: a,
                                c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - a) || 0,
                                f: 0,
                                m: f && f < 4 ? Math.round : G
                            }), p += h.length;
                            return (d += e.substr(p)) && u.push(d), u.setRatio = z, U.test(e) && (u.end = null), u
                        },
                        V = function(t, e, n, i, r, o, a, s, c) {
                            "function" == typeof i && (i = i(c || 0, t));
                            var l = typeof t[e],
                                h = "function" !== l ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                                u = "get" !== n ? n : h ? a ? t[h](a) : t[h]() : t[e],
                                p = "string" == typeof i && "=" === i.charAt(1),
                                d = {
                                    t: t,
                                    p: e,
                                    s: u,
                                    f: "function" === l,
                                    pg: 0,
                                    n: r || e,
                                    m: o ? "function" == typeof o ? o : Math.round : 0,
                                    pr: 0,
                                    c: p ? parseInt(i.charAt(0) + "1", 10) * parseFloat(i.substr(2)) : parseFloat(i) - u || 0
                                };
                            if (("number" != typeof u || "number" != typeof i && !p) && (a || isNaN(u) || !p && isNaN(i) || "boolean" == typeof u || "boolean" == typeof i ? (d.fp = a, d = {
                                    t: j(u, p ? parseFloat(d.s) + d.c + (d.s + "").replace(/[0-9\-\.]/g, "") : i, s || N.defaultStringFilter, d),
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 2,
                                    pg: 0,
                                    n: r || e,
                                    pr: 0,
                                    m: 0
                                }) : (d.s = parseFloat(u), p || (d.c = parseFloat(i) - d.s || 0))), d.c) return (d._next = this._firstPT) && (d._next._prev = d), this._firstPT = d, d
                        },
                        W = N._internals = {
                            isArray: y,
                            isSelector: B,
                            lazyTweens: H,
                            blobDif: j
                        },
                        X = N._plugins = {},
                        q = W.tweenLookup = {},
                        Y = 0,
                        Z = W.reservedProps = {
                            ease: 1,
                            delay: 1,
                            overwrite: 1,
                            onComplete: 1,
                            onCompleteParams: 1,
                            onCompleteScope: 1,
                            useFrames: 1,
                            runBackwards: 1,
                            startAt: 1,
                            onUpdate: 1,
                            onUpdateParams: 1,
                            onUpdateScope: 1,
                            onStart: 1,
                            onStartParams: 1,
                            onStartScope: 1,
                            onReverseComplete: 1,
                            onReverseCompleteParams: 1,
                            onReverseCompleteScope: 1,
                            onRepeat: 1,
                            onRepeatParams: 1,
                            onRepeatScope: 1,
                            easeParams: 1,
                            yoyo: 1,
                            immediateRender: 1,
                            repeat: 1,
                            repeatDelay: 1,
                            data: 1,
                            paused: 1,
                            reversed: 1,
                            autoCSS: 1,
                            lazy: 1,
                            onOverwrite: 1,
                            callbackScope: 1,
                            stringFilter: 1,
                            id: 1,
                            yoyoEase: 1,
                            stagger: 1
                        },
                        J = {
                            none: 0,
                            all: 1,
                            auto: 2,
                            concurrent: 3,
                            allOnStart: 4,
                            preexisting: 5,
                            true: 1,
                            false: 0
                        },
                        K = O._rootFramesTimeline = new D,
                        Q = O._rootTimeline = new D,
                        $ = 30,
                        tt = W.lazyRender = function() {
                            var t, e, n = H.length;
                            for (F = {}, t = 0; t < n; t++)(e = H[t]) && !1 !== e._lazy && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1);
                            H.length = 0
                        };
                    Q._startTime = p.time, K._startTime = p.frame, Q._active = K._active = !0, setTimeout(tt, 1), O._updateRoot = N.render = function() {
                        var t, e, n;
                        if (H.length && tt(), Q.render((p.time - Q._startTime) * Q._timeScale, !1, !1), K.render((p.frame - K._startTime) * K._timeScale, !1, !1), H.length && tt(), p.frame >= $) {
                            for (n in $ = p.frame + (parseInt(N.autoSleep, 10) || 120), q) {
                                for (t = (e = q[n].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                                0 === e.length && delete q[n]
                            }
                            if ((!(n = Q._first) || n._paused) && N.autoSleep && !K._first && 1 === p._listeners.tick.length) {
                                for (; n && n._paused;) n = n._next;
                                n || p.sleep()
                            }
                        }
                    }, p.addEventListener("tick", O._updateRoot);
                    var et = function(t, e, n) {
                            var i, r, o = t._gsTweenID;
                            if (q[o || (t._gsTweenID = o = "t" + Y++)] || (q[o] = {
                                    target: t,
                                    tweens: []
                                }), e && ((i = q[o].tweens)[r = i.length] = e, n))
                                for (; --r > -1;) i[r] === e && i.splice(r, 1);
                            return q[o].tweens
                        },
                        nt = function(t, e, n, i) {
                            var r, o, a = t.vars.onOverwrite;
                            return a && (r = a(t, e, n, i)), (a = N.onOverwrite) && (o = a(t, e, n, i)), !1 !== r && !1 !== o
                        },
                        it = function(t, e, n, i, r) {
                            var o, a, s, c;
                            if (1 === i || i >= 4) {
                                for (c = r.length, o = 0; o < c; o++)
                                    if ((s = r[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                                    else if (5 === i) break;
                                return a
                            }
                            var l, h = e._startTime + 1e-8,
                                u = [],
                                p = 0,
                                d = 0 === e._duration;
                            for (o = r.length; --o > -1;)(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (l = l || rt(e, 0, d), 0 === rt(s, l, d) && (u[p++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((d || !s._initted) && h - s._startTime <= 2e-8 || (u[p++] = s)));
                            for (o = p; --o > -1;)
                                if (c = (s = u[o])._firstPT, 2 === i && s._kill(n, t, e) && (a = !0), 2 !== i || !s._firstPT && s._initted && c) {
                                    if (2 !== i && !nt(s, e)) continue;
                                    s._enabled(!1, !1) && (a = !0)
                                }
                            return a
                        },
                        rt = function(t, e, n) {
                            for (var i = t._timeline, r = i._timeScale, o = t._startTime; i._timeline;) {
                                if (o += i._startTime, r *= i._timeScale, i._paused) return -100;
                                i = i._timeline
                            }
                            return (o /= r) > e ? o - e : n && o === e || !t._initted && o - e < 2e-8 ? 1e-8 : (o += t.totalDuration() / t._timeScale / r) > e + 1e-8 ? 0 : o - e - 1e-8
                        };
                    u._init = function() {
                        var t, e, n, i, r, o, a = this.vars,
                            s = this._overwrittenProps,
                            c = this._duration,
                            l = !!a.immediateRender,
                            h = a.ease,
                            u = this._startAt;
                        if (a.startAt) {
                            for (i in u && (u.render(-1, !0), u.kill()), r = {}, a.startAt) r[i] = a.startAt[i];
                            if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== a.lazy, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = N.to(this.target || {}, 0, r), l)
                                if (this._time > 0) this._startAt = null;
                                else if (0 !== c) return
                        } else if (a.runBackwards && 0 !== c)
                            if (u) u.render(-1, !0), u.kill(), this._startAt = null;
                            else {
                                for (i in 0 !== this._time && (l = !1), n = {}, a) Z[i] && "autoCSS" !== i || (n[i] = a[i]);
                                if (n.overwrite = 0, n.data = "isFromStart", n.lazy = l && !1 !== a.lazy, n.immediateRender = l, this._startAt = N.to(this.target, 0, n), l) {
                                    if (0 === this._time) return
                                } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                            }
                        if (this._ease = h = h ? h instanceof T ? h : "function" == typeof h ? new T(h, a.easeParams) : E[h] || N.defaultEase : N.defaultEase, a.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                            for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                        else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                        if (e && N._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                            for (n = this._firstPT; n;) n.s += n.c, n.c = -n.c, n = n._next;
                        this._onUpdate = a.onUpdate, this._initted = !0
                    }, u._initProps = function(t, e, i, r, o) {
                        var a, s, c, l, h, u;
                        if (null == t) return !1;
                        for (a in F[t._gsTweenID] && tt(), this.vars.css || t.style && t !== n && t.nodeType && X.css && !1 !== this.vars.autoCSS && function(t, e) {
                                var n, i = {};
                                for (n in t) Z[n] || n in e && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!X[n] || X[n] && X[n]._autoCSS) || (i[n] = t[n], delete t[n]);
                                t.css = i
                            }(this.vars, t), this.vars)
                            if (u = this.vars[a], Z[a]) u && (u instanceof Array || u.push && y(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[a] = u = this._swapSelfInParams(u, this));
                            else if (X[a] && (l = new X[a])._onInitTween(t, this.vars[a], this, o)) {
                            for (this._firstPT = h = {
                                    _next: this._firstPT,
                                    t: l,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 1,
                                    n: a,
                                    pg: 1,
                                    pr: l._priority,
                                    m: 0
                                }, s = l._overwriteProps.length; --s > -1;) e[l._overwriteProps[s]] = this._firstPT;
                            (l._priority || l._onInitAllProps) && (c = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
                        } else e[a] = V.call(this, t, a, "get", u, a, 0, null, this.vars.stringFilter, o);
                        return r && this._kill(r, t) ? this._initProps(t, e, i, r, o) : this._overwrite > 1 && this._firstPT && i.length > 1 && it(t, this, e, this._overwrite, i) ? (this._kill(e, t), this._initProps(t, e, i, r, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (F[t._gsTweenID] = !0), c)
                    }, u.render = function(t, e, n) {
                        var i, r, o, a, s = this._time,
                            c = this._duration,
                            l = this._rawPrevTime;
                        if (t >= c - 1e-8 && t >= 0) this._totalTime = this._time = c, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (i = !0, r = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === c && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (l < 0 || t <= 0 && t >= -1e-8 || 1e-8 === l && "isPause" !== this.data) && l !== t && (n = !0, l > 1e-8 && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : 1e-8);
                        else if (t < 1e-8) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === c && l > 0) && (r = "onReverseComplete", i = this._reversed), t > -1e-8 ? t = 0 : t < 0 && (this._active = !1, 0 === c && (this._initted || !this.vars.lazy || n) && (l >= 0 && (1e-8 !== l || "isPause" !== this.data) && (n = !0), this._rawPrevTime = a = !e || t || l === t ? t : 1e-8)), (!this._initted || this._startAt && this._startAt.progress()) && (n = !0);
                        else if (this._totalTime = this._time = t, this._easeType) {
                            var h = t / c,
                                u = this._easeType,
                                p = this._easePower;
                            (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === p ? h *= h : 2 === p ? h *= h * h : 3 === p ? h *= h * h * h : 4 === p && (h *= h * h * h * h), this.ratio = 1 === u ? 1 - h : 2 === u ? h : t / c < .5 ? h / 2 : 1 - h / 2
                        } else this.ratio = this._ease.getRatio(t / c);
                        if (this._time !== s || n) {
                            if (!this._initted) {
                                if (this._init(), !this._initted || this._gc) return;
                                if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = l, H.push(this), void(this._lazy = [t, e]);
                                this._time && !i ? this.ratio = this._ease.getRatio(this._time / c) : i && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                            }
                            for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, n) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== c || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                            this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, n), e || (this._time !== s || i || n) && this._callback("onUpdate")), r && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, n), i && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === c && 1e-8 === this._rawPrevTime && 1e-8 !== a && (this._rawPrevTime = 0)))
                        }
                    }, u._kill = function(t, e, n) {
                        if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                        e = "string" != typeof e ? e || this._targets || this.target : N.selector(e) || e;
                        var i, r, o, a, s, c, l, h, u, p = n && this._time && n._startTime === this._startTime && this._timeline === n._timeline,
                            d = this._firstPT;
                        if ((y(e) || B(e)) && "number" != typeof e[0])
                            for (i = e.length; --i > -1;) this._kill(t, e[i], n) && (c = !0);
                        else {
                            if (this._targets) {
                                for (i = this._targets.length; --i > -1;)
                                    if (e === this._targets[i]) {
                                        s = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all";
                                        break
                                    }
                            } else {
                                if (e !== this.target) return !1;
                                s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                            }
                            if (s) {
                                if (l = t || s, h = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), n && (N.onOverwrite || this.vars.onOverwrite)) {
                                    for (o in l) s[o] && (u || (u = []), u.push(o));
                                    if ((u || !t) && !nt(this, n, e, u)) return !1
                                }
                                for (o in l)(a = s[o]) && (p && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, c = !0), a.pg && a.t._kill(l) && (c = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), h && (r[o] = 1);
                                !this._firstPT && this._initted && d && this._enabled(!1, !1)
                            }
                        }
                        return c
                    }, u.invalidate = function() {
                        this._notifyPluginsOfEnabled && N._onPluginEvent("_onDisable", this);
                        var t = this._time;
                        return this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], O.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-8, this.render(t, !1, !1 !== this.vars.lazy)), this
                    }, u._enabled = function(t, e) {
                        if (d || p.wake(), t && this._gc) {
                            var n, i = this._targets;
                            if (i)
                                for (n = i.length; --n > -1;) this._siblings[n] = et(i[n], this, !0);
                            else this._siblings = et(this.target, this, !0)
                        }
                        return O.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && N._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                    }, N.to = function(t, e, n) {
                        return new N(t, e, n)
                    }, N.from = function(t, e, n) {
                        return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new N(t, e, n)
                    }, N.fromTo = function(t, e, n, i) {
                        return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, new N(t, e, i)
                    }, N.delayedCall = function(t, e, n, i, r) {
                        return new N(e, 0, {
                            delay: t,
                            onComplete: e,
                            onCompleteParams: n,
                            callbackScope: i,
                            onReverseComplete: e,
                            onReverseCompleteParams: n,
                            immediateRender: !1,
                            lazy: !1,
                            useFrames: r,
                            overwrite: 0
                        })
                    }, N.set = function(t, e) {
                        return new N(t, 0, e)
                    }, N.getTweensOf = function(t, e) {
                        if (null == t) return [];
                        var n, i, r, o;
                        if (t = "string" != typeof t ? t : N.selector(t) || t, (y(t) || B(t)) && "number" != typeof t[0]) {
                            for (n = t.length, i = []; --n > -1;) i = i.concat(N.getTweensOf(t[n], e));
                            for (n = i.length; --n > -1;)
                                for (o = i[n], r = n; --r > -1;) o === i[r] && i.splice(n, 1)
                        } else if (t._gsTweenID)
                            for (n = (i = et(t).concat()).length; --n > -1;)(i[n]._gc || e && !i[n].isActive()) && i.splice(n, 1);
                        return i || []
                    }, N.killTweensOf = N.killDelayedCallsTo = function(t, e, n) {
                        "object" == typeof e && (n = e, e = !1);
                        for (var i = N.getTweensOf(t, e), r = i.length; --r > -1;) i[r]._kill(n, t)
                    };
                    var ot = w("plugins.TweenPlugin", function(t, e) {
                        this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = ot.prototype
                    }, !0);
                    if (u = ot.prototype, ot.version = "1.19.0", ot.API = 2, u._firstPT = null, u._addTween = V, u.setRatio = z, u._kill = function(t) {
                            var e, n = this._overwriteProps,
                                i = this._firstPT;
                            if (null != t[this._propName]) this._overwriteProps = [];
                            else
                                for (e = n.length; --e > -1;) null != t[n[e]] && n.splice(e, 1);
                            for (; i;) null != t[i.n] && (i._next && (i._next._prev = i._prev), i._prev ? (i._prev._next = i._next, i._prev = null) : this._firstPT === i && (this._firstPT = i._next)), i = i._next;
                            return !1
                        }, u._mod = u._roundProps = function(t) {
                            for (var e, n = this._firstPT; n;)(e = t[this._propName] || null != n.n && t[n.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === n.f ? n.t._applyPT.m = e : n.m = e), n = n._next
                        }, N._onPluginEvent = function(t, e) {
                            var n, i, r, o, a, s = e._firstPT;
                            if ("_onInitAllProps" === t) {
                                for (; s;) {
                                    for (a = s._next, i = r; i && i.pr > s.pr;) i = i._next;
                                    (s._prev = i ? i._prev : o) ? s._prev._next = s: r = s, (s._next = i) ? i._prev = s : o = s, s = a
                                }
                                s = e._firstPT = r
                            }
                            for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (n = !0), s = s._next;
                            return n
                        }, ot.activate = function(t) {
                            for (var e = t.length; --e > -1;) t[e].API === ot.API && (X[(new t[e])._propName] = t[e]);
                            return !0
                        }, b.plugin = function(t) {
                            if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                            var e, n = t.propName,
                                i = t.priority || 0,
                                r = t.overwriteProps,
                                o = {
                                    init: "_onInitTween",
                                    set: "setRatio",
                                    kill: "_kill",
                                    round: "_mod",
                                    mod: "_mod",
                                    initAll: "_onInitAllProps"
                                },
                                a = w("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin", function() {
                                    ot.call(this, n, i), this._overwriteProps = r || []
                                }, !0 === t.global),
                                s = a.prototype = new ot(n);
                            for (e in s.constructor = a, a.API = t.API, o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                            return a.version = t.version, ot.activate([a]), a
                        }, l = n._gsQueue) {
                        for (h = 0; h < l.length; h++) l[h]();
                        for (u in _) _[u].func || n.console.log("GSAP encountered missing dependency: " + u)
                    }
                    d = !1
                }(void 0 !== t && t.exports && void 0 !== n ? n : this || window)
        }).call(this, n(27))
    }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
            return r
        });
        const i = new class {
                constructor() {
                    this.data = {}, this.listeners = {}, this.fireAtStart = {}, this.instances = []
                }
                on(t, e) {
                    this.listeners[t] = this.listeners[t] || [], this.listeners[t].push(e)
                }
                off(t, e) {
                    t in this.listeners != 0 && this.listeners[t].splice(this.listeners[t].indexOf(e), 1)
                }
                register(t) {
                    this.instances.push(t);
                    for (let e in this.fireAtStart) this.fireMethod(t, e)
                }
                unregister(t) {
                    const e = this.instances.indexOf(t);
                    e > -1 && this.instances.splice(e, 1)
                }
                nameToMethod(t) {
                    return `on${t.charAt(0).toUpperCase()+t.slice(1)}`
                }
                fireMethod(t, e) {
                    const n = t[this.nameToMethod(e)];
                    "function" == typeof n && n.call(t, this.data[e])
                }
                trigger({
                    name: t,
                    fireAtStart: e = !1,
                    log: n = !1
                }, i = {}) {
                    if (this.data[t] = i, e && (this.fireAtStart[t] = !0), t in this.listeners)
                        for (let e = 0; e < this.listeners[t].length; e++) this.listeners[t][e].call(this, i);
                    this.instances.forEach(e => this.fireMethod(e, t))
                }
            },
            r = (t = class {}) => (class extends t {
                constructor(...t) {
                    super(...t), this._args = t, this.init && this.init(), i.register(this)
                }
                destroy() {
                    i.unregister(this)
                }
            });
        e.b = i
    }, , function(t, e, n) {
        window,
        t.exports = function(t) {
            var e = {};

            function n(i) {
                if (e[i]) return e[i].exports;
                var r = e[i] = {
                    i: i,
                    l: !1,
                    exports: {}
                };
                return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
            }
            return n.m = t, n.c = e, n.d = function(t, e, i) {
                n.o(t, e) || Object.defineProperty(t, e, {
                    enumerable: !0,
                    get: i
                })
            }, n.r = function(t) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }, n.t = function(t, e) {
                if (1 & e && (t = n(t)), 8 & e) return t;
                if (4 & e && "object" == typeof t && t && t.__esModule) return t;
                var i = Object.create(null);
                if (n.r(i), Object.defineProperty(i, "default", {
                        enumerable: !0,
                        value: t
                    }), 2 & e && "string" != typeof t)
                    for (var r in t) n.d(i, r, function(e) {
                        return t[e]
                    }.bind(null, r));
                return i
            }, n.n = function(t) {
                var e = t && t.__esModule ? function() {
                    return t.default
                } : function() {
                    return t
                };
                return n.d(e, "a", e), e
            }, n.o = function(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }, n.p = "", n(n.s = 9)
        }([function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = n(2);
            Object.keys(i).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return i[t]
                    }
                })
            });
            var r = n(20);
            Object.keys(r).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return r[t]
                    }
                })
            })
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = n(22);
            Object.keys(i).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return i[t]
                    }
                })
            });
            var r = n(25);
            Object.keys(r).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return r[t]
                    }
                })
            });
            var o = n(26);
            Object.keys(o).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return o[t]
                    }
                })
            });
            var a = n(27);
            Object.keys(a).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return a[t]
                    }
                })
            });
            var s = n(28);
            Object.keys(s).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return s[t]
                    }
                })
            })
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Multimap = void 0;
            var i = function(t, e) {
                    if (Array.isArray(t)) return t;
                    if (Symbol.iterator in Object(t)) return function(t, e) {
                        var n = [],
                            i = !0,
                            r = !1,
                            o = void 0;
                        try {
                            for (var a, s = t[Symbol.iterator](); !(i = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); i = !0);
                        } catch (t) {
                            r = !0, o = t
                        } finally {
                            try {
                                !i && s.return && s.return()
                            } finally {
                                if (r) throw o
                            }
                        }
                        return n
                    }(t, e);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                },
                r = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                o = n(4);
            e.Multimap = function() {
                function t() {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.valuesByKey = new Map
                }
                return r(t, [{
                    key: "add",
                    value: function(t, e) {
                        (0, o.add)(this.valuesByKey, t, e)
                    }
                }, {
                    key: "delete",
                    value: function(t, e) {
                        (0, o.del)(this.valuesByKey, t, e)
                    }
                }, {
                    key: "has",
                    value: function(t, e) {
                        var n = this.valuesByKey.get(t);
                        return n && n.has(e)
                    }
                }, {
                    key: "hasKey",
                    value: function(t) {
                        return this.valuesByKey.has(t)
                    }
                }, {
                    key: "hasValue",
                    value: function(t) {
                        return Array.from(this.valuesByKey.values()).some(function(e) {
                            return e.has(t)
                        })
                    }
                }, {
                    key: "getValuesForKey",
                    value: function(t) {
                        var e = this.valuesByKey.get(t);
                        return e ? Array.from(e) : []
                    }
                }, {
                    key: "getKeysForValue",
                    value: function(t) {
                        return Array.from(this.valuesByKey).filter(function(e) {
                            return i(e, 2)[1].has(t)
                        }).map(function(t) {
                            return i(t, 1)[0]
                        })
                    }
                }, {
                    key: "values",
                    get: function() {
                        return Array.from(this.valuesByKey.values()).reduce(function(t, e) {
                            return t.concat(Array.from(e))
                        }, [])
                    }
                }, {
                    key: "size",
                    get: function() {
                        return Array.from(this.valuesByKey.values()).reduce(function(t, e) {
                            return t + e.size
                        }, 0)
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = n(19);
            Object.keys(i).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return i[t]
                    }
                })
            });
            var r = n(21);
            Object.keys(r).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return r[t]
                    }
                })
            })
        }, function(t, e, n) {
            "use strict";

            function i(t, e) {
                var n = t.get(e);
                return n || (n = new Set, t.set(e, n)), n
            }

            function r(t, e) {
                var n = t.get(e);
                null !== n && 0 === n.size && t.delete(e)
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.add = function(t, e, n) {
                i(t, e).add(n)
            }, e.del = function(t, e, n) {
                i(t, e).delete(n), r(t, e)
            }, e.fetch = i, e.prune = r
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ee = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = function(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }(n(23)),
                o = function(t) {
                    function e() {
                        ! function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, e);
                        var t = function(t, e) {
                            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return !e || "object" != typeof e && "function" != typeof e ? t : e
                        }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                        return t._logs = new Set, t
                    }
                    return function(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                    }(e, r.default), i(e, [{
                        key: "emit",
                        value: function() {
                            for (var t, n = arguments.length, i = Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                            var o = i[0];
                            i.slice(1), this._logs.has(o), (t = function t(e, n, i) {
                                null === e && (e = Function.prototype);
                                var r = Object.getOwnPropertyDescriptor(e, n);
                                if (void 0 === r) {
                                    var o = Object.getPrototypeOf(e);
                                    return null === o ? void 0 : t(o, n, i)
                                }
                                if ("value" in r) return r.value;
                                var a = r.get;
                                return void 0 !== a ? a.call(i) : void 0
                            }(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "emit", this)).call.apply(t, [this].concat(i))
                        }
                    }, {
                        key: "add",
                        value: function(t) {
                            (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && this._logs.add(t)
                        }
                    }, {
                        key: "remove",
                        value: function(t) {
                            this._logs.has(t) && this._logs.delete(t)
                        }
                    }]), e
                }();
            e.ee = new o
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.CustomEvent = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(7);
            e.CustomEvent = function() {
                function t(e, n) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.name = e, this.capitalizedName = (0, r.ucfirst)(e), this.scope = "global", this.log = n, this.eventByElement = new Map
                }
                return i(t, [{
                    key: "bind",
                    value: function(t, e) {
                        var n = t.context.element;
                        this.eventByElement.set(n, this.listener(t)), e.on(this.name, this.eventByElement.get(n))
                    }
                }, {
                    key: "unbind",
                    value: function(t, e) {
                        var n = t.context.element;
                        e.off(this.name, this.eventByElement.get(n))
                    }
                }, {
                    key: "listener",
                    value: function(t) {
                        var e = "on" + this.capitalizedName;
                        return function() {
                            t[e].apply(t, arguments)
                        }
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = n(8);
            Object.keys(i).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return i[t]
                    }
                })
            });
            var r = n(24);
            Object.keys(r).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return r[t]
                    }
                })
            })
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = function(t, e) {
                if (Array.isArray(t)) return t;
                if (Symbol.iterator in Object(t)) return function(t, e) {
                    var n = [],
                        i = !0,
                        r = !1,
                        o = void 0;
                    try {
                        for (var a, s = t[Symbol.iterator](); !(i = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); i = !0);
                    } catch (t) {
                        r = !0, o = t
                    } finally {
                        try {
                            !i && s.return && s.return()
                        } finally {
                            if (r) throw o
                        }
                    }
                    return n
                }(t, e);
                throw new TypeError("Invalid attempt to destructure non-iterable instance")
            };
            e.autoLoad = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    stripFolders: 1
                };
                return t.keys().map(function(n) {
                    return function(t, e, n) {
                        var r = function(t, e) {
                            var n = t.match(/^(?:\.\/)?([A-Z]{1}[A-Za-z]+|[a-z/]+\/[A-Z]{1}[A-Za-z]+)(?:\.js?)$/) || [],
                                r = i(n, 2)[1];
                            if (r) {
                                for (var o = 0; o < e; o++) r = r.replace(/^([a-zA-Z]+\/)/, "");
                                return r.replace(/([A-Z])/g, "-$1").replace(/^-/, "").replace(/\/-/g, "/").replace(/\//g, "--").toLowerCase()
                            }
                            return !1
                        }(e, n.stripFolders);
                        return !!r && function(t, e) {
                            var n = t.default;
                            return "function" == typeof n && {
                                slug: e,
                                ComponentConstructor: n
                            }
                        }(t(e), r)
                    }(t, n, e)
                }).filter(function(t) {
                    return t
                })
            }
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = n(10);
            Object.keys(i).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return i[t]
                    }
                })
            });
            var r = n(34);
            Object.keys(r).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return r[t]
                    }
                })
            });
            var o = n(35);
            Object.keys(o).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return o[t]
                    }
                })
            });
            var a = n(5);
            Object.keys(a).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return a[t]
                    }
                })
            });
            var s = n(6);
            Object.keys(s).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return s[t]
                    }
                })
            });
            var c = n(8);
            Object.keys(c).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return c[t]
                    }
                })
            });
            var l = n(2);
            Object.keys(l).forEach(function(t) {
                "default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: function() {
                        return l[t]
                    }
                })
            })
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Application = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = function(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }(n(11)),
                o = n(13),
                a = n(14),
                s = n(1);
            e.Application = function() {
                function t() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document.body,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.defaultSchema,
                        i = arguments[2];
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.element = e, this.schema = n, this.props = i, this.manager = new a.Manager(this), this.customEvents = s.customEvents, this.plugins = new Set
                }
                return i(t, null, [{
                    key: "start",
                    value: function(e, n, i) {
                        var r = new t(e, n, i);
                        return r.start(), r
                    }
                }]), i(t, [{
                    key: "start",
                    value: function() {
                        this.manager.start()
                    }
                }, {
                    key: "stop",
                    value: function() {
                        this.manager.stop()
                    }
                }, {
                    key: "register",
                    value: function(t, e) {
                        for (var n = arguments.length, i = Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
                        this.manager.addModule({
                            slug: t,
                            ComponentConstructor: e
                        }, !1, i)
                    }
                }, {
                    key: "load",
                    value: function(t) {
                        var e = this;
                        (Array.isArray(t) ? t : [t]).forEach(function(t) {
                            return e.manager.addModule(t)
                        })
                    }
                }, {
                    key: "init",
                    value: function(t, e) {
                        for (var n = arguments.length, i = Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
                        return this.manager.addModule({
                            slug: t,
                            ComponentConstructor: e
                        }, !0, i), this.components.find(function(t) {
                            return t instanceof e
                        })
                    }
                }, {
                    key: "unload",
                    value: function(t) {
                        var e = this;
                        (Array.isArray(t) ? t : [t]).forEach(function(t) {
                            return e.manager.removeModule(t)
                        })
                    }
                }, {
                    key: "use",
                    value: function(t, e, n) {
                        this.customEvents.types.has(t) && this.handleError("oups", "This event type already exists [" + t + "]"), this.customEvents.add(t, e, n)
                    }
                }, {
                    key: "extend",
                    value: function(t) {
                        t.init(), this.plugins.add(t)
                    }
                }, {
                    key: "handleError",
                    value: function(t, e) {
                        throw new Error(" " + r.default.random() + "! " + e + " \n " + t)
                    }
                }, {
                    key: "components",
                    get: function() {
                        return this.manager.contexts.map(function(t) {
                            return t.component
                        })
                    }
                }, {
                    key: "events",
                    get: function() {
                        return this.customEvents.events
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = function(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }(n(12)),
                r = {
                    all: i.default,
                    random: function() {
                        return i.default[Math.floor(Math.random() * i.default.length)]
                    }
                };
            e.default = r, t.exports = e.default
        }, function(t) {
            t.exports = ["Holy Agility", "Holy Almost", "Holy Alphabet", "Holy Alps", "Holy Alter Ego", "Holy Anagram", "Holy Apparition", "Holy Armadillo", "Holy Armour Plate", "Holy Ashtray", "Holy Asp", "Holy Astronomy", "Holy Astringent Plum-like Fruit", "Holy Audubon", "Holy Backfire", "Holy Ball And Chain", "Holy Bank Balance", "Holy Bankruptcy", "Holy Banks", "Holy Bargain Basements", "Holy Barracuda", "Holy Bat Logic", "Holy Bat Trap", "Holy Batman", "Holy Benedict Arnold", "Holy Bijou", "Holy Bikini", "Holy Bill Of Rights", "Holy Birthday Cake", "Holy Black Beard", "Holy Blackout", "Holy Blank Cartridge", "Holy Blizzard", "Holy Blonde Mackerel Ash", "Holy Bluebeard", "Holy Bouncing Boiler Plate", "Holy Bowler", "Holy Bullseye", "Holy Bunions", "Holy Caffeine", "Holy Camouflage", "Holy Captain Nemo", "Holy Caruso", "Holy Catastrophe", "Holy Cat(s)", "Holy Chicken Coop", "Holy Chilblains", "Holy Chocolate Eclair", "Holy Cinderella", "Holy Cinemascope", "Holy Cliche", "Holy Cliffhangers", "Holy Clockwork", "Holy Clockworks", "Holy Cofax You Mean", "Holy Coffin Nails", "Holy Cold Creeps", "Holy Complications", "Holy Conflagration", "Holy Contributing to the Delinquency of Minors", "Holy Corpuscles", "Holy Cosmos", "Holy Costume Party", "Holy Crack Up", "Holy Crickets", "Holy Crossfire", "Holy Crucial Moment", "Holy Cryptology", "Holy D'artagnan", "Holy Davy Jones", "Holy Detonator", "Holy Disappearing Act", "Holy Distortion", "Holy Diversionary Tactics", "Holy Dr. Jekyll and Mr. Hyde", "Holy Egg Shells", "Holy Encore", "Holy Endangered Species", "Holy Epigrams", "Holy Escape-hatch", "Holy Explosion", "Holy Fate-worse-than-death", "Holy Felony", "Holy Finishing-touches", "Holy Fireworks", "Holy Firing Squad", "Holy Fishbowl", "Holy Flight Plan", "Holy Flip-flop", "Holy Flood Gate", "Holy Floor Covering", "Holy Flypaper", "Holy Fly Trap", "Holy Fog", "Holy Forecast", "Holy Fork In The Road", "Holy Fourth Amendment", "Holy Fourth Of July", "Holy Frankenstein", "Holy Frankenstein It's Alive", "Holy Fratricide", "Holy Frogman", "Holy Fruit Salad", "Holy Frying Towels", "Holy Funny Bone", "Holy Gall", "Holy Gambles", "Holy Gemini", "Holy Geography", "Holy Ghost Writer", "Holy Giveaways", "Holy Glow Pot", "Holy Golden Gate", "Holy Graf Zeppelin", "Holy Grammar", "Holy Graveyards", "Holy Greed", "Holy Green Card", "Holy Greetings-cards", "Holy Guacamole", "Holy Guadalcanal", "Holy Gullibility", "Holy Gunpowder", "Holy Haberdashery", "Holy Hailstorm", "Holy Hairdo", "Holy Hallelujah", "Holy Halloween", "Holy Hallucination", "Holy Hamburger", "Holy Hamlet", "Holy Hamstrings", "Holy Happenstance", "Holy Hardest Metal In The World", "Holy Harem", "Holy Harshin", "Holy Haziness", "Holy Headache", "Holy Headline", "Holy Heart Failure", "Holy Heartbreak", "Holy Heidelberg", "Holy Helmets", "Holy Helplessness", "Holy Here We Go Again", "Holy Hi-fi", "Holy Hieroglyphic", "Holy High-wire", "Holy Hijack", "Holy Hijackers", "Holy History", "Holy Hoaxes", "Holy Hole In A Donut", "Holy Hollywood", "Holy Holocaust", "Holy Homecoming", "Holy Homework", "Holy Homicide", "Holy Hoodwink", "Holy Hoof Beats", "Holy Hors D'Oeuvre", "Holy Horseshoes", "Holy Hostage", "Holy Hot Foot", "Holy Houdini", "Holy Human Collectors Item", "Holy Human Pearls", "Holy Human Pressure Cookers", "Holy Human Surfboards", "Holy Hunting Horn", "Holy Hurricane", "Holy Hutzpa", "Holy Hydraulics", "Holy Hypnotism", "Holy Hypodermics", "Holy Ice Picks", "Holy Ice Skates", "Holy Iceberg", "Holy Impossibility", "Holy Impregnability", "Holy Incantation", "Holy Inquisition", "Holy Interplanetary Yardstick", "Holy Interruptions", "Holy Iodine", "Holy IT and T", "Holy Jack In The Box", "Holy Jackpot", "Holy Jail Break", "Holy Jaw Breaker", "Holy Jelly Molds", "Holy Jet Set", "Holy Jigsaw Puzzles", "Holy Jitter Bugs", "Holy Joe", "Holy Journey To The Center Of The Earth", "Holy Jumble", "Holy Jumpin' Jiminy", "Holy Karats", "Holy Key Hole", "Holy Key Ring", "Holy Kilowatts", "Holy Kindergarten", "Holy Knit One Purl Two", "Holy Knock Out Drops", "Holy Known Unknown Flying Objects", "Holy Kofax", "Holy Las Vegas", "Holy Leopard", "Holy Levitation", "Holy Liftoff", "Holy Living End", "Holy Lodestone", "Holy Long John Silver", "Holy Looking Glass", "Holy Love Birds", "Holy Luther Burbank", "Holy Madness", "Holy Magic Lantern", "Holy Magician", "Holy Main Springs", "Holy Marathon", "Holy Mashed Potatoes", "Holy Masquerade", "Holy Matador", "Holy Mechanical Armies", "Holy Memory Bank", "Holy Merlin Magician", "Holy Mermaid", "Holy Merry Go Around", "Holy Mesmerism", "Holy Metronome", "Holy Miracles", "Holy Miscast", "Holy Missing Relatives", "Holy Molars", "Holy Mole Hill", "Holy Mucilage", "Holy Multitudes", "Holy Murder", "Holy Mush", "Holy Naive", "Holy New Year's Eve", "Holy Nick Of Time", "Holy Nightmare", "Holy Non Sequiturs", "Holy Oleo", "Holy Olfactory", "Holy One Track Bat Computer Mind", "Holy Oversight", "Holy Oxygen", "Holy Paderewski", "Holy Paraffin", "Holy Perfect Pitch", "Holy Pianola", "Holy Pin Cushions", "Holy Polar Front", "Holy Polar Ice Sheet", "Holy Polaris", "Holy Popcorn", "Holy Potluck", "Holy Pressure Cooker", "Holy Priceless Collection of Etruscan Snoods", "Holy Pseudonym", "Holy Purple Cannibals", "Holy Puzzlers", "Holy Rainbow", "Holy Rats In A Trap", "Holy Ravioli", "Holy Razors Edge", "Holy Recompense", "Holy Red Herring", "Holy Red Snapper", "Holy Reincarnation", "Holy Relief", "Holy Remote Control Robot", "Holy Reshevsky", "Holy Return From Oblivion", "Holy Reverse Polarity", "Holy Rheostat", "Holy Ricochet", "Holy Rip Van Winkle", "Holy Rising Hemlines", "Holy Roadblocks", "Holy Robert Louis Stevenson", "Holy Rock Garden", "Holy Rocking Chair", "Holy Romeo And Juliet", "Holy Rudder", "Holy Safari", "Holy Sarcophagus", "Holy Sardine", "Holy Scalding", "Holy Schizophrenia", "Holy Sedatives", "Holy Self Service", "Holy Semantics", "Holy Serpentine", "Holy Sewer Pipe", "Holy Shamrocks", "Holy Sherlock Holmes", "Holy Show-Ups", "Holy Showcase", "Holy Shrinkage", "Holy Shucks", "Holy Skull Tap", "Holy Sky Rocket", "Holy Slipped Disc", "Holy Smoke", "Holy Smokes", "Holy Smokestack", "Holy Snowball", "Holy Sonic Booms", "Holy Special Delivery", "Holy Spider Webs", "Holy Split Seconds", "Holy Squirrel Cage", "Holy Stalactites", "Holy Stampede", "Holy Standstills", "Holy Steam Valve", "Holy Stew Pot", "Holy Stomach Aches", "Holy Stratosphere", "Holy Stuffing", "Holy Subliminal", "Holy Sudden Incapacitation", "Holy Sundials", "Holy Surprise Party", "Holy Switch A Roo", "Holy Taj Mahal", "Holy Tartars", "Holy Taxation", "Holy Taxidermy", "Holy Tee Shot", "Holy Ten Toes", "Holy Terminology", "Holy Time Bomb", "Holy Tintinnabulation", "Holy Tipoffs", "Holy Titanic", "Holy Tome", "Holy Toreador", "Holy Trampoline", "Holy Transistors", "Holy Travel Agent", "Holy Trickery", "Holy Triple Feature", "Holy Trolls And Goblins", "Holy Tuxedo", "Holy Uncanny Photographic Mental Processes", "Holy Understatements", "Holy Underwritten Metropolis", "Holy Unlikelihood", "Holy Unrefillable Prescriptions", "Holy Vat", "Holy Venezuela", "Holy Vertebrae", "Holy Voltage", "Holy Waste Of Energy", "Holy Wayne Manor", "Holy Weaponry", "Holy Wedding Cake", "Holy Wernher von Braun", "Holy Whiskers", "Holy Wigs", "Holy Zorro"]
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.defaultSchema = {
                componentAttribute: "data-component",
                refAttribute: "data-ref"
            }
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Manager = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(15),
                o = n(3);
            e.Manager = function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.application = e, this.observer = new o.TokenObserver(this.element, this.componentAttribute, this), this.modulesBySlug = new Map
                }
                return i(t, [{
                    key: "start",
                    value: function() {
                        this.observer.start()
                    }
                }, {
                    key: "stop",
                    value: function() {
                        this.observer.stop()
                    }
                }, {
                    key: "addModule",
                    value: function(t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            n = arguments[2],
                            i = t.slug;
                        this.removeModule(i);
                        var o = new r.Module(this.application, t, n);
                        this.modulesBySlug.set(i, o), this._initModule(o, e)
                    }
                }, {
                    key: "removeModule",
                    value: function(t) {
                        var e = this.modulesBySlug.get(t);
                        e && (this.modulesBySlug.delete(t), this._destroyModule(e))
                    }
                }, {
                    key: "elementMatchedToken",
                    value: function(t, e) {
                        this._initModuleBySlug(e, t)
                    }
                }, {
                    key: "elementUnmatchedToken",
                    value: function(t, e) {
                        this._destroyModuleBySlug(e, t)
                    }
                }, {
                    key: "_initModule",
                    value: function(t, e) {
                        var n = this.observer.getElementsMatchingToken(t.slug);
                        if (e) t.initNoElement(t.slug, t.args);
                        else {
                            var i = !0,
                                r = !1,
                                o = void 0;
                            try {
                                for (var a, s = n[Symbol.iterator](); !(i = (a = s.next()).done); i = !0) {
                                    var c = a.value;
                                    t.initElement(c, t.args)
                                }
                            } catch (t) {
                                r = !0, o = t
                            } finally {
                                try {
                                    !i && s.return && s.return()
                                } finally {
                                    if (r) throw o
                                }
                            }
                        }
                    }
                }, {
                    key: "_destroyModule",
                    value: function(t) {
                        var e = t.contexts,
                            n = !0,
                            i = !1,
                            r = void 0;
                        try {
                            for (var o, a = e[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                var s = o.value.element;
                                t.destroyElement(s)
                            }
                        } catch (t) {
                            i = !0, r = t
                        } finally {
                            try {
                                !n && a.return && a.return()
                            } finally {
                                if (i) throw r
                            }
                        }
                    }
                }, {
                    key: "_initModuleBySlug",
                    value: function(t, e) {
                        var n = this.modulesBySlug.get(t);
                        n && n.initElement(e, n.args)
                    }
                }, {
                    key: "_destroyModuleBySlug",
                    value: function(t, e) {
                        var n = this.modulesBySlug.get(t);
                        n && n.destroyElement(e)
                    }
                }, {
                    key: "schema",
                    get: function() {
                        return this.application.schema
                    }
                }, {
                    key: "element",
                    get: function() {
                        return this.application.element
                    }
                }, {
                    key: "componentAttribute",
                    get: function() {
                        return this.schema.componentAttribute
                    }
                }, {
                    key: "modules",
                    get: function() {
                        return Array.from(this.modulesBySlug.values())
                    }
                }, {
                    key: "contexts",
                    get: function() {
                        return this.modules.reduce(function(t, e) {
                            return t.concat(Array.from(e.contexts))
                        }, [])
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Module = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(16);
            e.Module = function() {
                function t(e, n, i) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.application = e, this.definition = n, this.args = i, this.contextsByElement = new WeakMap, this.contextsByNoElement = new Map, this.initializedContexts = new Set
                }
                return i(t, [{
                    key: "initElement",
                    value: function(t, e) {
                        var n = this._fetchContextForElement(t, e);
                        n && !this.initializedContexts.has(n) && (this.initializedContexts.add(n), n.init(), n.bindAll())
                    }
                }, {
                    key: "initNoElement",
                    value: function(t, e) {
                        var n = this._fetchContextForNoElement(t, e);
                        n && !this.initializedContexts.has(n) && (this.initializedContexts.add(n), n.bindAll())
                    }
                }, {
                    key: "destroyElement",
                    value: function(t) {
                        var e = this._fetchContextForElement(t);
                        e && this.initializedContexts.has(e) && (this.initializedContexts.delete(e), e.unbindAll(), e.unsubscribeAll(), e.destroy())
                    }
                }, {
                    key: "destroyNoElement",
                    value: function(t) {
                        var e = this._fetchContextForNoElement(t);
                        e && this.initializedContexts.has(e) && (this.initializedContexts.delete(e), e.unbindAll(), e.unsubscribeAll(), e.destroy())
                    }
                }, {
                    key: "_fetchContextForElement",
                    value: function(t, e) {
                        var n = this.contextsByElement.get(t);
                        return n || (n = new r.Context(this, t, e), this.contextsByElement.set(t, n)), n
                    }
                }, {
                    key: "_fetchContextForNoElement",
                    value: function(t, e) {
                        var n = this.contextsByNoElement.get(t);
                        return n || (n = new r.Context(this, null, e), this.contextsByNoElement.set(t, n)), n
                    }
                }, {
                    key: "slug",
                    get: function() {
                        return this.definition.slug
                    }
                }, {
                    key: "ComponentConstructor",
                    get: function() {
                        return this.definition.ComponentConstructor
                    }
                }, {
                    key: "contexts",
                    get: function() {
                        return Array.from(this.initializedContexts)
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Context = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(17);

            function o(t) {
                if (Array.isArray(t)) {
                    for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
                    return n
                }
                return Array.from(t)
            }
            e.Context = function() {
                function t(e, n, i) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.module = e, this.element = n;
                    var a = i || [null],
                        s = this.module.application.props;
                    if (this.scope = new r.Scope(this.schema, this.slug, n, s), n) try {
                        this.component = new(Function.prototype.bind.apply(e.ComponentConstructor, [null].concat([this], o(a)))), this.component.load()
                    } catch (t) {
                        this.handleError(t, "loading component [" + this.slug + "]")
                    } else this.component = new(Function.prototype.bind.apply(e.ComponentConstructor, [null].concat([this], o(a)))), this.init()
                }
                return i(t, [{
                    key: "init",
                    value: function() {
                        try {
                            this.component.init()
                        } catch (t) {
                            this.handleError(t, "initializing component [" + this.slug + "]")
                        }
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        try {
                            this.component.destroy()
                        } catch (t) {
                            this.handleError(t, "destroying component [" + this.slug + "]")
                        }
                    }
                }, {
                    key: "bindAll",
                    value: function() {
                        try {
                            this.component.bindAll()
                        } catch (t) {
                            this.handleError(t, "binding component [" + this.slug + "]")
                        }
                    }
                }, {
                    key: "unbindAll",
                    value: function() {
                        try {
                            this.component.unbindAll()
                        } catch (t) {
                            this.handleError(t, "unbinding component [" + this.slug + "]")
                        }
                    }
                }, {
                    key: "unsubscribeAll",
                    value: function() {
                        try {
                            this.component.unsubscribeAll()
                        } catch (t) {
                            this.handleError(t, "unsubscribing component [" + this.slug + "]")
                        }
                    }
                }, {
                    key: "handleError",
                    value: function(t, e) {
                        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                            i = this.identifier,
                            r = this.component,
                            o = this.element;
                        n = Object.assign({
                            identifier: i,
                            component: r,
                            element: o
                        }, n), this.application.handleError(t, e, n)
                    }
                }, {
                    key: "application",
                    get: function() {
                        return this.module.application
                    }
                }, {
                    key: "slug",
                    get: function() {
                        return this.module.slug
                    }
                }, {
                    key: "schema",
                    get: function() {
                        return this.application.schema
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Scope = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(18);
            e.Scope = function() {
                function t(e, n, i, o) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.schema = e, this.slug = n, this.element = i, this.props = o, this.data = new r.Data(this)
                }
                return i(t, [{
                    key: "getRefs",
                    value: function() {
                        var t = {},
                            e = this.element.querySelectorAll(this.refSelector),
                            n = !0,
                            i = !1,
                            r = void 0;
                        try {
                            for (var o, a = Array.from(e)[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                var s = o.value,
                                    c = this.getRefName(s);
                                t[c] ? Array.isArray(t[c]) ? t[c].push(s) : t[c] = [t[c], s] : t[c] = s
                            }
                        } catch (t) {
                            i = !0, r = t
                        } finally {
                            try {
                                !n && a.return && a.return()
                            } finally {
                                if (i) throw r
                            }
                        }
                        return t
                    }
                }, {
                    key: "getRefName",
                    value: function(t) {
                        var e = this;
                        return t.getAttribute(this.refAttribute).split(" ").find(function(t) {
                            return t.match(e.slug + ".")
                        }).replace(this.slug + ".", "")
                    }
                }, {
                    key: "refs",
                    get: function() {
                        return this.getRefs()
                    }
                }, {
                    key: "refAttribute",
                    get: function() {
                        return this.schema.refAttribute
                    }
                }, {
                    key: "refSelector",
                    get: function() {
                        return "[" + this.refAttribute + "*='" + this.slug + ".']"
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = function() {
                function t(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }
                return function(e, n, i) {
                    return n && t(e.prototype, n), i && t(e, i), e
                }
            }();
            e.Data = function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.scope = e
                }
                return i(t, [{
                    key: "get",
                    value: function(t) {
                        var e = this._getFormattedKey(t);
                        return this.element.getAttribute(e)
                    }
                }, {
                    key: "set",
                    value: function(t, e) {
                        var n = this._getFormattedKey(t);
                        return this.element.setAttribute(n, e), this.get(t)
                    }
                }, {
                    key: "has",
                    value: function(t) {
                        var e = this._getFormattedKey(t);
                        return this.element.hasAttribute(e)
                    }
                }, {
                    key: "delete",
                    value: function(t) {
                        if (this.has(t)) {
                            var e = this._getFormattedKey(t);
                            return this.element.removeAttribute(e), !0
                        }
                        return !1
                    }
                }, {
                    key: "_getFormattedKey",
                    value: function(t) {
                        return "data-" + this.slug + "-" + function(t) {
                            return t.toString().replace(/([A-Z])/g, function(t, e) {
                                return "-" + e.toLowerCase()
                            })
                        }(t)
                    }
                }, {
                    key: "element",
                    get: function() {
                        return this.scope.element
                    }
                }, {
                    key: "slug",
                    get: function() {
                        return this.scope.slug
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TokenObserver = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(3),
                o = n(0);
            e.TokenObserver = function() {
                function t(e, n, i) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.attributeName = n, this.delegate = i, this.elementObserver = new r.ElementObserver(e, this), this.tokensByElement = new o.IndexedMultimap
                }
                return i(t, [{
                    key: "start",
                    value: function() {
                        this.elementObserver.start()
                    }
                }, {
                    key: "stop",
                    value: function() {
                        this.elementObserver.stop()
                    }
                }, {
                    key: "refresh",
                    value: function() {
                        this.elementObserver.refresh()
                    }
                }, {
                    key: "getElementsMatchingToken",
                    value: function(t) {
                        return this.tokensByElement.getKeysForValue(t)
                    }
                }, {
                    key: "matchElement",
                    value: function(t) {
                        return t.hasAttribute(this.attributeName)
                    }
                }, {
                    key: "matchElementsInTree",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.element,
                            e = this.matchElement(t) ? [t] : [],
                            n = Array.from(t.querySelectorAll(this.selector));
                        return e.concat(n)
                    }
                }, {
                    key: "elementMatched",
                    value: function(t) {
                        var e = Array.from(this._readTokenSetForElement(t)),
                            n = !0,
                            i = !1,
                            r = void 0;
                        try {
                            for (var o, a = e[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                var s = o.value;
                                this._elementMatchedToken(t, s)
                            }
                        } catch (t) {
                            i = !0, r = t
                        } finally {
                            try {
                                !n && a.return && a.return()
                            } finally {
                                if (i) throw r
                            }
                        }
                    }
                }, {
                    key: "elementUnmatched",
                    value: function(t) {
                        var e = this._getTokensForElement(t),
                            n = !0,
                            i = !1,
                            r = void 0;
                        try {
                            for (var o, a = e[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                var s = o.value;
                                this._elementUnmatchedToken(t, s)
                            }
                        } catch (t) {
                            i = !0, r = t
                        } finally {
                            try {
                                !n && a.return && a.return()
                            } finally {
                                if (i) throw r
                            }
                        }
                    }
                }, {
                    key: "elementAttributeChanged",
                    value: function(t) {
                        var e = this._readTokenSetForElement(t),
                            n = !0,
                            i = !1,
                            r = void 0;
                        try {
                            for (var o, a = Array.from(e)[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                var s = o.value;
                                this.elementMatched(t, s)
                            }
                        } catch (t) {
                            i = !0, r = t
                        } finally {
                            try {
                                !n && a.return && a.return()
                            } finally {
                                if (i) throw r
                            }
                        }
                        var c = !0,
                            l = !1,
                            h = void 0;
                        try {
                            for (var u, p = this._getTokensForElement(t)[Symbol.iterator](); !(c = (u = p.next()).done); c = !0) {
                                var d = u.value;
                                e.has(d) || this.elementUnmatched(t, d)
                            }
                        } catch (t) {
                            l = !0, h = t
                        } finally {
                            try {
                                !c && p.return && p.return()
                            } finally {
                                if (l) throw h
                            }
                        }
                    }
                }, {
                    key: "_elementMatchedToken",
                    value: function(t, e) {
                        this.tokensByElement.has(t, e) || (this.tokensByElement.add(t, e), this.delegate.elementMatchedToken && this.delegate.elementMatchedToken(t, e, this.attributeName))
                    }
                }, {
                    key: "_elementUnmatchedToken",
                    value: function(t, e) {
                        this.tokensByElement.has(t, e) && (this.tokensByElement.delete(t, e), this.delegate.elementUnmatchedToken && this.delegate.elementUnmatchedToken(t, e, this.attributeName))
                    }
                }, {
                    key: "_getTokensForElement",
                    value: function(t) {
                        return this.tokensByElement.getValuesForKey(t)
                    }
                }, {
                    key: "_readTokenSetForElement",
                    value: function(t) {
                        var e = new Set,
                            n = t.getAttribute(this.attributeName) || "",
                            i = !0,
                            r = !1,
                            o = void 0;
                        try {
                            for (var a, s = n.split(/\s+/)[Symbol.iterator](); !(i = (a = s.next()).done); i = !0) {
                                var c = a.value;
                                c.length && e.add(c)
                            }
                        } catch (t) {
                            r = !0, o = t
                        } finally {
                            try {
                                !i && s.return && s.return()
                            } finally {
                                if (r) throw o
                            }
                        }
                        return e
                    }
                }, {
                    key: "selector",
                    get: function() {
                        return "[" + this.attributeName + "]"
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.IndexedMultimap = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = function t(e, n, i) {
                    null === e && (e = Function.prototype);
                    var r = Object.getOwnPropertyDescriptor(e, n);
                    if (void 0 === r) {
                        var o = Object.getPrototypeOf(e);
                        return null === o ? void 0 : t(o, n, i)
                    }
                    if ("value" in r) return r.value;
                    var a = r.get;
                    return void 0 !== a ? a.call(i) : void 0
                },
                o = n(2),
                a = n(4);
            e.IndexedMultimap = function(t) {
                function e() {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e);
                    var t = function(t, e) {
                        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !e || "object" != typeof e && "function" != typeof e ? t : e
                    }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                    return t.keysByValue = new Map, t
                }
                return function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }(e, o.Multimap), i(e, [{
                    key: "add",
                    value: function(t, n) {
                        r(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "add", this).call(this, t, n), (0, a.add)(this.keysByValue, n, t)
                    }
                }, {
                    key: "delete",
                    value: function(t, n) {
                        r(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "delete", this).call(this, t, n), (0, a.del)(this.keysByValue, n, t)
                    }
                }, {
                    key: "hasValue",
                    value: function(t) {
                        return this.keysByValue.has(t)
                    }
                }, {
                    key: "getKeysForValue",
                    value: function(t) {
                        var e = this.keysByValue.get(t);
                        return e ? Array.from(e) : []
                    }
                }, {
                    key: "values",
                    get: function() {
                        return Array.from(this.keysByValue.keys())
                    }
                }]), e
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = function() {
                function t(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }
                return function(e, n, i) {
                    return n && t(e.prototype, n), i && t(e, i), e
                }
            }();
            e.ElementObserver = function() {
                function t(e, n) {
                    var i = this;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.element = e, this.delegate = n, this.started = !1, this.elements = new Set, this.mutationObserver = new MutationObserver(function(t) {
                        return i._processMutations(t)
                    })
                }
                return i(t, [{
                    key: "start",
                    value: function() {
                        this.started || (this.mutationObserver.observe(this.element, {
                            attributes: !0,
                            childList: !0,
                            subtree: !0
                        }), this.started = !0, this.refresh())
                    }
                }, {
                    key: "stop",
                    value: function() {
                        this.started && (this.mutationObserver.takeRecords(), this.mutationObserver.disconnect(), this.started = !1)
                    }
                }, {
                    key: "refresh",
                    value: function() {
                        if (this.started) {
                            var t = new Set(this._matchElementsInTree()),
                                e = !0,
                                n = !1,
                                i = void 0;
                            try {
                                for (var r, o = Array.from(this.elements)[Symbol.iterator](); !(e = (r = o.next()).done); e = !0) {
                                    var a = r.value;
                                    t.has(a) || this._removeElement(a)
                                }
                            } catch (t) {
                                n = !0, i = t
                            } finally {
                                try {
                                    !e && o.return && o.return()
                                } finally {
                                    if (n) throw i
                                }
                            }
                            var s = !0,
                                c = !1,
                                l = void 0;
                            try {
                                for (var h, u = Array.from(t)[Symbol.iterator](); !(s = (h = u.next()).done); s = !0) {
                                    var p = h.value;
                                    this._addElement(p)
                                }
                            } catch (t) {
                                c = !0, l = t
                            } finally {
                                try {
                                    !s && u.return && u.return()
                                } finally {
                                    if (c) throw l
                                }
                            }
                        }
                    }
                }, {
                    key: "_matchElement",
                    value: function(t) {
                        return this.delegate.matchElement(t)
                    }
                }, {
                    key: "_matchElementsInTree",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.element;
                        return this.delegate.matchElementsInTree(t)
                    }
                }, {
                    key: "_processMutations",
                    value: function(t) {
                        var e = !0,
                            n = !1,
                            i = void 0;
                        try {
                            for (var r, o = t[Symbol.iterator](); !(e = (r = o.next()).done); e = !0) {
                                var a = r.value;
                                this._processMutation(a)
                            }
                        } catch (t) {
                            n = !0, i = t
                        } finally {
                            try {
                                !e && o.return && o.return()
                            } finally {
                                if (n) throw i
                            }
                        }
                    }
                }, {
                    key: "_processMutation",
                    value: function(t) {
                        "attributes" === t.type ? this._processAttributeChange(t.target, t.attributeName) : "childList" === t.type && (this._processRemovedNodes(t.removedNodes), this._processAddedNodes(t.addedNodes))
                    }
                }, {
                    key: "_processAttributeChange",
                    value: function(t, e) {
                        var n = t;
                        this.elements.has(n) ? this.delegate.elementAttributeChanged && this._matchElement(n) ? this.delegate.elementAttributeChanged(n, e) : this._removeElement(n) : this._matchElement(n) && this._addElement(n)
                    }
                }, {
                    key: "_processRemovedNodes",
                    value: function(t) {
                        var e = !0,
                            n = !1,
                            i = void 0;
                        try {
                            for (var r, o = Array.from(t)[Symbol.iterator](); !(e = (r = o.next()).done); e = !0) {
                                var a = r.value;
                                this._processNode(a, this._removeElement)
                            }
                        } catch (t) {
                            n = !0, i = t
                        } finally {
                            try {
                                !e && o.return && o.return()
                            } finally {
                                if (n) throw i
                            }
                        }
                    }
                }, {
                    key: "_processAddedNodes",
                    value: function(t) {
                        var e = !0,
                            n = !1,
                            i = void 0;
                        try {
                            for (var r, o = Array.from(t)[Symbol.iterator](); !(e = (r = o.next()).done); e = !0) {
                                var a = r.value;
                                this._processNode(a, this._addElement)
                            }
                        } catch (t) {
                            n = !0, i = t
                        } finally {
                            try {
                                !e && o.return && o.return()
                            } finally {
                                if (n) throw i
                            }
                        }
                    }
                }, {
                    key: "_processNode",
                    value: function(e, n) {
                        var i = t.elementFromNode(e);
                        if (i) {
                            var r = !0,
                                o = !1,
                                a = void 0;
                            try {
                                for (var s, c = this._matchElementsInTree(i)[Symbol.iterator](); !(r = (s = c.next()).done); r = !0) {
                                    var l = s.value;
                                    n.call(this, l)
                                }
                            } catch (t) {
                                o = !0, a = t
                            } finally {
                                try {
                                    !r && c.return && c.return()
                                } finally {
                                    if (o) throw a
                                }
                            }
                        }
                    }
                }, {
                    key: "_addElement",
                    value: function(t) {
                        this.elements.has(t) || (this.elements.add(t), this.delegate.elementMatched && this.delegate.elementMatched(t))
                    }
                }, {
                    key: "_removeElement",
                    value: function(t) {
                        this.elements.has(t) && (this.elements.delete(t), this.delegate.elementUnmatched && this.delegate.elementUnmatched(t))
                    }
                }], [{
                    key: "elementFromNode",
                    value: function(t) {
                        return t.nodeType === Node.ELEMENT_NODE && t
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.customEvents = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(0),
                o = n(5),
                a = n(6),
                s = function() {
                    function t() {
                        ! function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), this._types = new Set, this._typesByScope = new r.Multimap, this._eventByType = new Map, this._componentsByType = new r.Multimap
                    }
                    return i(t, [{
                        key: "getScope",
                        value: function(t) {
                            return this._typesByScope.getKeysForValue(t)[0]
                        }
                    }, {
                        key: "getEvent",
                        value: function(t) {
                            return this._eventByType.get(t)
                        }
                    }, {
                        key: "add",
                        value: function(t, e) {
                            var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                i = e || new a.CustomEvent(t, n),
                                r = i.scope || "component";
                            this._types.add(t), this._typesByScope.add(r, t), this._eventByType.set(t, i), "global" === r && o.ee.add(t, i.log)
                        }
                    }, {
                        key: "bind",
                        value: function(t, e, n) {
                            var i = this.getScope(t),
                                r = this.getEvent(t);
                            "global" === i ? (this._componentsByType.getValuesForKey(t).includes(e) || r.bind(e, o.ee, n), this._componentsByType.add(t, e)) : r.bind(e, o.ee, n)
                        }
                    }, {
                        key: "unbind",
                        value: function(t, e) {
                            var n = this.getScope(t),
                                i = this.getEvent(t);
                            "global" === n ? (this._componentsByType.delete(t, e), this._componentsByType.hasValue(e) || i.unbind(e, o.ee)) : i.unbind(e, o.ee)
                        }
                    }, {
                        key: "events",
                        get: function() {
                            return Array.from(this.types)
                        }
                    }, {
                        key: "types",
                        get: function() {
                            return this._types
                        }
                    }]), t
                }();
            e.customEvents = new s
        }, function(t, e, n) {
            "use strict";
            var i = Object.prototype.hasOwnProperty,
                r = "~";

            function o() {}

            function a(t, e, n, i, o) {
                if ("function" != typeof n) throw new TypeError("The listener must be a function");
                var a = new function(t, e, n) {
                        this.fn = t, this.context = e, this.once = n || !1
                    }(n, i || t, o),
                    s = r ? r + e : e;
                return t._events[s] ? t._events[s].fn ? t._events[s] = [t._events[s], a] : t._events[s].push(a) : (t._events[s] = a, t._eventsCount++), t
            }

            function s(t, e) {
                0 == --t._eventsCount ? t._events = new o : delete t._events[e]
            }

            function c() {
                this._events = new o, this._eventsCount = 0
            }
            Object.create && (o.prototype = Object.create(null), (new o).__proto__ || (r = !1)), c.prototype.eventNames = function() {
                var t, e, n = [];
                if (0 === this._eventsCount) return n;
                for (e in t = this._events) i.call(t, e) && n.push(r ? e.slice(1) : e);
                return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n
            }, c.prototype.listeners = function(t) {
                var e = r ? r + t : t,
                    n = this._events[e];
                if (!n) return [];
                if (n.fn) return [n.fn];
                for (var i = 0, o = n.length, a = new Array(o); i < o; i++) a[i] = n[i].fn;
                return a
            }, c.prototype.listenerCount = function(t) {
                var e = r ? r + t : t,
                    n = this._events[e];
                return n ? n.fn ? 1 : n.length : 0
            }, c.prototype.emit = function(t, e, n, i, o, a) {
                var s = r ? r + t : t;
                if (!this._events[s]) return !1;
                var c, l, h = this._events[s],
                    u = arguments.length;
                if (h.fn) {
                    switch (h.once && this.removeListener(t, h.fn, void 0, !0), u) {
                        case 1:
                            return h.fn.call(h.context), !0;
                        case 2:
                            return h.fn.call(h.context, e), !0;
                        case 3:
                            return h.fn.call(h.context, e, n), !0;
                        case 4:
                            return h.fn.call(h.context, e, n, i), !0;
                        case 5:
                            return h.fn.call(h.context, e, n, i, o), !0;
                        case 6:
                            return h.fn.call(h.context, e, n, i, o, a), !0
                    }
                    for (l = 1, c = new Array(u - 1); l < u; l++) c[l - 1] = arguments[l];
                    h.fn.apply(h.context, c)
                } else {
                    var p, d = h.length;
                    for (l = 0; l < d; l++) switch (h[l].once && this.removeListener(t, h[l].fn, void 0, !0), u) {
                        case 1:
                            h[l].fn.call(h[l].context);
                            break;
                        case 2:
                            h[l].fn.call(h[l].context, e);
                            break;
                        case 3:
                            h[l].fn.call(h[l].context, e, n);
                            break;
                        case 4:
                            h[l].fn.call(h[l].context, e, n, i);
                            break;
                        default:
                            if (!c)
                                for (p = 1, c = new Array(u - 1); p < u; p++) c[p - 1] = arguments[p];
                            h[l].fn.apply(h[l].context, c)
                    }
                }
                return !0
            }, c.prototype.on = function(t, e, n) {
                return a(this, t, e, n, !1)
            }, c.prototype.once = function(t, e, n) {
                return a(this, t, e, n, !0)
            }, c.prototype.removeListener = function(t, e, n, i) {
                var o = r ? r + t : t;
                if (!this._events[o]) return this;
                if (!e) return s(this, o), this;
                var a = this._events[o];
                if (a.fn) a.fn !== e || i && !a.once || n && a.context !== n || s(this, o);
                else {
                    for (var c = 0, l = [], h = a.length; c < h; c++)(a[c].fn !== e || i && !a[c].once || n && a[c].context !== n) && l.push(a[c]);
                    l.length ? this._events[o] = 1 === l.length ? l[0] : l : s(this, o)
                }
                return this
            }, c.prototype.removeAllListeners = function(t) {
                var e;
                return t ? (e = r ? r + t : t, this._events[e] && s(this, e)) : (this._events = new o, this._eventsCount = 0), this
            }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = r, c.EventEmitter = c, t.exports = c
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ucfirst = function(t) {
                return t.charAt(0).toUpperCase() + t.slice(1)
            }, e.lcfirst = function(t) {
                return t.charAt(0).toLowerCase() + t.slice(1)
            }, e.$parent = function t(e, n) {
                if (e.parentNode && "function" == typeof e.parentNode.matches) return e.parentNode.matches(n) ? e.parentNode : t(e.parentNode, n)
            }
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.mixedEvents = void 0;
            var i = n(0),
                r = {
                    enter: ["mouseenter", "touchstart"],
                    leave: ["mouseleave", "touchend"],
                    move: ["mousemove", "touchmove"],
                    over: ["mouseover", "touchmove"],
                    out: ["mouseout", "touchmove"]
                },
                o = e.mixedEvents = new i.Multimap;
            Object.keys(r).forEach(function(t) {
                r[t].forEach(function(e) {
                    o.add(t, e)
                })
            })
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.passiveEvents = ["scroll", "wheel", "touchstart", "touchmove", "touchend"]
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.subscribers = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(0);

            function o(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }
            var a = function() {
                    function t(e) {
                        o(this, t), this._component = e, this._callbacksByName = new r.Multimap
                    }
                    return i(t, [{
                        key: "on",
                        value: function(t, e) {
                            return this._callbacksByName.add(t, e), this
                        }
                    }, {
                        key: "trigger",
                        value: function(t) {
                            for (var e = this, n = arguments.length, i = Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                            this._callbacksByName.getValuesForKey(t).forEach(function(t) {
                                t.apply.apply(t, [e._component].concat(i))
                            })
                        }
                    }, {
                        key: "component",
                        get: function() {
                            return this._component
                        }
                    }]), t
                }(),
                s = function() {
                    function t() {
                        o(this, t), this._componentsBySlug = new r.Multimap, this._subscribersBySlug = new r.Multimap
                    }
                    return i(t, [{
                        key: "add",
                        value: function(t, e) {
                            if (this._componentsBySlug.has(e, t)) return this._subscribersBySlug.getValuesForKey(e).filter(function(e) {
                                return e.component === t
                            })[0];
                            var n = new a(t);
                            return this._componentsBySlug.add(e, t), this._subscribersBySlug.add(e, n), n
                        }
                    }, {
                        key: "remove",
                        value: function(t) {
                            var e = this;
                            this._componentsBySlug.hasValue(t) && this._componentsBySlug.getKeysForValue(t).forEach(function(n) {
                                e._componentsBySlug.delete(n, t), e._subscribersBySlug.getValuesForKey(n).forEach(function(i) {
                                    i.component === t && e._subscribersBySlug.delete(n, i)
                                })
                            })
                        }
                    }, {
                        key: "emit",
                        value: function(t) {
                            for (var e = t.slug, n = arguments.length, i = Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                            var o = i[0],
                                a = i.slice(1);
                            this._subscribersBySlug.hasKey(e) && this._subscribersBySlug.getValuesForKey(e).forEach(function(t) {
                                t.trigger(o, a)
                            })
                        }
                    }]), t
                }();
            e.subscribers = new s
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Handler = void 0;
            var i = function(t, e) {
                    if (Array.isArray(t)) return t;
                    if (Symbol.iterator in Object(t)) return function(t, e) {
                        var n = [],
                            i = !0,
                            r = !1,
                            o = void 0;
                        try {
                            for (var a, s = t[Symbol.iterator](); !(i = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); i = !0);
                        } catch (t) {
                            r = !0, o = t
                        } finally {
                            try {
                                !i && s.return && s.return()
                            } finally {
                                if (r) throw o
                            }
                        }
                        return n
                    }(t, e);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                },
                r = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                o = function(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }(n(29)),
                a = n(7),
                s = n(1);

            function c(t) {
                if (Array.isArray(t)) {
                    for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
                    return n
                }
                return Array.from(t)
            }
            e.Handler = function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.context = e, this.plugins = e.module.application.plugins
                }
                return r(t, null, [{
                    key: "events",
                    get: function() {
                        return this._events || Object.defineProperty(this, "_events", {
                            value: Object.getOwnPropertyNames(this.prototype).filter(function(t) {
                                return /^on/.test(t)
                            }).map(function(t) {
                                return (0, a.lcfirst)(t.slice(2))
                            })
                        })._events
                    }
                }]), r(t, [{
                    key: "getMethod",
                    value: function(t) {
                        var e = t;
                        if (s.mixedEvents.hasValue(t) && this.constructor.events.includes(s.mixedEvents.getKeysForValue(t)[0])) {
                            var n = s.mixedEvents.getKeysForValue(t);
                            e = i(n, 1)[0]
                        }
                        return "on" + (0, a.ucfirst)(e)
                    }
                }, {
                    key: "getCustomOptions",
                    value: function(t) {
                        return this["options" + (0, a.ucfirst)(t)] || !1
                    }
                }, {
                    key: "getCategory",
                    value: function(t) {
                        return s.customEvents.getScope(t) ? "custom" : s.mixedEvents.hasKey(t) ? "mixed" : !!this[this.getMethod(t)] && "native"
                    }
                }, {
                    key: "_bindEvent",
                    value: function(e) {
                        var n = this,
                            i = this.getCategory(e);
                        switch (i || this.context.handleError(new Error, "Unknown event type [" + e + "]"), i) {
                            case "custom":
                                s.customEvents.bind(e, this, this.getCustomOptions(e));
                                break;
                            case "mixed":
                                s.mixedEvents.getValuesForKey(e).forEach(function(e) {
                                    n.context.element.addEventListener(e, n, t.getOptions(e))
                                });
                                break;
                            case "native":
                            default:
                                this.context.element.addEventListener(e, this, t.getOptions(e))
                        }
                    }
                }, {
                    key: "_unbindEvent",
                    value: function(e) {
                        var n = this,
                            i = this.getCategory(e);
                        switch (i || this.context.handleError(new Error, "Unknown event type [" + e + "]"), i) {
                            case "custom":
                                s.customEvents.unbind(e, this);
                                break;
                            case "mixed":
                                s.mixedEvents.getValuesForKey(e).forEach(function(e) {
                                    n.context.element.removeEventListener(e, n, t.getOptions(e))
                                });
                                break;
                            case "native":
                            default:
                                this.context.element.removeEventListener(e, this, t.getOptions(e))
                        }
                    }
                }, {
                    key: "handleEvent",
                    value: function(t) {
                        var e = this,
                            n = s.mixedEvents.getKeysForValue(t.type)[0] || t.type,
                            i = this["delegate" + (0, a.ucfirst)(n)];
                        if (i) {
                            var r = !1,
                                o = null;
                            if ("string" == typeof i) {
                                var l = [].concat(c(this.context.element.querySelectorAll(i)));
                                o = t.target.matches(i) ? t.target : (0, a.$parent)(t.target, i), r = l.indexOf(o) >= 0
                            } else r = (Array.isArray(i) || i instanceof NodeList ? [].concat(c(i)) : [i]).some(function(e) {
                                return !(e !== t.target && !e.contains(t.target) || (o = e, 0))
                            });
                            r && (this[this.getMethod(t.type)](t, o), this.plugins.forEach(function(n) {
                                n.handleEvent && n.handleEvent(e, t)
                            }))
                        } else this[this.getMethod(t.type)](t), this.plugins.forEach(function(n) {
                            n.handleEvent && n.handleEvent(e, t)
                        })
                    }
                }, {
                    key: "bindAll",
                    value: function() {
                        var t = this,
                            e = this.constructor.events || [];
                        e.forEach(function(e) {
                            t._bindEvent(e)
                        }), this.plugins.forEach(function(n) {
                            n.bindAll && n.bindAll(t, e)
                        })
                    }
                }, {
                    key: "unbindAll",
                    value: function() {
                        var t = this,
                            e = this.constructor.events;
                        e.forEach(function(e) {
                            t._unbindEvent(e)
                        }), this.plugins.forEach(function(n) {
                            n.unbindAll && n.unbindAll(t, e)
                        })
                    }
                }, {
                    key: "bind",
                    value: function(t) {
                        this._bindEvent(t)
                    }
                }, {
                    key: "unbind",
                    value: function(t) {
                        this._unbindEvent(t)
                    }
                }, {
                    key: "subscribe",
                    value: function(t) {
                        return s.subscribers.add(this, t)
                    }
                }, {
                    key: "emit",
                    value: function() {
                        for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        s.subscribers.emit.apply(s.subscribers, [this].concat(e))
                    }
                }, {
                    key: "unsubscribeAll",
                    value: function() {
                        s.subscribers.remove(this)
                    }
                }], [{
                    key: "getOptions",
                    value: function(t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                            capture: !1
                        };
                        return s.passiveEvents.includes(t) && (e.passive = !0), !0 === o.default.passiveEvents ? e : e.capture
                    }
                }]), t
            }()
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = s(n(30)),
                r = s(n(31)),
                o = s(n(32)),
                a = s(n(33));

            function s(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            var c = {
                state: {
                    detectHover: i.default,
                    detectPointer: r.default,
                    detectTouchEvents: o.default,
                    detectPassiveEvents: a.default
                },
                update: function() {
                    c.state.detectHover.update(), c.state.detectPointer.update(), c.state.detectTouchEvents.update(), c.state.detectPassiveEvents.update(), c.updateOnlyOwnProperties()
                },
                updateOnlyOwnProperties: function() {
                    "undefined" != typeof window && (c.passiveEvents = c.state.detectPassiveEvents.hasSupport || !1, c.hasTouch = c.state.detectTouchEvents.hasSupport || !1, c.deviceType = function(t, e, n, i) {
                        return t && (e || n) ? "hybrid" : t && Object.keys(i.detectHover).filter(function(t) {
                            return "update" !== t
                        }).every(function(t) {
                            return !1 === i.detectHover[t]
                        }) && Object.keys(i.detectPointer).filter(function(t) {
                            return "update" !== t
                        }).every(function(t) {
                            return !1 === i.detectPointer[t]
                        }) ? window.navigator && /android/.test(window.navigator.userAgent.toLowerCase()) ? "touchOnly" : "hybrid" : t ? "touchOnly" : "mouseOnly"
                    }(c.hasTouch, c.state.detectHover.anyHover, c.state.detectPointer.anyFine, c.state), c.hasMouse = "touchOnly" !== c.deviceType, c.primaryInput = ("mouseOnly" === c.deviceType ? "mouse" : "touchOnly" === c.deviceType && "touch") || c.state.detectPointer.fine && "mouse" || c.state.detectPointer.coarse && "touch" || "mouse", /windows/.test(window.navigator.userAgent.toLowerCase()) && /chrome/.test(window.navigator.userAgent.toLowerCase()) && function(t) {
                        return t >= 59 && t < 62
                    }(parseInt(/Chrome\/([0-9.]+)/.exec(navigator.userAgent)[1], 10)) && c.hasTouch && (c.deviceType = "hybrid", c.hasMouse = !0, c.primaryInput = "mouse"))
                }
            };
            c.updateOnlyOwnProperties(), e.default = c
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = {
                update: function() {
                    "undefined" != typeof window && "function" == typeof window.matchMedia && (i.hover = window.matchMedia("(hover: hover)").matches, i.none = window.matchMedia("(hover: none)").matches || window.matchMedia("(hover: on-demand)").matches, i.anyHover = window.matchMedia("(any-hover: hover)").matches, i.anyNone = window.matchMedia("(any-hover: none)").matches || window.matchMedia("(any-hover: on-demand)").matches)
                }
            };
            i.update(), e.default = i
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = {
                update: function() {
                    "undefined" != typeof window && "function" == typeof window.matchMedia && (i.fine = window.matchMedia("(pointer: fine)").matches, i.coarse = window.matchMedia("(pointer: coarse)").matches, i.none = window.matchMedia("(pointer: none)").matches, i.anyFine = window.matchMedia("(any-pointer: fine)").matches, i.anyCoarse = window.matchMedia("(any-pointer: coarse)").matches, i.anyNone = window.matchMedia("(any-pointer: none)").matches)
                }
            };
            i.update(), e.default = i
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = {
                update: function() {
                    "undefined" != typeof window && (i.hasSupport = "ontouchstart" in window, i.browserSupportsApi = Boolean(window.TouchEvent))
                }
            };
            i.update(), e.default = i
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = {
                update: function() {
                    if ("undefined" != typeof window && "function" == typeof window.addEventListener) {
                        var t = !1,
                            e = Object.defineProperty({}, "passive", {
                                get: function() {
                                    t = !0
                                }
                            }),
                            n = function() {};
                        window.addEventListener("testPassiveEventSupport", n, e), window.removeEventListener("testPassiveEventSupport", n, e), i.hasSupport = t
                    }
                }
            };
            i.update(), e.default = i
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.mixComponent = e.Component = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(1);

            function o(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function s(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }
            var c = e.Component = function(t) {
                function e(t) {
                    o(this, e);
                    var n = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
                    n.context = t;
                    var i = n.scope.props;
                    if (i)
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (n[r] ? n.context.handleError("[" + r + "] already exists!", "initializing props") : n[r] = i[r]);
                    return n
                }
                return s(e, r.Handler), i(e, [{
                    key: "load",
                    value: function() {}
                }, {
                    key: "init",
                    value: function() {}
                }, {
                    key: "destroy",
                    value: function() {}
                }, {
                    key: "scope",
                    get: function() {
                        return this.context.scope
                    }
                }, {
                    key: "$el",
                    get: function() {
                        return this.scope.element
                    }
                }, {
                    key: "$refs",
                    get: function() {
                        return this.scope.refs
                    }
                }, {
                    key: "slug",
                    get: function() {
                        return this.scope.slug
                    }
                }, {
                    key: "data",
                    get: function() {
                        return this.scope.data
                    }
                }]), e
            }();
            e.mixComponent = function() {
                for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                var i = function(t) {
                        function n() {
                            o(this, n);
                            for (var t = arguments.length, i = Array(t), s = 0; s < t; s++) i[s] = arguments[s];
                            var c = i[0],
                                l = i.slice(1),
                                h = a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, c));
                            return e.forEach(function(t) {
                                r(h, new(Function.prototype.bind.apply(t, [null].concat(function(t) {
                                    if (Array.isArray(t)) {
                                        for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
                                        return n
                                    }
                                    return Array.from(t)
                                }(l)))))
                            }), h
                        }
                        return s(n, c), n
                    }(),
                    r = function(t, e) {
                        Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)).forEach(function(n) {
                            n.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/) || Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n))
                        })
                    };
                return e.forEach(function(t) {
                    r(i.prototype, t.prototype), r(i, t)
                }), i
            }
        }, function(t, e, n) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.mixNoComponent = e.NoComponent = void 0;
            var i = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }
                }(),
                r = n(1);

            function o(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function s(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }
            var c = e.NoComponent = function(t) {
                function e(t) {
                    o(this, e);
                    var n = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
                    n.context = t;
                    var i = n.scope.props;
                    if (i)
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (n[r] ? n.context.handleError("[" + r + "] already exists!", "initializing props") : n[r] = i[r]);
                    return n
                }
                return s(e, r.Handler), i(e, [{
                    key: "remove",
                    value: function() {
                        this.context.module.destroyNoElement(this.slug)
                    }
                }, {
                    key: "init",
                    value: function() {}
                }, {
                    key: "destroy",
                    value: function() {}
                }, {
                    key: "scope",
                    get: function() {
                        return this.context.scope
                    }
                }, {
                    key: "slug",
                    get: function() {
                        return this.scope.slug
                    }
                }]), e
            }();
            e.mixNoComponent = function() {
                for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                var i = function(t) {
                        function n() {
                            o(this, n);
                            for (var t = arguments.length, i = Array(t), s = 0; s < t; s++) i[s] = arguments[s];
                            var c = i[0],
                                l = i.slice(1),
                                h = a(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, c));
                            return e.forEach(function(t) {
                                r(h, new(Function.prototype.bind.apply(t, [null].concat(function(t) {
                                    if (Array.isArray(t)) {
                                        for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
                                        return n
                                    }
                                    return Array.from(t)
                                }(l)))))
                            }), h
                        }
                        return s(n, c), n
                    }(),
                    r = function(t, e) {
                        Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)).forEach(function(n) {
                            n.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/) || Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n))
                        })
                    };
                return e.forEach(function(t) {
                    r(i.prototype, t.prototype), r(i, t)
                }), i
            }
        }])
    }, function(t, e, n) {
        t.exports = function() {
            var t = function() {
                function t() {}
                return t.prototype.then = function(n, i) {
                    var r = new t,
                        o = this.s;
                    if (o) {
                        var a = 1 & o ? n : i;
                        if (a) {
                            try {
                                e(r, 1, a(this.v))
                            } catch (t) {
                                e(r, 2, t)
                            }
                            return r
                        }
                        return this
                    }
                    return this.o = function(t) {
                        try {
                            var o = t.v;
                            1 & t.s ? e(r, 1, n ? n(o) : o) : i ? e(r, 1, i(o)) : e(r, 2, o)
                        } catch (t) {
                            e(r, 2, t)
                        }
                    }, r
                }, t
            }();

            function e(n, i, r) {
                if (!n.s) {
                    if (r instanceof t) {
                        if (!r.s) return void(r.o = e.bind(null, n, i));
                        1 & i && (i = r.s), r = r.v
                    }
                    if (r && r.then) return void r.then(e.bind(null, n, i), e.bind(null, n, 2));
                    n.s = i, n.v = r;
                    var o = n.o;
                    o && o(n)
                }
            }

            function n(t, e) {
                try {
                    var n = t()
                } catch (t) {
                    return e(t)
                }
                return n && n.then ? n.then(void 0, e) : n
            }
            var i = {};
            ! function() {
                function n(t) {
                    this.t = t, this.i = null, this.u = null, this.h = null, this.l = null
                }

                function r(t) {
                    return {
                        value: t,
                        done: !0
                    }
                }

                function o(t) {
                    return {
                        value: t,
                        done: !1
                    }
                }
                n.prototype[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))] = function() {
                    return this
                }, n.prototype.p = function(e) {
                    return this.u(e && e.then ? e.then(o) : o(e)), this.i = new t
                }, n.prototype.next = function(n) {
                    var o = this;
                    return o.l = new Promise(function(a) {
                        var s = o.i;
                        if (null === s) {
                            var c = o.t;
                            if (null === c) return a(o.l);

                            function l(t) {
                                o.u(t && t.then ? t.then(r) : r(t)), o.i = null, o.u = null
                            }
                            o.t = null, o.u = a, c(o).then(l, function(e) {
                                if (e === i) l(o.h);
                                else {
                                    var n = new t;
                                    o.u(n), o.i = null, o.u = null, _resolve(n, 2, e)
                                }
                            })
                        } else o.i = null, o.u = a, e(s, 1, n)
                    })
                }, n.prototype.return = function(t) {
                    var n = this;
                    return n.l = new Promise(function(o) {
                        var a = n.i;
                        if (null === a) return null === n.t ? o(n.l) : (n.t = null, o(t && t.then ? t.then(r) : r(t)));
                        n.h = t, n.u = o, n.i = null, e(a, 2, i)
                    })
                }, n.prototype.throw = function(t) {
                    var n = this;
                    return n.l = new Promise(function(i, r) {
                        var o = n.i;
                        if (null === o) return null === n.t ? i(n.l) : (n.t = null, r(t));
                        n.u = i, n.i = null, e(o, 2, t)
                    })
                }
            }();
            var r, o, a = (function(t) {
                var e = t.exports = function(t, e) {
                    return e = e || function() {},
                        function() {
                            var n = !1,
                                i = arguments,
                                r = new Promise(function(e, r) {
                                    var o, a = t.apply({
                                        async: function() {
                                            return n = !0,
                                                function(t, n) {
                                                    t ? r(t) : e(n)
                                                }
                                        }
                                    }, Array.prototype.slice.call(i));
                                    n || (!(o = a) || "object" != typeof o && "function" != typeof o || "function" != typeof o.then ? e(a) : a.then(e, r))
                                });
                            return r.then(e.bind(null, null), e), r
                        }
                };
                e.cb = function(t, n) {
                    return e(function() {
                        var e = Array.prototype.slice.call(arguments);
                        return e.length === t.length - 1 && e.push(this.async()), t.apply(this, e)
                    }, n)
                }
            }(r = {
                exports: {}
            }), r.exports);
            ! function(t) {
                t[t.off = 0] = "off", t[t.error = 1] = "error", t[t.warning = 2] = "warning", t[t.info = 3] = "info", t[t.debug = 4] = "debug"
            }(o || (o = {}));
            var s = o.off,
                c = function(t) {
                    this.m = t
                };
            c.getLevel = function() {
                return s
            }, c.setLevel = function(t) {
                return s = o[t]
            }, c.prototype.error = function() {
                for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                this.P(console.error, o.error, t)
            }, c.prototype.warn = function() {
                for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                this.P(console.warn, o.warning, t)
            }, c.prototype.info = function() {
                for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                this.P(console.info, o.info, t)
            }, c.prototype.debug = function() {
                for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                this.P(console.log, o.debug, t)
            }, c.prototype.P = function(t, e, n) {
                e <= c.getLevel() && t.apply(console, ["[" + this.m + "] "].concat(n))
            };
            var l = function() {
                this.logger = new c("@barba/core"), this.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeAppear", "appear", "afterAppear", "appearCanceled", "before", "beforeLeave", "leave", "afterLeave", "leaveCanceled", "beforeEnter", "enter", "afterEnter", "enterCanceled", "after"], this.registered = new Map, this.init()
            };
            l.prototype.init = function() {
                var t = this;
                this.registered.clear(), this.all.forEach(function(e) {
                    t[e] || (t[e] = function(n, i) {
                        void 0 === i && (i = null), t.registered.has(e) || t.registered.set(e, new Set), t.registered.get(e).add({
                            ctx: i,
                            fn: n
                        })
                    })
                })
            }, l.prototype.do = function(t) {
                for (var e = [], n = arguments.length - 1; n-- > 0;) e[n] = arguments[n + 1];
                if (this.registered.has(t)) {
                    var i = Promise.resolve();
                    return this.registered.get(t).forEach(function(t) {
                        var n = t.ctx ? t.fn.bind(t.ctx) : t.fn;
                        i = i.then(function() {
                            return a(n).apply(void 0, e)
                        })
                    }), i
                }
                return Promise.resolve()
            }, l.prototype.clear = function() {
                var t = this;
                this.all.forEach(function(e) {
                    delete t[e]
                }), this.init()
            }, l.prototype.help = function() {
                this.logger.info("Available hooks: " + this.all.join(","));
                var t = [];
                this.registered.forEach(function(e, n) {
                    return t.push(n)
                }), this.logger.info("Registered hooks: " + t.join(","))
            };
            var h = new l,
                u = function t(e, n, i) {
                    return e instanceof RegExp ? function(t, e) {
                        if (!e) return t;
                        var n = t.source.match(/\((?!\?)/g);
                        if (n)
                            for (var i = 0; i < n.length; i++) e.push({
                                name: i,
                                prefix: null,
                                delimiter: null,
                                optional: !1,
                                repeat: !1,
                                pattern: null
                            });
                        return t
                    }(e, n) : Array.isArray(e) ? function(e, n, i) {
                        for (var r = [], o = 0; o < e.length; o++) r.push(t(e[o], n, i).source);
                        return new RegExp("(?:" + r.join("|") + ")", b(i))
                    }(e, n, i) : function(t, e, n) {
                        return w(g(t, n), e, n)
                    }(e, n, i)
                },
                p = g,
                d = y,
                f = w,
                m = "/",
                v = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");

            function g(t, e) {
                for (var n, i = [], r = 0, o = 0, a = "", s = e && e.delimiter || m, c = e && e.whitelist || void 0, l = !1; null !== (n = v.exec(t));) {
                    var h = n[0],
                        u = n[1],
                        p = n.index;
                    if (a += t.slice(o, p), o = p + h.length, u) a += u[1], l = !0;
                    else {
                        var d = "",
                            f = n[2],
                            g = n[3],
                            y = n[4],
                            b = n[5];
                        if (!l && a.length) {
                            var w = a.length - 1,
                                M = a[w];
                            (!c || c.indexOf(M) > -1) && (d = M, a = a.slice(0, w))
                        }
                        a && (i.push(a), a = "", l = !1);
                        var T = g || y,
                            E = d || s;
                        i.push({
                            name: f || r++,
                            prefix: d,
                            delimiter: E,
                            optional: "?" === b || "*" === b,
                            repeat: "+" === b || "*" === b,
                            pattern: T ? x(T) : "[^" + _(E === s ? E : E + s) + "]+?"
                        })
                    }
                }
                return (a || o < t.length) && i.push(a + t.substr(o)), i
            }

            function y(t) {
                for (var e = new Array(t.length), n = 0; n < t.length; n++) "object" == typeof t[n] && (e[n] = new RegExp("^(?:" + t[n].pattern + ")$"));
                return function(n, i) {
                    for (var r = "", o = i && i.encode || encodeURIComponent, a = 0; a < t.length; a++) {
                        var s = t[a];
                        if ("string" != typeof s) {
                            var c, l = n ? n[s.name] : void 0;
                            if (Array.isArray(l)) {
                                if (!s.repeat) throw new TypeError('Expected "' + s.name + '" to not repeat, but got array');
                                if (0 === l.length) {
                                    if (s.optional) continue;
                                    throw new TypeError('Expected "' + s.name + '" to not be empty')
                                }
                                for (var h = 0; h < l.length; h++) {
                                    if (c = o(l[h], s), !e[a].test(c)) throw new TypeError('Expected all "' + s.name + '" to match "' + s.pattern + '"');
                                    r += (0 === h ? s.prefix : s.delimiter) + c
                                }
                            } else if ("string" != typeof l && "number" != typeof l && "boolean" != typeof l) {
                                if (!s.optional) throw new TypeError('Expected "' + s.name + '" to be ' + (s.repeat ? "an array" : "a string"))
                            } else {
                                if (c = o(String(l), s), !e[a].test(c)) throw new TypeError('Expected "' + s.name + '" to match "' + s.pattern + '", but got "' + c + '"');
                                r += s.prefix + c
                            }
                        } else r += s
                    }
                    return r
                }
            }

            function _(t) {
                return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
            }

            function x(t) {
                return t.replace(/([=!:$\/()])/g, "\\$1")
            }

            function b(t) {
                return t && t.sensitive ? "" : "i"
            }

            function w(t, e, n) {
                for (var i = (n = n || {}).strict, r = !1 !== n.start, o = !1 !== n.end, a = n.delimiter || m, s = [].concat(n.endsWith || []).map(_).concat("$").join("|"), c = r ? "^" : "", l = 0; l < t.length; l++) {
                    var h = t[l];
                    if ("string" == typeof h) c += _(h);
                    else {
                        var u = h.repeat ? "(?:" + h.pattern + ")(?:" + _(h.delimiter) + "(?:" + h.pattern + "))*" : h.pattern;
                        e && e.push(h), c += h.optional ? h.prefix ? "(?:" + _(h.prefix) + "(" + u + "))?" : "(" + u + ")?" : _(h.prefix) + "(" + u + ")"
                    }
                }
                if (o) i || (c += "(?:" + _(a) + ")?"), c += "$" === s ? "$" : "(?=" + s + ")";
                else {
                    var p = t[t.length - 1],
                        d = "string" == typeof p ? p[p.length - 1] === a : void 0 === p;
                    i || (c += "(?:" + _(a) + "(?=" + s + "))?"), d || (c += "(?=" + _(a) + "|" + s + ")")
                }
                return new RegExp(c, b(n))
            }
            u.parse = p, u.compile = function(t, e) {
                return y(g(t, e))
            }, u.tokensToFunction = d, u.tokensToRegExp = f;
            var M = {
                    container: "container",
                    namespace: "namespace",
                    prefix: "data-barba",
                    prevent: "prevent",
                    wrapper: "wrapper"
                },
                T = function() {
                    this.g = M, this.A = new DOMParser
                };
            T.prototype.toString = function(t) {
                return t.outerHTML
            }, T.prototype.toDocument = function(t) {
                return this.A.parseFromString(t, "text/html")
            }, T.prototype.toElement = function(t) {
                var e = document.createElement("div");
                return e.innerHTML = t, e
            }, T.prototype.getHtml = function(t) {
                return void 0 === t && (t = document), this.toString(t.documentElement)
            }, T.prototype.getWrapper = function(t) {
                return void 0 === t && (t = document), t.querySelector("[" + this.g.prefix + '="' + this.g.wrapper + '"]')
            }, T.prototype.getContainer = function(t) {
                return void 0 === t && (t = document), t.querySelector("[" + this.g.prefix + '="' + this.g.container + '"]')
            }, T.prototype.getNamespace = function(t) {
                void 0 === t && (t = document);
                var e = t.querySelector("[" + this.g.prefix + "-" + this.g.namespace + "]");
                return e ? e.getAttribute(this.g.prefix + "-" + this.g.namespace) : null
            }, T.prototype.getHref = function(t) {
                if (t.tagName && "a" === t.tagName.toLowerCase()) {
                    var e = t.getAttribute("href");
                    if (e) return e.baseVal || e
                }
                return null
            };
            var E = new T,
                S = function() {
                    this.T = []
                },
                A = {
                    current: {
                        configurable: !0
                    },
                    previous: {
                        configurable: !0
                    },
                    size: {
                        configurable: !0
                    }
                };
            S.prototype.add = function(t, e) {
                this.T.push({
                    url: t,
                    ns: e
                })
            }, S.prototype.remove = function() {
                this.T.pop()
            }, S.prototype.push = function(t, e) {
                this.add(t, e), window.history && window.history.pushState(null, "", t)
            }, S.prototype.cancel = function() {
                this.remove(), window.history && window.history.back()
            }, A.current.get = function() {
                return this.T[this.T.length - 1]
            }, A.previous.get = function() {
                return this.T.length < 2 ? null : this.T[this.T.length - 2]
            }, A.size.get = function() {
                return this.T.length
            }, Object.defineProperties(S.prototype, A);
            var P = new S,
                L = function(t, e) {
                    try {
                        var n = function() {
                            if (!e.next.html) return Promise.resolve(t).then(function(t) {
                                var n = e.next,
                                    i = e.trigger;
                                if (t) {
                                    var r = E.toElement(t);
                                    n.namespace = E.getNamespace(r), n.container = E.getContainer(r), n.html = t, "popstate" === i ? P.add(n.url.href, n.namespace) : P.push(n.url.href, n.namespace);
                                    var o = E.toDocument(t);
                                    document.title = o.title
                                }
                            })
                        }();
                        return Promise.resolve(n && n.then ? n.then(function() {}) : void 0)
                    } catch (t) {
                        return Promise.reject(t)
                    }
                },
                R = u,
                C = {
                    update: L,
                    nextTick: function() {
                        return new Promise(function(t) {
                            window.requestAnimationFrame(t)
                        })
                    },
                    pathToRegexp: R
                },
                O = function() {
                    return window.location.origin
                },
                I = function(t) {
                    var e = t || window.location.port,
                        n = window.location.protocol;
                    return "" !== e ? parseInt(e, 10) : "https:" === n ? 443 : 80
                },
                D = function(t) {
                    var e, n = t.replace(O(), ""),
                        i = {},
                        r = n.indexOf("#");
                    r >= 0 && (e = n.slice(r + 1), n = n.slice(0, r));
                    var o = n.indexOf("?");
                    return o >= 0 && (i = N(n.slice(o + 1)), n = n.slice(0, o)), {
                        hash: e,
                        path: n,
                        query: i
                    }
                },
                N = function(t) {
                    return t.split("&").reduce(function(t, e) {
                        var n = e.split("=");
                        return t[n[0]] = n[1], t
                    }, {})
                },
                B = function(t) {
                    return t.replace(/(\/#.*|\/|#.*)$/, "")
                },
                H = {
                    getHref: function() {
                        return window.location.href
                    },
                    getOrigin: O,
                    getPort: I,
                    getPath: function(t) {
                        return D(t).path
                    },
                    parse: D,
                    parseQuery: N,
                    clean: B
                },
                F = function(t) {
                    if (this.j = [], "boolean" == typeof t) this.R = t;
                    else {
                        var e = Array.isArray(t) ? t : [t];
                        this.j = e.map(function(t) {
                            return R(t)
                        })
                    }
                };
            F.prototype.checkUrl = function(t) {
                if ("boolean" == typeof this.R) return this.R;
                var e = D(t).path;
                return this.j.some(function(t) {
                    return null !== t.exec(e)
                })
            };
            var k = function(t) {
                function e(e) {
                    t.call(this, e), this.T = new Map
                }
                return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function(t, e, n) {
                    return this.checkUrl(t) || this.T.set(t, {
                        action: n,
                        request: e
                    }), {
                        action: n,
                        request: e
                    }
                }, e.prototype.get = function(t) {
                    return this.T.get(t)
                }, e.prototype.getRequest = function(t) {
                    return this.T.get(t).request
                }, e.prototype.getAction = function(t) {
                    return this.T.get(t).action
                }, e.prototype.has = function(t) {
                    return this.T.has(t)
                }, e.prototype.delete = function(t) {
                    return this.T.delete(t)
                }, e.prototype.update = function(t, e) {
                    var n = Object.assign({}, this.T.get(t), e);
                    return this.T.set(t, n), n
                }, e
            }(F);

            function U(t, e, n) {
                return void 0 === e && (e = 2e3), new Promise(function(i, r) {
                    var o = new XMLHttpRequest;
                    o.onreadystatechange = function() {
                        if (o.readyState === XMLHttpRequest.DONE)
                            if (200 === o.status) i(o.responseText);
                            else if (o.status) {
                            var e = {
                                status: o.status,
                                statusText: o.statusText
                            };
                            n(t, e), r(e)
                        }
                    }, o.ontimeout = function() {
                        var i = new Error("Timeout error [" + e + "]");
                        n(t, i), r(i)
                    }, o.onerror = function() {
                        var e = new Error("Fetch error");
                        n(t, e), r(e)
                    }, o.open("GET", t), o.timeout = e, o.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), o.setRequestHeader("x-barba", "yes"), o.send()
                })
            }
            var z = function() {
                    return !window.history.pushState
                },
                G = function(t) {
                    return !t.el || !t.href
                },
                j = function(t) {
                    var e = t.event;
                    return e.which > 1 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey
                },
                V = function(t) {
                    var e = t.el;
                    return e.hasAttribute("target") && "_blank" === e.target
                },
                W = function(t) {
                    var e = t.el;
                    return void 0 !== e.protocol && window.location.protocol !== e.protocol || void 0 !== e.hostname && window.location.hostname !== e.hostname
                },
                X = function(t) {
                    var e = t.el;
                    return void 0 !== e.port && I() !== I(e.port)
                },
                q = function(t) {
                    var e = t.el;
                    return e.getAttribute && "string" == typeof e.getAttribute("download")
                },
                Y = function(t) {
                    return t.el.hasAttribute(M.prefix + "-" + M.prevent)
                },
                Z = function(t) {
                    return Boolean(t.el.closest("[" + M.prefix + "-" + M.prevent + '="all"]'))
                },
                J = function(t) {
                    return B(t.href) === B(window.location.href)
                },
                K = function(t) {
                    function e(e) {
                        t.call(this, e), this.suite = [], this.tests = new Map, this.init()
                    }
                    return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.init = function() {
                        this.add("pushState", z), this.add("exists", G), this.add("newTab", j), this.add("blank", V), this.add("corsDomain", W), this.add("corsPort", X), this.add("download", q), this.add("preventSelf", Y), this.add("preventAll", Z), this.add("sameUrl", J, !1)
                    }, e.prototype.add = function(t, e, n) {
                        void 0 === n && (n = !0), this.tests.set(t, e), n && this.suite.push(t)
                    }, e.prototype.run = function(t, e, n, i) {
                        return this.tests.get(t)({
                            el: e,
                            event: n,
                            href: i
                        })
                    }, e.prototype.checkLink = function(t, e, n) {
                        var i = this;
                        return this.suite.some(function(r) {
                            return i.run(r, t, e, n)
                        })
                    }, e
                }(F),
                Q = function(t) {
                    void 0 === t && (t = []), this.logger = new c("@barba/core"), this.all = [], this.appear = [], this.k = [{
                        name: "namespace",
                        type: "strings"
                    }, {
                        name: "custom",
                        type: "function"
                    }], t && (this.all = this.all.concat(t)), this.update()
                };
            Q.prototype.add = function(t, e) {
                switch (t) {
                    case "rule":
                        this.k.splice(e.position || 0, 0, e.value);
                        break;
                    case "transition":
                    default:
                        this.all.push(e)
                }
                this.update()
            }, Q.prototype.resolve = function(t, e) {
                var n, i = this;
                void 0 === e && (e = {});
                var r = e.appear ? this.appear : this.all;
                r = r.filter(e.self ? function(t) {
                    return t.name && "self" === t.name
                } : function(t) {
                    return !t.name || "self" !== t.name
                });
                var o = new Map,
                    a = r.find(function(n) {
                        var r = !0,
                            a = {};
                        return !(!e.self || "self" !== n.name) || (i.k.reverse().forEach(function(o) {
                            r && (r = i.O(n, o, t, a), e.appear || (n.from && n.to && (r = i.O(n, o, t, a, "from") && i.O(n, o, t, a, "to")), n.from && !n.to && (r = i.O(n, o, t, a, "from")), !n.from && n.to && (r = i.O(n, o, t, a, "to"))))
                        }), o.set(n, a), r)
                    }),
                    s = o.get(a),
                    c = [];
                if (c.push(e.appear ? "appear" : "page"), e.self && c.push("self"), s) {
                    var l = [a];
                    Object.keys(s).length > 0 && l.push(s), (n = this.logger).info.apply(n, ["Transition found [" + c.join(",") + "]"].concat(l))
                } else this.logger.info("No transition found [" + c.join(",") + "]");
                return a
            }, Q.prototype.update = function() {
                var t = this;
                this.all = this.all.map(function(e) {
                    return t.L(e)
                }).sort(function(t, e) {
                    return t.priority - e.priority
                }).reverse().map(function(t) {
                    return delete t.priority, t
                }), this.appear = this.all.filter(function(t) {
                    return void 0 !== t.appear
                })
            }, Q.prototype.O = function(t, e, n, i, r) {
                var o = !0,
                    a = !1,
                    s = t,
                    c = e.name,
                    l = c,
                    h = c,
                    u = c,
                    p = r ? s[r] : s,
                    d = "to" === r ? n.next : n.current;
                if (r ? p && p[c] : p[c]) {
                    switch (e.type) {
                        case "strings":
                        default:
                            var f = Array.isArray(p[l]) ? p[l] : [p[l]];
                            d[l] && -1 !== f.indexOf(d[l]) && (a = !0), -1 === f.indexOf(d[l]) && (o = !1);
                            break;
                        case "object":
                            var m = Array.isArray(p[h]) ? p[h] : [p[h]];
                            d[h] && (d[h].name && -1 !== m.indexOf(d[h].name) && (a = !0), -1 === m.indexOf(d[h].name) && (o = !1));
                            break;
                        case "function":
                            p[u](n) ? a = !0 : o = !1
                    }
                    a && (r ? (i[r] = i[r] || {}, i[r][c] = s[r][c]) : i[c] = s[c])
                }
                return o
            }, Q.prototype.M = function(t, e, n) {
                var i = 0;
                return (t[e] || t.from && t.from[e] || t.to && t.to[e]) && (i += Math.pow(10, n), t.from && t.from[e] && (i += 1), t.to && t.to[e] && (i += 2)), i
            }, Q.prototype.L = function(t) {
                var e = this;
                t.priority = 0;
                var n = 0;
                return this.k.forEach(function(i, r) {
                    n += e.M(t, i.name, r + 1)
                }), t.priority = n, t
            };
            var $ = function(t) {
                    void 0 === t && (t = []), this.logger = new c("@barba/core"), this.S = !1, this.store = new Q(t)
                },
                tt = {
                    isRunning: {
                        configurable: !0
                    },
                    hasAppear: {
                        configurable: !0
                    },
                    hasSelf: {
                        configurable: !0
                    },
                    shouldWait: {
                        configurable: !0
                    }
                };
            $.prototype.get = function(t, e) {
                return this.store.resolve(t, e)
            }, tt.isRunning.get = function() {
                return this.S
            }, tt.isRunning.set = function(t) {
                this.S = t
            }, tt.hasAppear.get = function() {
                return this.store.appear.length > 0
            }, tt.hasSelf.get = function() {
                return this.store.all.some(function(t) {
                    return "self" === t.name
                })
            }, tt.shouldWait.get = function() {
                return this.store.all.some(function(t) {
                    return t.to && !t.to.route || t.sync
                })
            }, $.prototype.doAppear = function(t) {
                var e = t.data,
                    i = t.transition;
                try {
                    var r = this;

                    function o(t) {
                        r.S = !1
                    }
                    var a = i || {};
                    r.S = !0;
                    var s = n(function() {
                        return Promise.resolve(r.$("beforeAppear", e, a)).then(function() {
                            return Promise.resolve(r.appear(e, a)).then(function() {
                                return Promise.resolve(r.$("afterAppear", e, a)).then(function() {})
                            })
                        })
                    }, function(t) {
                        throw r.S = !1, r.logger.error(t), new Error("Transition error [appear]")
                    });
                    return s && s.then ? s.then(o) : o()
                } catch (t) {
                    return Promise.reject(t)
                }
            }, $.prototype.doPage = function(t) {
                var e = t.data,
                    i = t.transition,
                    r = t.page,
                    o = t.wrapper;
                try {
                    var a = this;

                    function s(t) {
                        a.S = !1
                    }
                    var c = i || {},
                        l = !0 === c.sync || !1;
                    a.S = !0;
                    var h = n(function() {
                        function t() {
                            return Promise.resolve(a.$("before", e, c)).then(function() {
                                function t(t) {
                                    return Promise.resolve(a.$("after", e, c)).then(function() {
                                        return Promise.resolve(a.remove(e)).then(function() {})
                                    })
                                }
                                var i = function() {
                                    if (l) return n(function() {
                                        return Promise.resolve(a.add(e, o)).then(function() {
                                            return Promise.resolve(a.$("beforeLeave", e, c)).then(function() {
                                                return Promise.resolve(a.$("beforeEnter", e, c)).then(function() {
                                                    return Promise.resolve(Promise.all([a.leave(e, c), a.enter(e, c)])).then(function() {
                                                        return Promise.resolve(a.$("afterLeave", e, c)).then(function() {
                                                            return Promise.resolve(a.$("afterEnter", e, c)).then(function() {})
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    }, function() {
                                        throw new Error("Transition error [page][sync]")
                                    }); {
                                        function t(t) {
                                            return n(function() {
                                                var t = function() {
                                                    if (!1 !== i) return Promise.resolve(a.add(e, o)).then(function() {
                                                        return Promise.resolve(a.$("beforeEnter", e, c)).then(function() {
                                                            return Promise.resolve(a.enter(e, c, i)).then(function() {
                                                                return Promise.resolve(a.$("afterEnter", e, c)).then(function() {})
                                                            })
                                                        })
                                                    })
                                                }();
                                                if (t && t.then) return t.then(function() {})
                                            }, function() {
                                                throw new Error("Transition error [page][enter]")
                                            })
                                        }
                                        var i = !1,
                                            s = n(function() {
                                                return Promise.resolve(a.$("beforeLeave", e, c)).then(function() {
                                                    return Promise.resolve(Promise.all([a.leave(e, c), L(r, e)]).then(function(t) {
                                                        return t[0]
                                                    })).then(function(t) {
                                                        return i = t, Promise.resolve(a.$("afterLeave", e, c)).then(function() {})
                                                    })
                                                })
                                            }, function() {
                                                throw new Error("Transition error [page][leave]")
                                            });
                                        return s && s.then ? s.then(t) : t()
                                    }
                                }();
                                return i && i.then ? i.then(t) : t()
                            })
                        }
                        var i = function() {
                            if (l) return Promise.resolve(L(r, e)).then(function() {})
                        }();
                        return i && i.then ? i.then(t) : t()
                    }, function(t) {
                        throw a.S = !1, a.logger.error(t), new Error("Transition error")
                    });
                    return h && h.then ? h.then(s) : s()
                } catch (t) {
                    return Promise.reject(t)
                }
            }, $.prototype.appear = function(t, e) {
                try {
                    return Promise.resolve(h.do("appear", t, e)).then(function() {
                        return e.appear ? a(e.appear)(t) : Promise.resolve()
                    })
                } catch (t) {
                    return Promise.reject(t)
                }
            }, $.prototype.leave = function(t, e) {
                try {
                    return Promise.resolve(h.do("leave", t, e)).then(function() {
                        return e.leave ? a(e.leave)(t) : Promise.resolve()
                    })
                } catch (t) {
                    return Promise.reject(t)
                }
            }, $.prototype.enter = function(t, e, n) {
                try {
                    return Promise.resolve(h.do("enter", t, e)).then(function() {
                        return e.enter ? a(e.enter)(t, n) : Promise.resolve()
                    })
                } catch (t) {
                    return Promise.reject(t)
                }
            }, $.prototype.add = function(t, e) {
                try {
                    e.appendChild(t.next.container), h.do("nextAdded", t)
                } catch (t) {
                    return Promise.reject(t)
                }
            }, $.prototype.remove = function(t) {
                try {
                    var e = t.current.container;
                    document.body.contains(e) && (e.parentNode.removeChild(e), h.do("currentRemoved", t))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, $.prototype.$ = function(t, e, n) {
                try {
                    return Promise.resolve(h.do(t, e, n)).then(function() {
                        return n[t] ? a(n[t])(e) : Promise.resolve()
                    })
                } catch (t) {
                    return Promise.reject(t)
                }
            }, Object.defineProperties($.prototype, tt);
            var et = function(t) {
                var e = this;
                this.names = ["beforeAppear", "afterAppear", "beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = new Map, 0 !== t.length && (t.forEach(function(t) {
                    e.byNamespace.set(t.namespace, t)
                }), this.names.forEach(function(t) {
                    h[t](e.q(t), e)
                }))
            };
            et.prototype.q = function(t) {
                var e = this;
                return function(n) {
                    var i = t.match(/enter/i) ? n.next : n.current,
                        r = e.byNamespace.get(i.namespace);
                    r && r[t] && r[t](n)
                }
            }, Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function(t) {
                var e = this;
                do {
                    if (e.matches(t)) return e;
                    e = e.parentElement || e.parentNode
                } while (null !== e && 1 === e.nodeType);
                return null
            });
            var nt = {
                    container: void 0,
                    html: void 0,
                    namespace: void 0,
                    url: {
                        hash: void 0,
                        href: void 0,
                        path: void 0,
                        query: {}
                    }
                },
                it = function() {
                    this.version = "2.4.0", this.schemaPage = nt, this.Logger = c, this.logger = new c("@barba/core"), this.plugins = [], this.hooks = h, this.dom = E, this.helpers = C, this.history = P, this.request = U, this.url = H
                },
                rt = {
                    data: {
                        configurable: !0
                    },
                    wrapper: {
                        configurable: !0
                    }
                };
            return it.prototype.use = function(t, e) {
                var n = this.plugins;
                n.indexOf(t) > -1 ? this.logger.warn("Plugin [" + t.name + "] already installed.") : "function" == typeof t.install ? (t.install(this, e), n.push(t)) : this.logger.warn("Plugin [" + t.name + '] has no "install" method.')
            }, it.prototype.init = function(t) {
                void 0 === t && (t = {});
                var e = t.transitions;
                void 0 === e && (e = []);
                var n = t.views;
                void 0 === n && (n = []);
                var i = t.prevent;
                void 0 === i && (i = null);
                var r = t.timeout;
                void 0 === r && (r = 2e3);
                var o = t.requestError,
                    a = t.cacheIgnore;
                void 0 === a && (a = !1);
                var s = t.prefetchIgnore;
                void 0 === s && (s = !1);
                var l = t.schema;
                void 0 === l && (l = M);
                var h = t.debug;
                void 0 === h && (h = !1);
                var u = t.logLevel;
                if (void 0 === u && (u = "off"), c.setLevel(!0 === h ? "debug" : u), this.logger.info(this.version), Object.keys(l).forEach(function(t) {
                        M[t] && (M[t] = l[t])
                    }), this.C = o, this.timeout = r, this.cacheIgnore = a, this.prefetchIgnore = s, this.B = this.dom.getWrapper(), !this.B) throw new Error("[@barba/core] No Barba wrapper found");
                this.B.setAttribute("aria-live", "polite"), this.H();
                var p = this.data.current;
                if (!p.container) throw new Error("[@barba/core] No Barba container found");
                if (this.cache = new k(a), this.prevent = new K(s), this.transitions = new $(e), this.views = new et(n), null !== i) {
                    if ("function" != typeof i) throw new Error("[@barba/core] Prevent should be a function");
                    this.prevent.add("preventCustom", i)
                }
                this.history.add(p.url.href, p.namespace), this.I = this.I.bind(this), this.N = this.N.bind(this), this.U = this.U.bind(this), this.D(), this.plugins.forEach(function(t) {
                    return t.init()
                });
                var d = this.data;
                d.trigger = "barba", d.next = d.current, this.hooks.do("ready", d), this.appear(d), this.H()
            }, it.prototype.destroy = function() {
                this.H(), this.X(), this.hooks.clear(), this.plugins = []
            }, rt.data.get = function() {
                return this._
            }, rt.wrapper.get = function() {
                return this.B
            }, it.prototype.force = function(t) {
                window.location.assign(t)
            }, it.prototype.go = function(t, e, n) {
                var i;
                if (void 0 === e && (e = "barba"), !(i = "popstate" === e ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t) : this.prevent.run("sameUrl", null, null, t)) || this.transitions.hasSelf) return n && (n.stopPropagation(), n.preventDefault()), this.page(t, e, i)
            }, it.prototype.appear = function(t) {
                try {
                    var e = this;
                    return Promise.resolve(e.hooks.do("beforeEnter", t)).then(function() {
                        function i() {
                            return Promise.resolve(e.hooks.do("afterEnter", t)).then(function() {})
                        }
                        var r = function() {
                            if (e.transitions.hasAppear) {
                                var i = n(function() {
                                    var n = e.transitions.get(t, {
                                        appear: !0
                                    });
                                    return Promise.resolve(e.transitions.doAppear({
                                        transition: n,
                                        data: t
                                    })).then(function() {})
                                }, function(t) {
                                    e.logger.error(t)
                                });
                                if (i && i.then) return i.then(function() {})
                            }
                        }();
                        return r && r.then ? r.then(i) : i()
                    })
                } catch (t) {
                    return Promise.reject(t)
                }
            }, it.prototype.page = function(t, e, i) {
                try {
                    var r = this;

                    function o() {
                        var t = r.data;
                        return Promise.resolve(r.hooks.do("page", t)).then(function() {
                            var e = n(function() {
                                var e = r.transitions.get(t, {
                                    appear: !1,
                                    self: i
                                });
                                return Promise.resolve(r.transitions.doPage({
                                    data: t,
                                    page: a,
                                    transition: e,
                                    wrapper: r.B
                                })).then(function() {
                                    r.H()
                                })
                            }, function(t) {
                                r.logger.error(t)
                            });
                            if (e && e.then) return e.then(function() {})
                        })
                    }
                    if (r.transitions.isRunning) return void r.force(t);
                    r.data.next.url = Object.assign({}, {
                        href: t
                    }, r.url.parse(t)), r.data.trigger = e;
                    var a = r.cache.has(t) ? r.cache.update(t, {
                            action: "click"
                        }).request : r.cache.set(t, r.request(t, r.timeout, r.onRequestError.bind(r, e)), "click").request,
                        s = function() {
                            if (r.transitions.shouldWait) return Promise.resolve(L(a, r.data)).then(function() {})
                        }();
                    return s && s.then ? s.then(o) : o()
                } catch (t) {
                    return Promise.reject(t)
                }
            }, it.prototype.onRequestError = function(t) {
                for (var e = [], n = arguments.length - 1; n-- > 0;) e[n] = arguments[n + 1];
                this.transitions.isRunning = !1;
                var i = e[0],
                    r = e[1],
                    o = this.cache.getAction(i);
                return this.cache.delete(i), !(this.C && !1 === this.C(t, o, i, r) || ("click" === o && this.force(i), 1))
            }, it.prototype.prefetch = function(t) {
                var e = this;
                this.cache.has(t) || this.cache.set(t, this.request(t, this.timeout, this.onRequestError.bind(this, "barba")).catch(function(t) {
                    e.logger.error(t)
                }), "prefetch")
            }, it.prototype.D = function() {
                !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.I), document.addEventListener("touchstart", this.I)), document.addEventListener("click", this.N), window.addEventListener("popstate", this.U)
            }, it.prototype.X = function() {
                !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.I), document.removeEventListener("touchstart", this.I)), document.removeEventListener("click", this.N), window.removeEventListener("popstate", this.U)
            }, it.prototype.I = function(t) {
                var e = this,
                    n = this.F(t);
                if (n) {
                    var i = this.dom.getHref(n);
                    this.prevent.checkUrl(i) || this.cache.has(i) || this.cache.set(i, this.request(i, this.timeout, this.onRequestError.bind(this, n)).catch(function(t) {
                        e.logger.error(t)
                    }), "enter")
                }
            }, it.prototype.N = function(t) {
                var e = this.F(t);
                e && this.go(this.dom.getHref(e), e, t)
            }, it.prototype.U = function() {
                this.go(this.url.getHref(), "popstate")
            }, it.prototype.F = function(t) {
                for (var e = t.target; e && !this.dom.getHref(e);) e = e.parentNode;
                if (e && !this.prevent.checkLink(e, t, this.dom.getHref(e))) return e
            }, it.prototype.H = function() {
                var t = this.url.getHref(),
                    e = {
                        container: this.dom.getContainer(),
                        html: this.dom.getHtml(),
                        namespace: this.dom.getNamespace(),
                        url: Object.assign({}, {
                            href: t
                        }, this.url.parse(t))
                    };
                this._ = {
                    current: e,
                    next: Object.assign({}, this.schemaPage),
                    trigger: void 0
                }, this.hooks.do("reset", this.data)
            }, Object.defineProperties(it.prototype, rt), new it
        }()
    }, , , , , function(t, e, n) {
        ! function(t) {
            "use strict";

            function e(t, e, n) {
                return t + (e - t) * n
            }

            function n(t) {
                return t * Math.PI / 180
            }

            function i(t) {
                return 180 * t / Math.PI
            }

            function r(t, e, n) {
                return (n - t) / (e - t)
            }

            function o(t, e, n) {
                return n <= 0 ? t : n >= 1 ? e : t + n * (e - t)
            }

            function a(t, e) {
                var n = s(e - t, 360);
                return n > 180 && (n = Math.abs(n - 360)), n
            }

            function s(t, e) {
                return (t % e + e) % e
            }

            function c(t, n, i) {
                var r = a(t, n);
                return s(t + e(0, r, i), 360)
            }
            t.clamp = function(t, e, n) {
                return Math.min(e, Math.max(t, n))
            }, t.clamp01 = function(t) {
                return t < 0 ? 0 : t > 1 ? 1 : t
            }, t.step = function(t, e) {
                return e < t ? 0 : 1
            }, t.map = function(t, e, n, i, r) {
                return (t - e) / (n - e) * (r - i) + i
            }, t.diagonal = function(t, e) {
                return Math.sqrt(t * t + e * e)
            }, t.distance = function(t, e, n, i) {
                var r = t - n,
                    o = e - i;
                return Math.sqrt(r * r + o * o)
            }, t.smoothStep = function(t, e, n) {
                var i = Math.max(0, Math.min(1, (n - t) / (e - t)));
                return i * i * (3 - 2 * i)
            }, t.lerp = e, t.mix = e, t.normalize = function(t, e, n) {
                return (n - t) / (e - t)
            }, t.randomFloat = function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2;
                return parseFloat(Math.min(t + Math.random() * (e - t), e).toFixed(n))
            }, t.randomInt = function(t, e) {
                return Math.floor(Math.random() * (e - t + 1) + t)
            }, t.randomSign = function() {
                return Math.random() > .5 ? 1 : -1
            }, t.wrap = function(t, e, n) {
                var i = n - e;
                if (i <= 0) return 0;
                var r = (t - e) % i;
                return r < 0 && (r += i), r + e
            }, t.degToRad = n, t.toRadians = n, t.radToDeg = i, t.toDegrees = i, t.fuzzyFloor = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-4;
                return Math.floor(t + e)
            }, t.fuzzyCeil = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-4;
                return Math.ceil(t + e)
            }, t.fuzzyEqual = function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-4;
                return Math.abs(t - e) < n
            }, t.fuzzyGreaterThan = function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-4;
                return t > e - n
            }, t.fuzzyLessThan = function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-4;
                return t < e + n
            }, t.maxAdd = function(t, e, n) {
                return Math.min(t + e, n)
            }, t.minSub = function(t, e, n) {
                return Math.max(t - e, n)
            }, t.isOdd = function(t) {
                return !!(1 & t)
            }, t.isEven = function(t) {
                return !(1 & t)
            }, t.isPowerOfTwo = function(t) {
                return 0 !== t && 0 == (t & t - 1)
            }, t.closestPowerOfTwo = function(t) {
                return Math.pow(2, Math.round(Math.log(t) / Math.log(2)))
            }, t.nextPowerOfTwo = function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.log(2)))
            }, t.percent01 = function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return t > e || n > e ? 1 : t < n || n > t ? 0 : (t - n) / e
            }, t.average = function() {
                for (var t = 0, e = arguments.length, n = Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                var r = !0,
                    o = !1,
                    a = void 0;
                try {
                    for (var s, c = n[Symbol.iterator](); !(r = (s = c.next()).done); r = !0) {
                        var l = s.value;
                        t += +l
                    }
                } catch (t) {
                    o = !0, a = t
                } finally {
                    try {
                        !r && c.return && c.return()
                    } finally {
                        if (o) throw a
                    }
                }
                return t / n.length
            }, t.difference = function(t, e) {
                return Math.abs(t - e)
            }, t.within = function(t, e, n) {
                return Math.abs(t - e) <= n
            }, t.inverseLerp = r, t.inverseMix = r, t.lerpUnclamped = o, t.mixUnclamped = o, t.deltaAngleDeg = a, t.deltaAngle = a, t.deltaAngleRad = function(t, e) {
                return n(a(i(t), i(e)))
            }, t.fract = function(t) {
                return t - Math.floor(t)
            }, t.mod = s, t.lerpAngleDeg = c, t.lerpAngle = c, t.lerpAngleRad = function(t, e, r) {
                return n(c(i(t), i(e), r))
            }, t.gammaToLinearSpace = function(t) {
                return Math.pow(t, 2.2)
            }, t.linearToGammaSpace = function(t) {
                return Math.pow(t, 1 / 2.2)
            }, t.almostIdentity = function(t, e, n) {
                if (t > e) return t;
                var i = t / e;
                return ((2 * n - e) * i + (2 * e - 3 * n)) * i * i + n
            }, t.impulse = function(t, e) {
                var n = t * e;
                return n * Math.exp(1 - n)
            }, t.cubicPulse = function(t, e, n) {
                return (n = Math.abs(n - t)) > e ? 0 : 1 - (n /= e) * n * (3 - 2 * n)
            }, t.expStep = function(t, e, n) {
                return Math.exp(-e * Math.pow(t, n))
            }, t.parabola = function(t, e) {
                return Math.pow(4 * t * (1 - t), e)
            }, t.powerCurve = function(t, e, n) {
                return Math.pow(e + n, e + n) / (Math.pow(e, e) * Math.pow(n, n)) * Math.pow(t, e) * Math.pow(1 - t, n)
            }, t.smoothMin = function(t, e, n) {
                var i = Math.exp(-n * t) + Math.exp(-n * e);
                return -Math.log(i) / n
            }, t.smoothMax = function(t, e, n) {
                return Math.log(Math.exp(t) + Math.exp(e)) / n
            }, t.deltaTime = function(t) {
                return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now()) - t
            }, t.gcd = function t(e, n) {
                return 0 === n ? e : t(n, e % n)
            }, t.dotProduct = function(t, e, n, i, r, o, a, s) {
                return (n - t) * (a - r) + (i - e) * (s - o)
            }, Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }(e)
    }, , , function(t, e, n) {
        var i = n(43),
            r = "object" == typeof self && self && self.Object === Object && self,
            o = i || r || Function("return this")();
        t.exports = o
    }, , function(t, e, n) {
        var i = n(120),
            r = n(115);
        t.exports = function(t, e) {
            var n = r(t, e);
            return i(n) ? n : void 0
        }
    }, , , , function(t, e, n) {
        (function(n) {
            var i;
            /*!
             *  howler.js v2.1.2
             *  howlerjs.com
             *
             *  (c) 2013-2019, James Simpson of GoldFire Studios
             *  goldfirestudios.com
             *
             *  MIT License
             */
            /*!
             *  howler.js v2.1.2
             *  howlerjs.com
             *
             *  (c) 2013-2019, James Simpson of GoldFire Studios
             *  goldfirestudios.com
             *
             *  MIT License
             */
            ! function() {
                "use strict";
                var r = function() {
                    this.init()
                };
                r.prototype = {
                    init: function() {
                        var t = this || o;
                        return t._counter = 1e3, t._html5AudioPool = [], t.html5PoolSize = 10, t._codecs = {}, t._howls = [], t._muted = !1, t._volume = 1, t._canPlayEvent = "canplaythrough", t._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, t.masterGain = null, t.noAudio = !1, t.usingWebAudio = !0, t.autoSuspend = !0, t.ctx = null, t.autoUnlock = !0, t._setup(), t
                    },
                    volume: function(t) {
                        var e = this || o;
                        if (t = parseFloat(t), e.ctx || d(), void 0 !== t && t >= 0 && t <= 1) {
                            if (e._volume = t, e._muted) return e;
                            e.usingWebAudio && e.masterGain.gain.setValueAtTime(t, o.ctx.currentTime);
                            for (var n = 0; n < e._howls.length; n++)
                                if (!e._howls[n]._webAudio)
                                    for (var i = e._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
                                        var a = e._howls[n]._soundById(i[r]);
                                        a && a._node && (a._node.volume = a._volume * t)
                                    }
                            return e
                        }
                        return e._volume
                    },
                    mute: function(t) {
                        var e = this || o;
                        e.ctx || d(), e._muted = t, e.usingWebAudio && e.masterGain.gain.setValueAtTime(t ? 0 : e._volume, o.ctx.currentTime);
                        for (var n = 0; n < e._howls.length; n++)
                            if (!e._howls[n]._webAudio)
                                for (var i = e._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
                                    var a = e._howls[n]._soundById(i[r]);
                                    a && a._node && (a._node.muted = !!t || a._muted)
                                }
                        return e
                    },
                    unload: function() {
                        for (var t = this || o, e = t._howls.length - 1; e >= 0; e--) t._howls[e].unload();
                        return t.usingWebAudio && t.ctx && void 0 !== t.ctx.close && (t.ctx.close(), t.ctx = null, d()), t
                    },
                    codecs: function(t) {
                        return (this || o)._codecs[t.replace(/^x-/, "")]
                    },
                    _setup: function() {
                        var t = this || o;
                        if (t.state = t.ctx && t.ctx.state || "suspended", t._autoSuspend(), !t.usingWebAudio)
                            if ("undefined" != typeof Audio) try {
                                void 0 === (new Audio).oncanplaythrough && (t._canPlayEvent = "canplay")
                            } catch (e) {
                                t.noAudio = !0
                            } else t.noAudio = !0;
                        try {
                            (new Audio).muted && (t.noAudio = !0)
                        } catch (t) {}
                        return t.noAudio || t._setupCodecs(), t
                    },
                    _setupCodecs: function() {
                        var t = this || o,
                            e = null;
                        try {
                            e = "undefined" != typeof Audio ? new Audio : null
                        } catch (e) {
                            return t
                        }
                        if (!e || "function" != typeof e.canPlayType) return t;
                        var n = e.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                            i = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g),
                            r = i && parseInt(i[0].split("/")[1], 10) < 33;
                        return t._codecs = {
                            mp3: !(r || !n && !e.canPlayType("audio/mp3;").replace(/^no$/, "")),
                            mpeg: !!n,
                            opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                            ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            wav: !!e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
                            aac: !!e.canPlayType("audio/aac;").replace(/^no$/, ""),
                            caf: !!e.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                            m4a: !!(e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            mp4: !!(e.canPlayType("audio/x-mp4;") || e.canPlayType("audio/mp4;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            weba: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                            webm: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                            dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                            flac: !!(e.canPlayType("audio/x-flac;") || e.canPlayType("audio/flac;")).replace(/^no$/, "")
                        }, t
                    },
                    _unlockAudio: function() {
                        var t = this || o;
                        if (!t._audioUnlocked && t.ctx) {
                            t._audioUnlocked = !1, t.autoUnlock = !1, t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0, t.unload()), t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050);
                            var e = function(n) {
                                for (var i = 0; i < t.html5PoolSize; i++) try {
                                    var r = new Audio;
                                    r._unlocked = !0, t._releaseHtml5Audio(r)
                                } catch (n) {
                                    t.noAudio = !0
                                }
                                for (i = 0; i < t._howls.length; i++)
                                    if (!t._howls[i]._webAudio)
                                        for (var o = t._howls[i]._getSoundIds(), a = 0; a < o.length; a++) {
                                            var s = t._howls[i]._soundById(o[a]);
                                            s && s._node && !s._node._unlocked && (s._node._unlocked = !0, s._node.load())
                                        }
                                t._autoResume();
                                var c = t.ctx.createBufferSource();
                                c.buffer = t._scratchBuffer, c.connect(t.ctx.destination), void 0 === c.start ? c.noteOn(0) : c.start(0), "function" == typeof t.ctx.resume && t.ctx.resume(), c.onended = function() {
                                    c.disconnect(0), t._audioUnlocked = !0, document.removeEventListener("touchstart", e, !0), document.removeEventListener("touchend", e, !0), document.removeEventListener("click", e, !0);
                                    for (var n = 0; n < t._howls.length; n++) t._howls[n]._emit("unlock")
                                }
                            };
                            return document.addEventListener("touchstart", e, !0), document.addEventListener("touchend", e, !0), document.addEventListener("click", e, !0), t
                        }
                    },
                    _obtainHtml5Audio: function() {
                        var t = this || o;
                        if (t._html5AudioPool.length) return t._html5AudioPool.pop();
                        var e = (new Audio).play();
                        return e && "undefined" != typeof Promise && (e instanceof Promise || "function" == typeof e.then) && e.catch(function() {
                            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                        }), new Audio
                    },
                    _releaseHtml5Audio: function(t) {
                        var e = this || o;
                        return t._unlocked && e._html5AudioPool.push(t), e
                    },
                    _autoSuspend: function() {
                        var t = this;
                        if (t.autoSuspend && t.ctx && void 0 !== t.ctx.suspend && o.usingWebAudio) {
                            for (var e = 0; e < t._howls.length; e++)
                                if (t._howls[e]._webAudio)
                                    for (var n = 0; n < t._howls[e]._sounds.length; n++)
                                        if (!t._howls[e]._sounds[n]._paused) return t;
                            return t._suspendTimer && clearTimeout(t._suspendTimer), t._suspendTimer = setTimeout(function() {
                                t.autoSuspend && (t._suspendTimer = null, t.state = "suspending", t.ctx.suspend().then(function() {
                                    t.state = "suspended", t._resumeAfterSuspend && (delete t._resumeAfterSuspend, t._autoResume())
                                }))
                            }, 3e4), t
                        }
                    },
                    _autoResume: function() {
                        var t = this;
                        if (t.ctx && void 0 !== t.ctx.resume && o.usingWebAudio) return "running" === t.state && t._suspendTimer ? (clearTimeout(t._suspendTimer), t._suspendTimer = null) : "suspended" === t.state ? (t.ctx.resume().then(function() {
                            t.state = "running";
                            for (var e = 0; e < t._howls.length; e++) t._howls[e]._emit("resume")
                        }), t._suspendTimer && (clearTimeout(t._suspendTimer), t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0), t
                    }
                };
                var o = new r,
                    a = function(t) {
                        t.src && 0 !== t.src.length ? this.init(t) : console.error("An array of source files must be passed with any new Howl.")
                    };
                a.prototype = {
                    init: function(t) {
                        var e = this;
                        return o.ctx || d(), e._autoplay = t.autoplay || !1, e._format = "string" != typeof t.format ? t.format : [t.format], e._html5 = t.html5 || !1, e._muted = t.mute || !1, e._loop = t.loop || !1, e._pool = t.pool || 5, e._preload = "boolean" != typeof t.preload || t.preload, e._rate = t.rate || 1, e._sprite = t.sprite || {}, e._src = "string" != typeof t.src ? t.src : [t.src], e._volume = void 0 !== t.volume ? t.volume : 1, e._xhrWithCredentials = t.xhrWithCredentials || !1, e._duration = 0, e._state = "unloaded", e._sounds = [], e._endTimers = {}, e._queue = [], e._playLock = !1, e._onend = t.onend ? [{
                            fn: t.onend
                        }] : [], e._onfade = t.onfade ? [{
                            fn: t.onfade
                        }] : [], e._onload = t.onload ? [{
                            fn: t.onload
                        }] : [], e._onloaderror = t.onloaderror ? [{
                            fn: t.onloaderror
                        }] : [], e._onplayerror = t.onplayerror ? [{
                            fn: t.onplayerror
                        }] : [], e._onpause = t.onpause ? [{
                            fn: t.onpause
                        }] : [], e._onplay = t.onplay ? [{
                            fn: t.onplay
                        }] : [], e._onstop = t.onstop ? [{
                            fn: t.onstop
                        }] : [], e._onmute = t.onmute ? [{
                            fn: t.onmute
                        }] : [], e._onvolume = t.onvolume ? [{
                            fn: t.onvolume
                        }] : [], e._onrate = t.onrate ? [{
                            fn: t.onrate
                        }] : [], e._onseek = t.onseek ? [{
                            fn: t.onseek
                        }] : [], e._onunlock = t.onunlock ? [{
                            fn: t.onunlock
                        }] : [], e._onresume = [], e._webAudio = o.usingWebAudio && !e._html5, void 0 !== o.ctx && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(e), e._autoplay && e._queue.push({
                            event: "play",
                            action: function() {
                                e.play()
                            }
                        }), e._preload && e.load(), e
                    },
                    load: function() {
                        var t = null;
                        if (o.noAudio) this._emit("loaderror", null, "No audio support.");
                        else {
                            "string" == typeof this._src && (this._src = [this._src]);
                            for (var e = 0; e < this._src.length; e++) {
                                var n, i;
                                if (this._format && this._format[e]) n = this._format[e];
                                else {
                                    if ("string" != typeof(i = this._src[e])) {
                                        this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                        continue
                                    }(n = /^data:audio\/([^;,]+);/i.exec(i)) || (n = /\.([^.]+)$/.exec(i.split("?", 1)[0])), n && (n = n[1].toLowerCase())
                                }
                                if (n || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n && o.codecs(n)) {
                                    t = this._src[e];
                                    break
                                }
                            }
                            if (t) return this._src = t, this._state = "loading", "https:" === window.location.protocol && "http:" === t.slice(0, 5) && (this._html5 = !0, this._webAudio = !1), new s(this), this._webAudio && l(this), this;
                            this._emit("loaderror", null, "No codec support for selected audio sources.")
                        }
                    },
                    play: function(t, e) {
                        var n = this,
                            i = null;
                        if ("number" == typeof t) i = t, t = null;
                        else {
                            if ("string" == typeof t && "loaded" === n._state && !n._sprite[t]) return null;
                            if (void 0 === t && (t = "__default", !n._playLock)) {
                                for (var r = 0, a = 0; a < n._sounds.length; a++) n._sounds[a]._paused && !n._sounds[a]._ended && (r++, i = n._sounds[a]._id);
                                1 === r ? t = null : i = null
                            }
                        }
                        var s = i ? n._soundById(i) : n._inactiveSound();
                        if (!s) return null;
                        if (i && !t && (t = s._sprite || "__default"), "loaded" !== n._state) {
                            s._sprite = t, s._ended = !1;
                            var c = s._id;
                            return n._queue.push({
                                event: "play",
                                action: function() {
                                    n.play(c)
                                }
                            }), c
                        }
                        if (i && !s._paused) return e || n._loadQueue("play"), s._id;
                        n._webAudio && o._autoResume();
                        var l = Math.max(0, s._seek > 0 ? s._seek : n._sprite[t][0] / 1e3),
                            h = Math.max(0, (n._sprite[t][0] + n._sprite[t][1]) / 1e3 - l),
                            u = 1e3 * h / Math.abs(s._rate),
                            p = n._sprite[t][0] / 1e3,
                            d = (n._sprite[t][0] + n._sprite[t][1]) / 1e3,
                            f = !(!s._loop && !n._sprite[t][2]);
                        s._sprite = t, s._ended = !1;
                        var m = function() {
                            s._paused = !1, s._seek = l, s._start = p, s._stop = d, s._loop = f
                        };
                        if (!(l >= d)) {
                            var v = s._node;
                            if (n._webAudio) {
                                var g = function() {
                                    n._playLock = !1, m(), n._refreshBuffer(s);
                                    var t = s._muted || n._muted ? 0 : s._volume;
                                    v.gain.setValueAtTime(t, o.ctx.currentTime), s._playStart = o.ctx.currentTime, void 0 === v.bufferSource.start ? s._loop ? v.bufferSource.noteGrainOn(0, l, 86400) : v.bufferSource.noteGrainOn(0, l, h) : s._loop ? v.bufferSource.start(0, l, 86400) : v.bufferSource.start(0, l, h), u !== 1 / 0 && (n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), u)), e || setTimeout(function() {
                                        n._emit("play", s._id), n._loadQueue()
                                    }, 0)
                                };
                                "running" === o.state ? g() : (n._playLock = !0, n.once("resume", g), n._clearTimer(s._id))
                            } else {
                                var y = function() {
                                    v.currentTime = l, v.muted = s._muted || n._muted || o._muted || v.muted, v.volume = s._volume * o.volume(), v.playbackRate = s._rate;
                                    try {
                                        var i = v.play();
                                        if (i && "undefined" != typeof Promise && (i instanceof Promise || "function" == typeof i.then) ? (n._playLock = !0, m(), i.then(function() {
                                                n._playLock = !1, v._unlocked = !0, e || (n._emit("play", s._id), n._loadQueue())
                                            }).catch(function() {
                                                n._playLock = !1, n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), s._ended = !0, s._paused = !0
                                            })) : e || (n._playLock = !1, m(), n._emit("play", s._id), n._loadQueue()), v.playbackRate = s._rate, v.paused) return void n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                        "__default" !== t || s._loop ? n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), u) : (n._endTimers[s._id] = function() {
                                            n._ended(s), v.removeEventListener("ended", n._endTimers[s._id], !1)
                                        }, v.addEventListener("ended", n._endTimers[s._id], !1))
                                    } catch (t) {
                                        n._emit("playerror", s._id, t)
                                    }
                                };
                                "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === v.src && (v.src = n._src, v.load());
                                var _ = window && window.ejecta || !v.readyState && o._navigator.isCocoonJS;
                                if (v.readyState >= 3 || _) y();
                                else {
                                    n._playLock = !0;
                                    var x = function() {
                                        y(), v.removeEventListener(o._canPlayEvent, x, !1)
                                    };
                                    v.addEventListener(o._canPlayEvent, x, !1), n._clearTimer(s._id)
                                }
                            }
                            return s._id
                        }
                        n._ended(s)
                    },
                    pause: function(t) {
                        var e = this;
                        if ("loaded" !== e._state || e._playLock) return e._queue.push({
                            event: "pause",
                            action: function() {
                                e.pause(t)
                            }
                        }), e;
                        for (var n = e._getSoundIds(t), i = 0; i < n.length; i++) {
                            e._clearTimer(n[i]);
                            var r = e._soundById(n[i]);
                            if (r && !r._paused && (r._seek = e.seek(n[i]), r._rateSeek = 0, r._paused = !0, e._stopFade(n[i]), r._node))
                                if (e._webAudio) {
                                    if (!r._node.bufferSource) continue;
                                    void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), e._cleanBuffer(r._node)
                                } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
                            arguments[1] || e._emit("pause", r ? r._id : null)
                        }
                        return e
                    },
                    stop: function(t, e) {
                        var n = this;
                        if ("loaded" !== n._state || n._playLock) return n._queue.push({
                            event: "stop",
                            action: function() {
                                n.stop(t)
                            }
                        }), n;
                        for (var i = n._getSoundIds(t), r = 0; r < i.length; r++) {
                            n._clearTimer(i[r]);
                            var o = n._soundById(i[r]);
                            o && (o._seek = o._start || 0, o._rateSeek = 0, o._paused = !0, o._ended = !0, n._stopFade(i[r]), o._node && (n._webAudio ? o._node.bufferSource && (void 0 === o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0), n._cleanBuffer(o._node)) : isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0, o._node.pause(), o._node.duration === 1 / 0 && n._clearSound(o._node))), e || n._emit("stop", o._id))
                        }
                        return n
                    },
                    mute: function(t, e) {
                        var n = this;
                        if ("loaded" !== n._state || n._playLock) return n._queue.push({
                            event: "mute",
                            action: function() {
                                n.mute(t, e)
                            }
                        }), n;
                        if (void 0 === e) {
                            if ("boolean" != typeof t) return n._muted;
                            n._muted = t
                        }
                        for (var i = n._getSoundIds(e), r = 0; r < i.length; r++) {
                            var a = n._soundById(i[r]);
                            a && (a._muted = t, a._interval && n._stopFade(a._id), n._webAudio && a._node ? a._node.gain.setValueAtTime(t ? 0 : a._volume, o.ctx.currentTime) : a._node && (a._node.muted = !!o._muted || t), n._emit("mute", a._id))
                        }
                        return n
                    },
                    volume: function() {
                        var t, e, n, i = this,
                            r = arguments;
                        if (0 === r.length) return i._volume;
                        if (1 === r.length || 2 === r.length && void 0 === r[1] ? i._getSoundIds().indexOf(r[0]) >= 0 ? e = parseInt(r[0], 10) : t = parseFloat(r[0]) : r.length >= 2 && (t = parseFloat(r[0]), e = parseInt(r[1], 10)), !(void 0 !== t && t >= 0 && t <= 1)) return (n = e ? i._soundById(e) : i._sounds[0]) ? n._volume : 0;
                        if ("loaded" !== i._state || i._playLock) return i._queue.push({
                            event: "volume",
                            action: function() {
                                i.volume.apply(i, r)
                            }
                        }), i;
                        void 0 === e && (i._volume = t), e = i._getSoundIds(e);
                        for (var a = 0; a < e.length; a++)(n = i._soundById(e[a])) && (n._volume = t, r[2] || i._stopFade(e[a]), i._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(t, o.ctx.currentTime) : n._node && !n._muted && (n._node.volume = t * o.volume()), i._emit("volume", n._id));
                        return i
                    },
                    fade: function(t, e, n, i) {
                        var r = this;
                        if ("loaded" !== r._state || r._playLock) return r._queue.push({
                            event: "fade",
                            action: function() {
                                r.fade(t, e, n, i)
                            }
                        }), r;
                        t = parseFloat(t), e = parseFloat(e), n = parseFloat(n), r.volume(t, i);
                        for (var a = r._getSoundIds(i), s = 0; s < a.length; s++) {
                            var c = r._soundById(a[s]);
                            if (c) {
                                if (i || r._stopFade(a[s]), r._webAudio && !c._muted) {
                                    var l = o.ctx.currentTime,
                                        h = l + n / 1e3;
                                    c._volume = t, c._node.gain.setValueAtTime(t, l), c._node.gain.linearRampToValueAtTime(e, h)
                                }
                                r._startFadeInterval(c, t, e, n, a[s], void 0 === i)
                            }
                        }
                        return r
                    },
                    _startFadeInterval: function(t, e, n, i, r, o) {
                        var a = this,
                            s = e,
                            c = n - e,
                            l = Math.abs(c / .01),
                            h = Math.max(4, l > 0 ? i / l : i),
                            u = Date.now();
                        t._fadeTo = n, t._interval = setInterval(function() {
                            var r = (Date.now() - u) / i;
                            u = Date.now(), s += c * r, s = Math.max(0, s), s = Math.min(1, s), s = Math.round(100 * s) / 100, a._webAudio ? t._volume = s : a.volume(s, t._id, !0), o && (a._volume = s), (n < e && s <= n || n > e && s >= n) && (clearInterval(t._interval), t._interval = null, t._fadeTo = null, a.volume(n, t._id), a._emit("fade", t._id))
                        }, h)
                    },
                    _stopFade: function(t) {
                        var e = this._soundById(t);
                        return e && e._interval && (this._webAudio && e._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(e._interval), e._interval = null, this.volume(e._fadeTo, t), e._fadeTo = null, this._emit("fade", t)), this
                    },
                    loop: function() {
                        var t, e, n, i = arguments;
                        if (0 === i.length) return this._loop;
                        if (1 === i.length) {
                            if ("boolean" != typeof i[0]) return !!(n = this._soundById(parseInt(i[0], 10))) && n._loop;
                            t = i[0], this._loop = t
                        } else 2 === i.length && (t = i[0], e = parseInt(i[1], 10));
                        for (var r = this._getSoundIds(e), o = 0; o < r.length; o++)(n = this._soundById(r[o])) && (n._loop = t, this._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = t, t && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop)));
                        return this
                    },
                    rate: function() {
                        var t, e, n, i = this,
                            r = arguments;
                        if (0 === r.length) e = i._sounds[0]._id;
                        else if (1 === r.length) {
                            i._getSoundIds().indexOf(r[0]) >= 0 ? e = parseInt(r[0], 10) : t = parseFloat(r[0])
                        } else 2 === r.length && (t = parseFloat(r[0]), e = parseInt(r[1], 10));
                        if ("number" != typeof t) return (n = i._soundById(e)) ? n._rate : i._rate;
                        if ("loaded" !== i._state || i._playLock) return i._queue.push({
                            event: "rate",
                            action: function() {
                                i.rate.apply(i, r)
                            }
                        }), i;
                        void 0 === e && (i._rate = t), e = i._getSoundIds(e);
                        for (var a = 0; a < e.length; a++)
                            if (n = i._soundById(e[a])) {
                                i.playing(e[a]) && (n._rateSeek = i.seek(e[a]), n._playStart = i._webAudio ? o.ctx.currentTime : n._playStart), n._rate = t, i._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(t, o.ctx.currentTime) : n._node && (n._node.playbackRate = t);
                                var s = i.seek(e[a]),
                                    c = 1e3 * ((i._sprite[n._sprite][0] + i._sprite[n._sprite][1]) / 1e3 - s) / Math.abs(n._rate);
                                !i._endTimers[e[a]] && n._paused || (i._clearTimer(e[a]), i._endTimers[e[a]] = setTimeout(i._ended.bind(i, n), c)), i._emit("rate", n._id)
                            }
                        return i
                    },
                    seek: function() {
                        var t, e, n = this,
                            i = arguments;
                        if (0 === i.length) e = n._sounds[0]._id;
                        else if (1 === i.length) {
                            n._getSoundIds().indexOf(i[0]) >= 0 ? e = parseInt(i[0], 10) : n._sounds.length && (e = n._sounds[0]._id, t = parseFloat(i[0]))
                        } else 2 === i.length && (t = parseFloat(i[0]), e = parseInt(i[1], 10));
                        if (void 0 === e) return n;
                        if ("loaded" !== n._state || n._playLock) return n._queue.push({
                            event: "seek",
                            action: function() {
                                n.seek.apply(n, i)
                            }
                        }), n;
                        var r = n._soundById(e);
                        if (r) {
                            if (!("number" == typeof t && t >= 0)) {
                                if (n._webAudio) {
                                    var a = n.playing(e) ? o.ctx.currentTime - r._playStart : 0,
                                        s = r._rateSeek ? r._rateSeek - r._seek : 0;
                                    return r._seek + (s + a * Math.abs(r._rate))
                                }
                                return r._node.currentTime
                            }
                            var c = n.playing(e);
                            c && n.pause(e, !0), r._seek = t, r._ended = !1, n._clearTimer(e), n._webAudio || !r._node || isNaN(r._node.duration) || (r._node.currentTime = t);
                            var l = function() {
                                n._emit("seek", e), c && n.play(e, !0)
                            };
                            if (c && !n._webAudio) {
                                var h = function() {
                                    n._playLock ? setTimeout(h, 0) : l()
                                };
                                setTimeout(h, 0)
                            } else l()
                        }
                        return n
                    },
                    playing: function(t) {
                        if ("number" == typeof t) {
                            var e = this._soundById(t);
                            return !!e && !e._paused
                        }
                        for (var n = 0; n < this._sounds.length; n++)
                            if (!this._sounds[n]._paused) return !0;
                        return !1
                    },
                    duration: function(t) {
                        var e = this._duration,
                            n = this._soundById(t);
                        return n && (e = this._sprite[n._sprite][1] / 1e3), e
                    },
                    state: function() {
                        return this._state
                    },
                    unload: function() {
                        for (var t = this, e = t._sounds, n = 0; n < e.length; n++) e[n]._paused || t.stop(e[n]._id), t._webAudio || (t._clearSound(e[n]._node), e[n]._node.removeEventListener("error", e[n]._errorFn, !1), e[n]._node.removeEventListener(o._canPlayEvent, e[n]._loadFn, !1), o._releaseHtml5Audio(e[n]._node)), delete e[n]._node, t._clearTimer(e[n]._id);
                        var i = o._howls.indexOf(t);
                        i >= 0 && o._howls.splice(i, 1);
                        var r = !0;
                        for (n = 0; n < o._howls.length; n++)
                            if (o._howls[n]._src === t._src || t._src.indexOf(o._howls[n]._src) >= 0) {
                                r = !1;
                                break
                            }
                        return c && r && delete c[t._src], o.noAudio = !1, t._state = "unloaded", t._sounds = [], t = null, null
                    },
                    on: function(t, e, n, i) {
                        var r = this["_on" + t];
                        return "function" == typeof e && r.push(i ? {
                            id: n,
                            fn: e,
                            once: i
                        } : {
                            id: n,
                            fn: e
                        }), this
                    },
                    off: function(t, e, n) {
                        var i = this["_on" + t],
                            r = 0;
                        if ("number" == typeof e && (n = e, e = null), e || n)
                            for (r = 0; r < i.length; r++) {
                                var o = n === i[r].id;
                                if (e === i[r].fn && o || !e && o) {
                                    i.splice(r, 1);
                                    break
                                }
                            } else if (t) this["_on" + t] = [];
                            else {
                                var a = Object.keys(this);
                                for (r = 0; r < a.length; r++) 0 === a[r].indexOf("_on") && Array.isArray(this[a[r]]) && (this[a[r]] = [])
                            }
                        return this
                    },
                    once: function(t, e, n) {
                        return this.on(t, e, n, 1), this
                    },
                    _emit: function(t, e, n) {
                        for (var i = this["_on" + t], r = i.length - 1; r >= 0; r--) i[r].id && i[r].id !== e && "load" !== t || (setTimeout(function(t) {
                            t.call(this, e, n)
                        }.bind(this, i[r].fn), 0), i[r].once && this.off(t, i[r].fn, i[r].id));
                        return this._loadQueue(t), this
                    },
                    _loadQueue: function(t) {
                        if (this._queue.length > 0) {
                            var e = this._queue[0];
                            e.event === t && (this._queue.shift(), this._loadQueue()), t || e.action()
                        }
                        return this
                    },
                    _ended: function(t) {
                        var e = t._sprite;
                        if (!this._webAudio && t._node && !t._node.paused && !t._node.ended && t._node.currentTime < t._stop) return setTimeout(this._ended.bind(this, t), 100), this;
                        var n = !(!t._loop && !this._sprite[e][2]);
                        if (this._emit("end", t._id), !this._webAudio && n && this.stop(t._id, !0).play(t._id), this._webAudio && n) {
                            this._emit("play", t._id), t._seek = t._start || 0, t._rateSeek = 0, t._playStart = o.ctx.currentTime;
                            var i = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
                            this._endTimers[t._id] = setTimeout(this._ended.bind(this, t), i)
                        }
                        return this._webAudio && !n && (t._paused = !0, t._ended = !0, t._seek = t._start || 0, t._rateSeek = 0, this._clearTimer(t._id), this._cleanBuffer(t._node), o._autoSuspend()), this._webAudio || n || this.stop(t._id, !0), this
                    },
                    _clearTimer: function(t) {
                        if (this._endTimers[t]) {
                            if ("function" != typeof this._endTimers[t]) clearTimeout(this._endTimers[t]);
                            else {
                                var e = this._soundById(t);
                                e && e._node && e._node.removeEventListener("ended", this._endTimers[t], !1)
                            }
                            delete this._endTimers[t]
                        }
                        return this
                    },
                    _soundById: function(t) {
                        for (var e = 0; e < this._sounds.length; e++)
                            if (t === this._sounds[e]._id) return this._sounds[e];
                        return null
                    },
                    _inactiveSound: function() {
                        this._drain();
                        for (var t = 0; t < this._sounds.length; t++)
                            if (this._sounds[t]._ended) return this._sounds[t].reset();
                        return new s(this)
                    },
                    _drain: function() {
                        var t = this._pool,
                            e = 0,
                            n = 0;
                        if (!(this._sounds.length < t)) {
                            for (n = 0; n < this._sounds.length; n++) this._sounds[n]._ended && e++;
                            for (n = this._sounds.length - 1; n >= 0; n--) {
                                if (e <= t) return;
                                this._sounds[n]._ended && (this._webAudio && this._sounds[n]._node && this._sounds[n]._node.disconnect(0), this._sounds.splice(n, 1), e--)
                            }
                        }
                    },
                    _getSoundIds: function(t) {
                        if (void 0 === t) {
                            for (var e = [], n = 0; n < this._sounds.length; n++) e.push(this._sounds[n]._id);
                            return e
                        }
                        return [t]
                    },
                    _refreshBuffer: function(t) {
                        return t._node.bufferSource = o.ctx.createBufferSource(), t._node.bufferSource.buffer = c[this._src], t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node), t._node.bufferSource.loop = t._loop, t._loop && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop || 0), t._node.bufferSource.playbackRate.setValueAtTime(t._rate, o.ctx.currentTime), this
                    },
                    _cleanBuffer: function(t) {
                        var e = o._navigator && o._navigator.vendor.indexOf("Apple") >= 0;
                        if (o._scratchBuffer && t.bufferSource && (t.bufferSource.onended = null, t.bufferSource.disconnect(0), e)) try {
                            t.bufferSource.buffer = o._scratchBuffer
                        } catch (t) {}
                        return t.bufferSource = null, this
                    },
                    _clearSound: function(t) {
                        /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (t.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                    }
                };
                var s = function(t) {
                    this._parent = t, this.init()
                };
                s.prototype = {
                    init: function() {
                        var t = this._parent;
                        return this._muted = t._muted, this._loop = t._loop, this._volume = t._volume, this._rate = t._rate, this._seek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++o._counter, t._sounds.push(this), this.create(), this
                    },
                    create: function() {
                        var t = this._parent,
                            e = o._muted || this._muted || this._parent._muted ? 0 : this._volume;
                        return t._webAudio ? (this._node = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), this._node.gain.setValueAtTime(e, o.ctx.currentTime), this._node.paused = !0, this._node.connect(o.masterGain)) : (this._node = o._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(o._canPlayEvent, this._loadFn, !1), this._node.src = t._src, this._node.preload = "auto", this._node.volume = e * o.volume(), this._node.load()), this
                    },
                    reset: function() {
                        var t = this._parent;
                        return this._muted = t._muted, this._loop = t._loop, this._volume = t._volume, this._rate = t._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++o._counter, this
                    },
                    _errorListener: function() {
                        this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, !1)
                    },
                    _loadListener: function() {
                        var t = this._parent;
                        t._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(t._sprite).length && (t._sprite = {
                            __default: [0, 1e3 * t._duration]
                        }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue()), this._node.removeEventListener(o._canPlayEvent, this._loadFn, !1)
                    }
                };
                var c = {},
                    l = function(t) {
                        var e = t._src;
                        if (c[e]) return t._duration = c[e].duration, void p(t);
                        if (/^data:[^;]+;base64,/.test(e)) {
                            for (var n = atob(e.split(",")[1]), i = new Uint8Array(n.length), r = 0; r < n.length; ++r) i[r] = n.charCodeAt(r);
                            u(i.buffer, t)
                        } else {
                            var o = new XMLHttpRequest;
                            o.open("GET", e, !0), o.withCredentials = t._xhrWithCredentials, o.responseType = "arraybuffer", o.onload = function() {
                                var e = (o.status + "")[0];
                                "0" === e || "2" === e || "3" === e ? u(o.response, t) : t._emit("loaderror", null, "Failed loading audio file with status: " + o.status + ".")
                            }, o.onerror = function() {
                                t._webAudio && (t._html5 = !0, t._webAudio = !1, t._sounds = [], delete c[e], t.load())
                            }, h(o)
                        }
                    },
                    h = function(t) {
                        try {
                            t.send()
                        } catch (e) {
                            t.onerror()
                        }
                    },
                    u = function(t, e) {
                        var n = function() {
                                e._emit("loaderror", null, "Decoding audio data failed.")
                            },
                            i = function(t) {
                                t && e._sounds.length > 0 ? (c[e._src] = t, p(e, t)) : n()
                            };
                        "undefined" != typeof Promise && 1 === o.ctx.decodeAudioData.length ? o.ctx.decodeAudioData(t).then(i).catch(n) : o.ctx.decodeAudioData(t, i, n)
                    },
                    p = function(t, e) {
                        e && !t._duration && (t._duration = e.duration), 0 === Object.keys(t._sprite).length && (t._sprite = {
                            __default: [0, 1e3 * t._duration]
                        }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue())
                    },
                    d = function() {
                        if (o.usingWebAudio) {
                            try {
                                "undefined" != typeof AudioContext ? o.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? o.ctx = new webkitAudioContext : o.usingWebAudio = !1
                            } catch (t) {
                                o.usingWebAudio = !1
                            }
                            o.ctx || (o.usingWebAudio = !1);
                            var t = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform),
                                e = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                                n = e ? parseInt(e[1], 10) : null;
                            if (t && n && n < 9) {
                                var i = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
                                (o._navigator && o._navigator.standalone && !i || o._navigator && !o._navigator.standalone && !i) && (o.usingWebAudio = !1)
                            }
                            o.usingWebAudio && (o.masterGain = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : 1, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup()
                        }
                    };
                void 0 === (i = function() {
                    return {
                        Howler: o,
                        Howl: a
                    }
                }.apply(e, [])) || (t.exports = i), e.Howler = o, e.Howl = a, "undefined" != typeof window ? (window.HowlerGlobal = r, window.Howler = o, window.Howl = a, window.Sound = s) : void 0 !== n && (n.HowlerGlobal = r, n.Howler = o, n.Howl = a, n.Sound = s)
            }(),
            /*!
             *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
             *  
             *  howler.js v2.1.2
             *  howlerjs.com
             *
             *  (c) 2013-2019, James Simpson of GoldFire Studios
             *  goldfirestudios.com
             *
             *  MIT License
             */
            function() {
                "use strict";
                HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(t) {
                    if (!this.ctx || !this.ctx.listener) return this;
                    for (var e = this._howls.length - 1; e >= 0; e--) this._howls[e].stereo(t);
                    return this
                }, HowlerGlobal.prototype.pos = function(t, e, n) {
                    return this.ctx && this.ctx.listener ? (e = "number" != typeof e ? this._pos[1] : e, n = "number" != typeof n ? this._pos[2] : n, "number" != typeof t ? this._pos : (this._pos = [t, e, n], void 0 !== this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, .1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, .1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, .1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this
                }, HowlerGlobal.prototype.orientation = function(t, e, n, i, r, o) {
                    if (!this.ctx || !this.ctx.listener) return this;
                    var a = this._orientation;
                    return e = "number" != typeof e ? a[1] : e, n = "number" != typeof n ? a[2] : n, i = "number" != typeof i ? a[3] : i, r = "number" != typeof r ? a[4] : r, o = "number" != typeof o ? a[5] : o, "number" != typeof t ? a : (this._orientation = [t, e, n, i, r, o], void 0 !== this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), this.ctx.listener.upX.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.upY.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.upZ.setTargetAtTime(n, Howler.ctx.currentTime, .1)) : this.ctx.listener.setOrientation(t, e, n, i, r, o), this)
                }, Howl.prototype.init = function(t) {
                    return function(e) {
                        return this._orientation = e.orientation || [1, 0, 0], this._stereo = e.stereo || null, this._pos = e.pos || null, this._pannerAttr = {
                            coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : 360,
                            coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : 360,
                            coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : 0,
                            distanceModel: void 0 !== e.distanceModel ? e.distanceModel : "inverse",
                            maxDistance: void 0 !== e.maxDistance ? e.maxDistance : 1e4,
                            panningModel: void 0 !== e.panningModel ? e.panningModel : "HRTF",
                            refDistance: void 0 !== e.refDistance ? e.refDistance : 1,
                            rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : 1
                        }, this._onstereo = e.onstereo ? [{
                            fn: e.onstereo
                        }] : [], this._onpos = e.onpos ? [{
                            fn: e.onpos
                        }] : [], this._onorientation = e.onorientation ? [{
                            fn: e.onorientation
                        }] : [], t.call(this, e)
                    }
                }(Howl.prototype.init), Howl.prototype.stereo = function(e, n) {
                    var i = this;
                    if (!i._webAudio) return i;
                    if ("loaded" !== i._state) return i._queue.push({
                        event: "stereo",
                        action: function() {
                            i.stereo(e, n)
                        }
                    }), i;
                    var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                    if (void 0 === n) {
                        if ("number" != typeof e) return i._stereo;
                        i._stereo = e, i._pos = [e, 0, 0]
                    }
                    for (var o = i._getSoundIds(n), a = 0; a < o.length; a++) {
                        var s = i._soundById(o[a]);
                        if (s) {
                            if ("number" != typeof e) return s._stereo;
                            s._stereo = e, s._pos = [e, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || t(s, r), "spatial" === r ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(e, 0, 0) : s._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), i._emit("stereo", s._id)
                        }
                    }
                    return i
                }, Howl.prototype.pos = function(e, n, i, r) {
                    var o = this;
                    if (!o._webAudio) return o;
                    if ("loaded" !== o._state) return o._queue.push({
                        event: "pos",
                        action: function() {
                            o.pos(e, n, i, r)
                        }
                    }), o;
                    if (n = "number" != typeof n ? 0 : n, i = "number" != typeof i ? -.5 : i, void 0 === r) {
                        if ("number" != typeof e) return o._pos;
                        o._pos = [e, n, i]
                    }
                    for (var a = o._getSoundIds(r), s = 0; s < a.length; s++) {
                        var c = o._soundById(a[s]);
                        if (c) {
                            if ("number" != typeof e) return c._pos;
                            c._pos = [e, n, i], c._node && (c._panner && !c._panner.pan || t(c, "spatial"), void 0 !== c._panner.positionX ? (c._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), c._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), c._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : c._panner.setPosition(e, n, i)), o._emit("pos", c._id)
                        }
                    }
                    return o
                }, Howl.prototype.orientation = function(e, n, i, r) {
                    var o = this;
                    if (!o._webAudio) return o;
                    if ("loaded" !== o._state) return o._queue.push({
                        event: "orientation",
                        action: function() {
                            o.orientation(e, n, i, r)
                        }
                    }), o;
                    if (n = "number" != typeof n ? o._orientation[1] : n, i = "number" != typeof i ? o._orientation[2] : i, void 0 === r) {
                        if ("number" != typeof e) return o._orientation;
                        o._orientation = [e, n, i]
                    }
                    for (var a = o._getSoundIds(r), s = 0; s < a.length; s++) {
                        var c = o._soundById(a[s]);
                        if (c) {
                            if ("number" != typeof e) return c._orientation;
                            c._orientation = [e, n, i], c._node && (c._panner || (c._pos || (c._pos = o._pos || [0, 0, -.5]), t(c, "spatial")), void 0 !== c._panner.orientationX ? (c._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), c._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), c._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : c._panner.setOrientation(e, n, i)), o._emit("orientation", c._id)
                        }
                    }
                    return o
                }, Howl.prototype.pannerAttr = function() {
                    var e, n, i, r = arguments;
                    if (!this._webAudio) return this;
                    if (0 === r.length) return this._pannerAttr;
                    if (1 === r.length) {
                        if ("object" != typeof r[0]) return (i = this._soundById(parseInt(r[0], 10))) ? i._pannerAttr : this._pannerAttr;
                        e = r[0], void 0 === n && (e.pannerAttr || (e.pannerAttr = {
                            coneInnerAngle: e.coneInnerAngle,
                            coneOuterAngle: e.coneOuterAngle,
                            coneOuterGain: e.coneOuterGain,
                            distanceModel: e.distanceModel,
                            maxDistance: e.maxDistance,
                            refDistance: e.refDistance,
                            rolloffFactor: e.rolloffFactor,
                            panningModel: e.panningModel
                        }), this._pannerAttr = {
                            coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : this._coneInnerAngle,
                            coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : this._coneOuterAngle,
                            coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : this._coneOuterGain,
                            distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : this._distanceModel,
                            maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : this._maxDistance,
                            refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : this._refDistance,
                            rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : this._rolloffFactor,
                            panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : this._panningModel
                        })
                    } else 2 === r.length && (e = r[0], n = parseInt(r[1], 10));
                    for (var o = this._getSoundIds(n), a = 0; a < o.length; a++)
                        if (i = this._soundById(o[a])) {
                            var s = i._pannerAttr;
                            s = {
                                coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : s.coneInnerAngle,
                                coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : s.coneOuterAngle,
                                coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : s.coneOuterGain,
                                distanceModel: void 0 !== e.distanceModel ? e.distanceModel : s.distanceModel,
                                maxDistance: void 0 !== e.maxDistance ? e.maxDistance : s.maxDistance,
                                refDistance: void 0 !== e.refDistance ? e.refDistance : s.refDistance,
                                rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : s.rolloffFactor,
                                panningModel: void 0 !== e.panningModel ? e.panningModel : s.panningModel
                            };
                            var c = i._panner;
                            c ? (c.coneInnerAngle = s.coneInnerAngle, c.coneOuterAngle = s.coneOuterAngle, c.coneOuterGain = s.coneOuterGain, c.distanceModel = s.distanceModel, c.maxDistance = s.maxDistance, c.refDistance = s.refDistance, c.rolloffFactor = s.rolloffFactor, c.panningModel = s.panningModel) : (i._pos || (i._pos = this._pos || [0, 0, -.5]), t(i, "spatial"))
                        }
                    return this
                }, Sound.prototype.init = function(t) {
                    return function() {
                        var e = this._parent;
                        this._orientation = e._orientation, this._stereo = e._stereo, this._pos = e._pos, this._pannerAttr = e._pannerAttr, t.call(this), this._stereo ? e.stereo(this._stereo) : this._pos && e.pos(this._pos[0], this._pos[1], this._pos[2], this._id)
                    }
                }(Sound.prototype.init), Sound.prototype.reset = function(t) {
                    return function() {
                        var e = this._parent;
                        return this._orientation = e._orientation, this._stereo = e._stereo, this._pos = e._pos, this._pannerAttr = e._pannerAttr, this._stereo ? e.stereo(this._stereo) : this._pos ? e.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, e._refreshBuffer(this)), t.call(this)
                    }
                }(Sound.prototype.reset);
                var t = function(t, e) {
                    "spatial" === (e = e || "spatial") ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, void 0 !== t._panner.positionX ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), void 0 !== t._panner.orientationX ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0)
                }
            }()
        }).call(this, n(27))
    }, function(t, e) {
        t.exports = function(t) {
            return null != t && "object" == typeof t
        }
    }, function(t, e, n) {
        var i = n(106);
        t.exports = function(t, e) {
            var n = t.__data__;
            return i(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
        }
    }, function(t, e, n) {
        var i = n(16)(Object, "create");
        t.exports = i
    }, function(t, e, n) {
        var i = n(31),
            r = n(119),
            o = n(118),
            a = "[object Null]",
            s = "[object Undefined]",
            c = i ? i.toStringTag : void 0;
        t.exports = function(t) {
            return null == t ? void 0 === t ? s : a : c && c in Object(t) ? r(t) : o(t)
        }
    }, function(t, e, n) {
        var i = n(45);
        t.exports = function(t, e) {
            for (var n = t.length; n--;)
                if (i(t[n][0], e)) return n;
            return -1
        }
    }, function(t, e, n) {
        var i = n(130),
            r = n(129),
            o = n(128),
            a = n(127),
            s = n(126);

        function c(t) {
            var e = -1,
                n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }
        c.prototype.clear = i, c.prototype.delete = r, c.prototype.get = o, c.prototype.has = a, c.prototype.set = s, t.exports = c
    }, function(t, e) {
        var n;
        n = function() {
            return this
        }();
        try {
            n = n || Function("return this")() || (0, eval)("this")
        } catch (t) {
            "object" == typeof window && (n = window)
        }
        t.exports = n
    }, , function(t, e, n) {
        "use strict";
        (function(t, i) {
            n.d(e, "a", function() {
                return r
            });
            /*!
             * VERSION: 2.1.3
             * DATE: 2019-05-17
             * UPDATES AND DOCS AT: http://greensock.com
             *
             * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
             * This work is subject to the terms at http://greensock.com/standard-license or for
             * Club GreenSock members, the software agreement that was issued with your membership.
             *
             * @author: Jack Doyle, jack@greensock.com
             */
            var r = "undefined" != typeof window ? window : void 0 !== t && t.exports && void 0 !== i ? i : {},
                o = (function(t) {
                    var e = {},
                        n = t.document,
                        i = t.GreenSockGlobals = t.GreenSockGlobals || t;
                    if (i.TweenLite) return i.TweenLite;
                    var r, o, a, s, c, l = function(t) {
                            var e, n = t.split("."),
                                r = i;
                            for (e = 0; e < n.length; e++) r[n[e]] = r = r[n[e]] || {};
                            return r
                        },
                        h = l("com.greensock"),
                        u = function(t) {
                            var e, n = [],
                                i = t.length;
                            for (e = 0; e !== i; n.push(t[e++]));
                            return n
                        },
                        p = function() {},
                        d = function() {
                            var t = Object.prototype.toString,
                                e = t.call([]);
                            return function(n) {
                                return null != n && (n instanceof Array || "object" == typeof n && !!n.push && t.call(n) === e)
                            }
                        }(),
                        f = {},
                        m = function(t, n, r, o) {
                            this.sc = f[t] ? f[t].sc : [], f[t] = this, this.gsClass = null, this.func = r;
                            var a = [];
                            this.check = function(s) {
                                for (var c, h, u, p, d = n.length, v = d; --d > -1;)(c = f[n[d]] || new m(n[d], [])).gsClass ? (a[d] = c.gsClass, v--) : s && c.sc.push(this);
                                if (0 === v && r)
                                    for (u = (h = ("com.greensock." + t).split(".")).pop(), p = l(h.join("."))[u] = this.gsClass = r.apply(r, a), o && (i[u] = e[u] = p), d = 0; d < this.sc.length; d++) this.sc[d].check()
                            }, this.check(!0)
                        },
                        v = t._gsDefine = function(t, e, n, i) {
                            return new m(t, e, n, i)
                        },
                        g = h._class = function(t, e, n) {
                            return e = e || function() {}, v(t, [], function() {
                                return e
                            }, n), e
                        };
                    v.globals = i;
                    var y = [0, 0, 1, 1],
                        _ = g("easing.Ease", function(t, e, n, i) {
                            this._func = t, this._type = n || 0, this._power = i || 0, this._params = e ? y.concat(e) : y
                        }, !0),
                        x = _.map = {},
                        b = _.register = function(t, e, n, i) {
                            for (var r, o, a, s, c = e.split(","), l = c.length, u = (n || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
                                for (o = c[l], r = i ? g("easing." + o, null, !0) : h.easing[o] || {}, a = u.length; --a > -1;) s = u[a], x[o + "." + s] = x[s + o] = r[s] = t.getRatio ? t : t[s] || new t
                        };
                    for ((a = _.prototype)._calcEnd = !1, a.getRatio = function(t) {
                            if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                            var e = this._type,
                                n = this._power,
                                i = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                            return 1 === n ? i *= i : 2 === n ? i *= i * i : 3 === n ? i *= i * i * i : 4 === n && (i *= i * i * i * i), 1 === e ? 1 - i : 2 === e ? i : t < .5 ? i / 2 : 1 - i / 2
                        }, o = (r = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --o > -1;) a = r[o] + ",Power" + o, b(new _(null, null, 1, o), a, "easeOut", !0), b(new _(null, null, 2, o), a, "easeIn" + (0 === o ? ",easeNone" : "")), b(new _(null, null, 3, o), a, "easeInOut");
                    x.linear = h.easing.Linear.easeIn, x.swing = h.easing.Quad.easeInOut;
                    var w = g("events.EventDispatcher", function(t) {
                        this._listeners = {}, this._eventTarget = t || this
                    });
                    (a = w.prototype).addEventListener = function(t, e, n, i, r) {
                        r = r || 0;
                        var o, a, l = this._listeners[t],
                            h = 0;
                        for (this !== s || c || s.wake(), null == l && (this._listeners[t] = l = []), a = l.length; --a > -1;)(o = l[a]).c === e && o.s === n ? l.splice(a, 1) : 0 === h && o.pr < r && (h = a + 1);
                        l.splice(h, 0, {
                            c: e,
                            s: n,
                            up: i,
                            pr: r
                        })
                    }, a.removeEventListener = function(t, e) {
                        var n, i = this._listeners[t];
                        if (i)
                            for (n = i.length; --n > -1;)
                                if (i[n].c === e) return void i.splice(n, 1)
                    }, a.dispatchEvent = function(t) {
                        var e, n, i, r = this._listeners[t];
                        if (r)
                            for ((e = r.length) > 1 && (r = r.slice(0)), n = this._eventTarget; --e > -1;)(i = r[e]) && (i.up ? i.c.call(i.s || n, {
                                type: t,
                                target: n
                            }) : i.c.call(i.s || n))
                    };
                    var M = t.requestAnimationFrame,
                        T = t.cancelAnimationFrame,
                        E = Date.now || function() {
                            return (new Date).getTime()
                        },
                        S = E();
                    for (o = (r = ["ms", "moz", "webkit", "o"]).length; --o > -1 && !M;) M = t[r[o] + "RequestAnimationFrame"], T = t[r[o] + "CancelAnimationFrame"] || t[r[o] + "CancelRequestAnimationFrame"];
                    g("Ticker", function(t, e) {
                        var i, r, o, a, l, h = this,
                            u = E(),
                            d = !(!1 === e || !M) && "auto",
                            f = 500,
                            m = 33,
                            v = function(t) {
                                var e, n, s = E() - S;
                                s > f && (u += s - m), S += s, h.time = (S - u) / 1e3, e = h.time - l, (!i || e > 0 || !0 === t) && (h.frame++, l += e + (e >= a ? .004 : a - e), n = !0), !0 !== t && (o = r(v)), n && h.dispatchEvent("tick")
                            };
                        w.call(h), h.time = h.frame = 0, h.tick = function() {
                            v(!0)
                        }, h.lagSmoothing = function(t, e) {
                            if (!arguments.length) return f < 1e8;
                            f = t || 1e8, m = Math.min(e, f, 0)
                        }, h.sleep = function() {
                            null != o && (d && T ? T(o) : clearTimeout(o), r = p, o = null, h === s && (c = !1))
                        }, h.wake = function(t) {
                            null !== o ? h.sleep() : t ? u += -S + (S = E()) : h.frame > 10 && (S = E() - f + 5), r = 0 === i ? p : d && M ? M : function(t) {
                                return setTimeout(t, 1e3 * (l - h.time) + 1 | 0)
                            }, h === s && (c = !0), v(2)
                        }, h.fps = function(t) {
                            if (!arguments.length) return i;
                            a = 1 / ((i = t) || 60), l = this.time + a, h.wake()
                        }, h.useRAF = function(t) {
                            if (!arguments.length) return d;
                            h.sleep(), d = t, h.fps(i)
                        }, h.fps(t), setTimeout(function() {
                            "auto" === d && h.frame < 5 && "hidden" !== (n || {}).visibilityState && h.useRAF(!1)
                        }, 1500)
                    }), (a = h.Ticker.prototype = new h.events.EventDispatcher).constructor = h.Ticker;
                    var A = g("core.Animation", function(t, e) {
                        if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !!e.immediateRender, this.data = e.data, this._reversed = !!e.reversed, q) {
                            c || s.wake();
                            var n = this.vars.useFrames ? X : q;
                            n.add(this, n._time), this.vars.paused && this.paused(!0)
                        }
                    });
                    s = A.ticker = new h.Ticker, (a = A.prototype)._dirty = a._gc = a._initted = a._paused = !1, a._totalTime = a._time = 0, a._rawPrevTime = -1, a._next = a._last = a._onUpdate = a._timeline = a.timeline = null, a._paused = !1;
                    var P = function() {
                        c && E() - S > 2e3 && ("hidden" !== (n || {}).visibilityState || !s.lagSmoothing()) && s.wake();
                        var t = setTimeout(P, 2e3);
                        t.unref && t.unref()
                    };
                    P(), a.play = function(t, e) {
                        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                    }, a.pause = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!0)
                    }, a.resume = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!1)
                    }, a.seek = function(t, e) {
                        return this.totalTime(Number(t), !1 !== e)
                    }, a.restart = function(t, e) {
                        return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                    }, a.reverse = function(t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                    }, a.render = function(t, e, n) {}, a.invalidate = function() {
                        return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                    }, a.isActive = function() {
                        var t, e = this._timeline,
                            n = this._startTime;
                        return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= n && t < n + this.totalDuration() / this._timeScale - 1e-8
                    }, a._enabled = function(t, e) {
                        return c || s.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                    }, a._kill = function(t, e) {
                        return this._enabled(!1, !1)
                    }, a.kill = function(t, e) {
                        return this._kill(t, e), this
                    }, a._uncache = function(t) {
                        for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                        return this
                    }, a._swapSelfInParams = function(t) {
                        for (var e = t.length, n = t.concat(); --e > -1;) "{self}" === t[e] && (n[e] = this);
                        return n
                    }, a._callback = function(t) {
                        var e = this.vars,
                            n = e[t],
                            i = e[t + "Params"],
                            r = e[t + "Scope"] || e.callbackScope || this;
                        switch (i ? i.length : 0) {
                            case 0:
                                n.call(r);
                                break;
                            case 1:
                                n.call(r, i[0]);
                                break;
                            case 2:
                                n.call(r, i[0], i[1]);
                                break;
                            default:
                                n.apply(r, i)
                        }
                    }, a.eventCallback = function(t, e, n, i) {
                        if ("on" === (t || "").substr(0, 2)) {
                            var r = this.vars;
                            if (1 === arguments.length) return r[t];
                            null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = d(n) && -1 !== n.join("").indexOf("{self}") ? this._swapSelfInParams(n) : n, r[t + "Scope"] = i), "onUpdate" === t && (this._onUpdate = e)
                        }
                        return this
                    }, a.delay = function(t) {
                        return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                    }, a.duration = function(t) {
                        return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                    }, a.totalDuration = function(t) {
                        return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                    }, a.time = function(t, e) {
                        return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                    }, a.totalTime = function(t, e, n) {
                        if (c || s.wake(), !arguments.length) return this._totalTime;
                        if (this._timeline) {
                            if (t < 0 && !n && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                                this._dirty && this.totalDuration();
                                var i = this._totalDuration,
                                    r = this._timeline;
                                if (t > i && !n && (t = i), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? i - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                    for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                            }
                            this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (O.length && Z(), this.render(t, e, !1), O.length && Z())
                        }
                        return this
                    }, a.progress = a.totalProgress = function(t, e) {
                        var n = this.duration();
                        return arguments.length ? this.totalTime(n * t, e) : n ? this._time / n : this.ratio
                    }, a.startTime = function(t) {
                        return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                    }, a.endTime = function(t) {
                        return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                    }, a.timeScale = function(t) {
                        if (!arguments.length) return this._timeScale;
                        var e, n;
                        for (t = t || 1e-8, this._timeline && this._timeline.smoothChildTiming && (n = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = n - (n - this._startTime) * this._timeScale / t), this._timeScale = t, n = this.timeline; n && n.timeline;) n._dirty = !0, n.totalDuration(), n = n.timeline;
                        return this
                    }, a.reversed = function(t) {
                        return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                    }, a.paused = function(t) {
                        if (!arguments.length) return this._paused;
                        var e, n, i = this._timeline;
                        return t != this._paused && i && (c || t || s.wake(), n = (e = i.rawTime()) - this._pauseTime, !t && i.smoothChildTiming && (this._startTime += n, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== n && this._initted && this.duration() && (e = i.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                    };
                    var L = g("core.SimpleTimeline", function(t) {
                        A.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                    });
                    (a = L.prototype = new A).constructor = L, a.kill()._gc = !1, a._first = a._last = a._recent = null, a._sortChildren = !1, a.add = a.insert = function(t, e, n, i) {
                        var r, o;
                        if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                            for (o = t._startTime; r && r._startTime > o;) r = r._prev;
                        return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                    }, a._remove = function(t, e) {
                        return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                    }, a.render = function(t, e, n) {
                        var i, r = this._first;
                        for (this._totalTime = this._time = this._rawPrevTime = t; r;) i = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, n) : r.render((t - r._startTime) * r._timeScale, e, n)), r = i
                    }, a.rawTime = function() {
                        return c || s.wake(), this._totalTime
                    };
                    var R = g("TweenLite", function(e, n, i) {
                            if (A.call(this, n, i), this.render = R.prototype.render, null == e) throw "Cannot tween a null target.";
                            this.target = e = "string" != typeof e ? e : R.selector(e) || e;
                            var r, o, a, s = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
                                c = this.vars.overwrite;
                            if (this._overwrite = c = null == c ? W[R.defaultOverwrite] : "number" == typeof c ? c >> 0 : W[c], (s || e instanceof Array || e.push && d(e)) && "number" != typeof e[0])
                                for (this._targets = a = u(e), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++)(o = a[r]) ? "string" != typeof o ? o.length && o !== t && o[0] && (o[0] === t || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(u(o))) : (this._siblings[r] = J(o, this, !1), 1 === c && this._siblings[r].length > 1 && Q(o, this, null, 1, this._siblings[r])) : "string" == typeof(o = a[r--] = R.selector(o)) && a.splice(r + 1, 1) : a.splice(r--, 1);
                            else this._propLookup = {}, this._siblings = J(e, this, !1), 1 === c && this._siblings.length > 1 && Q(e, this, null, 1, this._siblings);
                            (this.vars.immediateRender || 0 === n && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-8, this.render(Math.min(0, -this._delay)))
                        }, !0),
                        C = function(e) {
                            return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
                        };
                    (a = R.prototype = new A).constructor = R, a.kill()._gc = !1, a.ratio = 0, a._firstPT = a._targets = a._overwrittenProps = a._startAt = null, a._notifyPluginsOfEnabled = a._lazy = !1, R.version = "2.1.3", R.defaultEase = a._ease = new _(null, null, 1, 1), R.defaultOverwrite = "auto", R.ticker = s, R.autoSleep = 120, R.lagSmoothing = function(t, e) {
                        s.lagSmoothing(t, e)
                    }, R.selector = t.$ || t.jQuery || function(e) {
                        var i = t.$ || t.jQuery;
                        return i ? (R.selector = i, i(e)) : (n || (n = t.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e)
                    };
                    var O = [],
                        I = {},
                        D = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                        N = /[\+-]=-?[\.\d]/,
                        B = function(t) {
                            for (var e, n = this._firstPT; n;) e = n.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : n.c * t + n.s, n.m ? e = n.m.call(this._tween, e, this._target || n.t, this._tween) : e < 1e-6 && e > -1e-6 && !n.blob && (e = 0), n.f ? n.fp ? n.t[n.p](n.fp, e) : n.t[n.p](e) : n.t[n.p] = e, n = n._next
                        },
                        H = function(t) {
                            return (1e3 * t | 0) / 1e3 + ""
                        },
                        F = function(t, e, n, i) {
                            var r, o, a, s, c, l, h, u = [],
                                p = 0,
                                d = "",
                                f = 0;
                            for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", n && (n(u), t = u[0], e = u[1]), u.length = 0, r = t.match(D) || [], o = e.match(D) || [], i && (i._next = null, i.blob = 1, u._firstPT = u._applyPT = i), c = o.length, s = 0; s < c; s++) h = o[s], d += (l = e.substr(p, e.indexOf(h, p) - p)) || !s ? l : ",", p += l.length, f ? f = (f + 1) % 5 : "rgba(" === l.substr(-5) && (f = 1), h === r[s] || r.length <= s ? d += h : (d && (u.push(d), d = ""), a = parseFloat(r[s]), u.push(a), u._firstPT = {
                                _next: u._firstPT,
                                t: u,
                                p: u.length - 1,
                                s: a,
                                c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - a) || 0,
                                f: 0,
                                m: f && f < 4 ? Math.round : H
                            }), p += h.length;
                            return (d += e.substr(p)) && u.push(d), u.setRatio = B, N.test(e) && (u.end = null), u
                        },
                        k = function(t, e, n, i, r, o, a, s, c) {
                            "function" == typeof i && (i = i(c || 0, t));
                            var l = typeof t[e],
                                h = "function" !== l ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                                u = "get" !== n ? n : h ? a ? t[h](a) : t[h]() : t[e],
                                p = "string" == typeof i && "=" === i.charAt(1),
                                d = {
                                    t: t,
                                    p: e,
                                    s: u,
                                    f: "function" === l,
                                    pg: 0,
                                    n: r || e,
                                    m: o ? "function" == typeof o ? o : Math.round : 0,
                                    pr: 0,
                                    c: p ? parseInt(i.charAt(0) + "1", 10) * parseFloat(i.substr(2)) : parseFloat(i) - u || 0
                                };
                            if (("number" != typeof u || "number" != typeof i && !p) && (a || isNaN(u) || !p && isNaN(i) || "boolean" == typeof u || "boolean" == typeof i ? (d.fp = a, d = {
                                    t: F(u, p ? parseFloat(d.s) + d.c + (d.s + "").replace(/[0-9\-\.]/g, "") : i, s || R.defaultStringFilter, d),
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 2,
                                    pg: 0,
                                    n: r || e,
                                    pr: 0,
                                    m: 0
                                }) : (d.s = parseFloat(u), p || (d.c = parseFloat(i) - d.s || 0))), d.c) return (d._next = this._firstPT) && (d._next._prev = d), this._firstPT = d, d
                        },
                        U = R._internals = {
                            isArray: d,
                            isSelector: C,
                            lazyTweens: O,
                            blobDif: F
                        },
                        z = R._plugins = {},
                        G = U.tweenLookup = {},
                        j = 0,
                        V = U.reservedProps = {
                            ease: 1,
                            delay: 1,
                            overwrite: 1,
                            onComplete: 1,
                            onCompleteParams: 1,
                            onCompleteScope: 1,
                            useFrames: 1,
                            runBackwards: 1,
                            startAt: 1,
                            onUpdate: 1,
                            onUpdateParams: 1,
                            onUpdateScope: 1,
                            onStart: 1,
                            onStartParams: 1,
                            onStartScope: 1,
                            onReverseComplete: 1,
                            onReverseCompleteParams: 1,
                            onReverseCompleteScope: 1,
                            onRepeat: 1,
                            onRepeatParams: 1,
                            onRepeatScope: 1,
                            easeParams: 1,
                            yoyo: 1,
                            immediateRender: 1,
                            repeat: 1,
                            repeatDelay: 1,
                            data: 1,
                            paused: 1,
                            reversed: 1,
                            autoCSS: 1,
                            lazy: 1,
                            onOverwrite: 1,
                            callbackScope: 1,
                            stringFilter: 1,
                            id: 1,
                            yoyoEase: 1,
                            stagger: 1
                        },
                        W = {
                            none: 0,
                            all: 1,
                            auto: 2,
                            concurrent: 3,
                            allOnStart: 4,
                            preexisting: 5,
                            true: 1,
                            false: 0
                        },
                        X = A._rootFramesTimeline = new L,
                        q = A._rootTimeline = new L,
                        Y = 30,
                        Z = U.lazyRender = function() {
                            var t, e, n = O.length;
                            for (I = {}, t = 0; t < n; t++)(e = O[t]) && !1 !== e._lazy && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1);
                            O.length = 0
                        };
                    q._startTime = s.time, X._startTime = s.frame, q._active = X._active = !0, setTimeout(Z, 1), A._updateRoot = R.render = function() {
                        var t, e, n;
                        if (O.length && Z(), q.render((s.time - q._startTime) * q._timeScale, !1, !1), X.render((s.frame - X._startTime) * X._timeScale, !1, !1), O.length && Z(), s.frame >= Y) {
                            for (n in Y = s.frame + (parseInt(R.autoSleep, 10) || 120), G) {
                                for (t = (e = G[n].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                                0 === e.length && delete G[n]
                            }
                            if ((!(n = q._first) || n._paused) && R.autoSleep && !X._first && 1 === s._listeners.tick.length) {
                                for (; n && n._paused;) n = n._next;
                                n || s.sleep()
                            }
                        }
                    }, s.addEventListener("tick", A._updateRoot);
                    var J = function(t, e, n) {
                            var i, r, o = t._gsTweenID;
                            if (G[o || (t._gsTweenID = o = "t" + j++)] || (G[o] = {
                                    target: t,
                                    tweens: []
                                }), e && ((i = G[o].tweens)[r = i.length] = e, n))
                                for (; --r > -1;) i[r] === e && i.splice(r, 1);
                            return G[o].tweens
                        },
                        K = function(t, e, n, i) {
                            var r, o, a = t.vars.onOverwrite;
                            return a && (r = a(t, e, n, i)), (a = R.onOverwrite) && (o = a(t, e, n, i)), !1 !== r && !1 !== o
                        },
                        Q = function(t, e, n, i, r) {
                            var o, a, s, c;
                            if (1 === i || i >= 4) {
                                for (c = r.length, o = 0; o < c; o++)
                                    if ((s = r[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                                    else if (5 === i) break;
                                return a
                            }
                            var l, h = e._startTime + 1e-8,
                                u = [],
                                p = 0,
                                d = 0 === e._duration;
                            for (o = r.length; --o > -1;)(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (l = l || $(e, 0, d), 0 === $(s, l, d) && (u[p++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((d || !s._initted) && h - s._startTime <= 2e-8 || (u[p++] = s)));
                            for (o = p; --o > -1;)
                                if (c = (s = u[o])._firstPT, 2 === i && s._kill(n, t, e) && (a = !0), 2 !== i || !s._firstPT && s._initted && c) {
                                    if (2 !== i && !K(s, e)) continue;
                                    s._enabled(!1, !1) && (a = !0)
                                }
                            return a
                        },
                        $ = function(t, e, n) {
                            for (var i = t._timeline, r = i._timeScale, o = t._startTime; i._timeline;) {
                                if (o += i._startTime, r *= i._timeScale, i._paused) return -100;
                                i = i._timeline
                            }
                            return (o /= r) > e ? o - e : n && o === e || !t._initted && o - e < 2e-8 ? 1e-8 : (o += t.totalDuration() / t._timeScale / r) > e + 1e-8 ? 0 : o - e - 1e-8
                        };
                    a._init = function() {
                        var t, e, n, i, r, o, a = this.vars,
                            s = this._overwrittenProps,
                            c = this._duration,
                            l = !!a.immediateRender,
                            h = a.ease,
                            u = this._startAt;
                        if (a.startAt) {
                            for (i in u && (u.render(-1, !0), u.kill()), r = {}, a.startAt) r[i] = a.startAt[i];
                            if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== a.lazy, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = R.to(this.target || {}, 0, r), l)
                                if (this._time > 0) this._startAt = null;
                                else if (0 !== c) return
                        } else if (a.runBackwards && 0 !== c)
                            if (u) u.render(-1, !0), u.kill(), this._startAt = null;
                            else {
                                for (i in 0 !== this._time && (l = !1), n = {}, a) V[i] && "autoCSS" !== i || (n[i] = a[i]);
                                if (n.overwrite = 0, n.data = "isFromStart", n.lazy = l && !1 !== a.lazy, n.immediateRender = l, this._startAt = R.to(this.target, 0, n), l) {
                                    if (0 === this._time) return
                                } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                            }
                        if (this._ease = h = h ? h instanceof _ ? h : "function" == typeof h ? new _(h, a.easeParams) : x[h] || R.defaultEase : R.defaultEase, a.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                            for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                        else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                        if (e && R._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                            for (n = this._firstPT; n;) n.s += n.c, n.c = -n.c, n = n._next;
                        this._onUpdate = a.onUpdate, this._initted = !0
                    }, a._initProps = function(e, n, i, r, o) {
                        var a, s, c, l, h, u;
                        if (null == e) return !1;
                        for (a in I[e._gsTweenID] && Z(), this.vars.css || e.style && e !== t && e.nodeType && z.css && !1 !== this.vars.autoCSS && function(t, e) {
                                var n, i = {};
                                for (n in t) V[n] || n in e && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!z[n] || z[n] && z[n]._autoCSS) || (i[n] = t[n], delete t[n]);
                                t.css = i
                            }(this.vars, e), this.vars)
                            if (u = this.vars[a], V[a]) u && (u instanceof Array || u.push && d(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[a] = u = this._swapSelfInParams(u, this));
                            else if (z[a] && (l = new z[a])._onInitTween(e, this.vars[a], this, o)) {
                            for (this._firstPT = h = {
                                    _next: this._firstPT,
                                    t: l,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 1,
                                    n: a,
                                    pg: 1,
                                    pr: l._priority,
                                    m: 0
                                }, s = l._overwriteProps.length; --s > -1;) n[l._overwriteProps[s]] = this._firstPT;
                            (l._priority || l._onInitAllProps) && (c = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
                        } else n[a] = k.call(this, e, a, "get", u, a, 0, null, this.vars.stringFilter, o);
                        return r && this._kill(r, e) ? this._initProps(e, n, i, r, o) : this._overwrite > 1 && this._firstPT && i.length > 1 && Q(e, this, n, this._overwrite, i) ? (this._kill(n, e), this._initProps(e, n, i, r, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (I[e._gsTweenID] = !0), c)
                    }, a.render = function(t, e, n) {
                        var i, r, o, a, s = this._time,
                            c = this._duration,
                            l = this._rawPrevTime;
                        if (t >= c - 1e-8 && t >= 0) this._totalTime = this._time = c, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (i = !0, r = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === c && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (l < 0 || t <= 0 && t >= -1e-8 || 1e-8 === l && "isPause" !== this.data) && l !== t && (n = !0, l > 1e-8 && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : 1e-8);
                        else if (t < 1e-8) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === c && l > 0) && (r = "onReverseComplete", i = this._reversed), t > -1e-8 ? t = 0 : t < 0 && (this._active = !1, 0 === c && (this._initted || !this.vars.lazy || n) && (l >= 0 && (1e-8 !== l || "isPause" !== this.data) && (n = !0), this._rawPrevTime = a = !e || t || l === t ? t : 1e-8)), (!this._initted || this._startAt && this._startAt.progress()) && (n = !0);
                        else if (this._totalTime = this._time = t, this._easeType) {
                            var h = t / c,
                                u = this._easeType,
                                p = this._easePower;
                            (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === p ? h *= h : 2 === p ? h *= h * h : 3 === p ? h *= h * h * h : 4 === p && (h *= h * h * h * h), this.ratio = 1 === u ? 1 - h : 2 === u ? h : t / c < .5 ? h / 2 : 1 - h / 2
                        } else this.ratio = this._ease.getRatio(t / c);
                        if (this._time !== s || n) {
                            if (!this._initted) {
                                if (this._init(), !this._initted || this._gc) return;
                                if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = l, O.push(this), void(this._lazy = [t, e]);
                                this._time && !i ? this.ratio = this._ease.getRatio(this._time / c) : i && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                            }
                            for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, n) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== c || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                            this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, n), e || (this._time !== s || i || n) && this._callback("onUpdate")), r && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, n), i && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === c && 1e-8 === this._rawPrevTime && 1e-8 !== a && (this._rawPrevTime = 0)))
                        }
                    }, a._kill = function(t, e, n) {
                        if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                        e = "string" != typeof e ? e || this._targets || this.target : R.selector(e) || e;
                        var i, r, o, a, s, c, l, h, u, p = n && this._time && n._startTime === this._startTime && this._timeline === n._timeline,
                            f = this._firstPT;
                        if ((d(e) || C(e)) && "number" != typeof e[0])
                            for (i = e.length; --i > -1;) this._kill(t, e[i], n) && (c = !0);
                        else {
                            if (this._targets) {
                                for (i = this._targets.length; --i > -1;)
                                    if (e === this._targets[i]) {
                                        s = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all";
                                        break
                                    }
                            } else {
                                if (e !== this.target) return !1;
                                s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                            }
                            if (s) {
                                if (l = t || s, h = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), n && (R.onOverwrite || this.vars.onOverwrite)) {
                                    for (o in l) s[o] && (u || (u = []), u.push(o));
                                    if ((u || !t) && !K(this, n, e, u)) return !1
                                }
                                for (o in l)(a = s[o]) && (p && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, c = !0), a.pg && a.t._kill(l) && (c = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), h && (r[o] = 1);
                                !this._firstPT && this._initted && f && this._enabled(!1, !1)
                            }
                        }
                        return c
                    }, a.invalidate = function() {
                        this._notifyPluginsOfEnabled && R._onPluginEvent("_onDisable", this);
                        var t = this._time;
                        return this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], A.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-8, this.render(t, !1, !1 !== this.vars.lazy)), this
                    }, a._enabled = function(t, e) {
                        if (c || s.wake(), t && this._gc) {
                            var n, i = this._targets;
                            if (i)
                                for (n = i.length; --n > -1;) this._siblings[n] = J(i[n], this, !0);
                            else this._siblings = J(this.target, this, !0)
                        }
                        return A.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && R._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                    }, R.to = function(t, e, n) {
                        return new R(t, e, n)
                    }, R.from = function(t, e, n) {
                        return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new R(t, e, n)
                    }, R.fromTo = function(t, e, n, i) {
                        return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, new R(t, e, i)
                    }, R.delayedCall = function(t, e, n, i, r) {
                        return new R(e, 0, {
                            delay: t,
                            onComplete: e,
                            onCompleteParams: n,
                            callbackScope: i,
                            onReverseComplete: e,
                            onReverseCompleteParams: n,
                            immediateRender: !1,
                            lazy: !1,
                            useFrames: r,
                            overwrite: 0
                        })
                    }, R.set = function(t, e) {
                        return new R(t, 0, e)
                    }, R.getTweensOf = function(t, e) {
                        if (null == t) return [];
                        var n, i, r, o;
                        if (t = "string" != typeof t ? t : R.selector(t) || t, (d(t) || C(t)) && "number" != typeof t[0]) {
                            for (n = t.length, i = []; --n > -1;) i = i.concat(R.getTweensOf(t[n], e));
                            for (n = i.length; --n > -1;)
                                for (o = i[n], r = n; --r > -1;) o === i[r] && i.splice(n, 1)
                        } else if (t._gsTweenID)
                            for (n = (i = J(t).concat()).length; --n > -1;)(i[n]._gc || e && !i[n].isActive()) && i.splice(n, 1);
                        return i || []
                    }, R.killTweensOf = R.killDelayedCallsTo = function(t, e, n) {
                        "object" == typeof e && (n = e, e = !1);
                        for (var i = R.getTweensOf(t, e), r = i.length; --r > -1;) i[r]._kill(n, t)
                    };
                    var tt = g("plugins.TweenPlugin", function(t, e) {
                        this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = tt.prototype
                    }, !0);
                    if (a = tt.prototype, tt.version = "1.19.0", tt.API = 2, a._firstPT = null, a._addTween = k, a.setRatio = B, a._kill = function(t) {
                            var e, n = this._overwriteProps,
                                i = this._firstPT;
                            if (null != t[this._propName]) this._overwriteProps = [];
                            else
                                for (e = n.length; --e > -1;) null != t[n[e]] && n.splice(e, 1);
                            for (; i;) null != t[i.n] && (i._next && (i._next._prev = i._prev), i._prev ? (i._prev._next = i._next, i._prev = null) : this._firstPT === i && (this._firstPT = i._next)), i = i._next;
                            return !1
                        }, a._mod = a._roundProps = function(t) {
                            for (var e, n = this._firstPT; n;)(e = t[this._propName] || null != n.n && t[n.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === n.f ? n.t._applyPT.m = e : n.m = e), n = n._next
                        }, R._onPluginEvent = function(t, e) {
                            var n, i, r, o, a, s = e._firstPT;
                            if ("_onInitAllProps" === t) {
                                for (; s;) {
                                    for (a = s._next, i = r; i && i.pr > s.pr;) i = i._next;
                                    (s._prev = i ? i._prev : o) ? s._prev._next = s: r = s, (s._next = i) ? i._prev = s : o = s, s = a
                                }
                                s = e._firstPT = r
                            }
                            for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (n = !0), s = s._next;
                            return n
                        }, tt.activate = function(t) {
                            for (var e = t.length; --e > -1;) t[e].API === tt.API && (z[(new t[e])._propName] = t[e]);
                            return !0
                        }, v.plugin = function(t) {
                            if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                            var e, n = t.propName,
                                i = t.priority || 0,
                                r = t.overwriteProps,
                                o = {
                                    init: "_onInitTween",
                                    set: "setRatio",
                                    kill: "_kill",
                                    round: "_mod",
                                    mod: "_mod",
                                    initAll: "_onInitAllProps"
                                },
                                a = g("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin", function() {
                                    tt.call(this, n, i), this._overwriteProps = r || []
                                }, !0 === t.global),
                                s = a.prototype = new tt(n);
                            for (e in s.constructor = a, a.API = t.API, o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                            return a.version = t.version, tt.activate([a]), a
                        }, r = t._gsQueue) {
                        for (o = 0; o < r.length; o++) r[o]();
                        for (a in f) f[a].func || t.console.log("GSAP encountered missing dependency: " + a)
                    }
                    c = !1
                }(r), r.GreenSockGlobals),
                a = o.com.greensock;
            a.core.SimpleTimeline, a.core.Animation, o.Ease, o.Linear, o.Power1, o.Power2, o.Power3, o.Power4, o.TweenPlugin, a.events.EventDispatcher
        }).call(this, n(134)(t), n(27))
    }, function(t, e) {
        var n = Array.isArray;
        t.exports = n
    }, function(t, e, n) {
        var i = n(14).Symbol;
        t.exports = i
    }, function(t, e, n) {
        var i = n(16)(n(14), "Map");
        t.exports = i
    }, function(t, e) {
        /*!
         * verge 1.10.2+201705300050
         * http://npm.im/verge
         * MIT Ryan Van Etten
         */
        ! function(e, n, i) {
            void 0 !== t && t.exports ? t.exports = i() : e.verge = i()
        }(this, 0, function() {
            var t = {},
                e = "undefined" != typeof window && window,
                n = "undefined" != typeof document && document,
                i = n && n.documentElement,
                r = e.matchMedia || e.msMatchMedia,
                o = r ? function(t) {
                    return !!r.call(e, t).matches
                } : function() {
                    return !1
                },
                a = t.viewportW = function() {
                    var t = i.clientWidth,
                        n = e.innerWidth;
                    return t < n ? n : t
                },
                s = t.viewportH = function() {
                    var t = i.clientHeight,
                        n = e.innerHeight;
                    return t < n ? n : t
                };

            function c() {
                return {
                    width: a(),
                    height: s()
                }
            }

            function l(t, e) {
                return !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && function(t, e) {
                    var n = {};
                    return e = +e || 0, n.width = (n.right = t.right + e) - (n.left = t.left - e), n.height = (n.bottom = t.bottom + e) - (n.top = t.top - e), n
                }(t.getBoundingClientRect(), e)
            }
            return t.mq = o, t.matchMedia = r ? function() {
                return r.apply(e, arguments)
            } : function() {
                return {}
            }, t.viewport = c, t.scrollX = function() {
                return e.pageXOffset || i.scrollLeft
            }, t.scrollY = function() {
                return e.pageYOffset || i.scrollTop
            }, t.rectangle = l, t.aspect = function(t) {
                var e = (t = null == t ? c() : 1 === t.nodeType ? l(t) : t).height,
                    n = t.width;
                return e = "function" == typeof e ? e.call(t) : e, (n = "function" == typeof n ? n.call(t) : n) / e
            }, t.inX = function(t, e) {
                var n = l(t, e);
                return !!n && n.right >= 0 && n.left <= a()
            }, t.inY = function(t, e) {
                var n = l(t, e);
                return !!n && n.bottom >= 0 && n.top <= s()
            }, t.inViewport = function(t, e) {
                var n = l(t, e);
                return !!n && n.bottom >= 0 && n.right >= 0 && n.top <= s() && n.left <= a()
            }, t
        })
    }, function(t, e, n) {
        "use strict";
        /*!
         * resource-loader - v3.0.1
         * https://github.com/pixijs/pixi-sound
         * Compiled Tue, 02 Jul 2019 14:06:18 UTC
         *
         * resource-loader is licensed under the MIT license.
         * http://www.opensource.org/licenses/mit-license
         */
        function i(t) {
            return t && "object" == typeof t && "default" in t ? t.default : t
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var r = i(n(164)),
            o = i(n(163));

        function a() {}

        function s(t, e, n, i) {
            var r = 0,
                o = t.length;
            ! function a(s) {
                s || r === o ? n && n(s) : i ? setTimeout(function() {
                    e(t[r++], a)
                }, 1) : e(t[r++], a)
            }()
        }

        function c(t) {
            return function() {
                if (null === t) throw new Error("Callback was already called.");
                var e = t;
                t = null, e.apply(this, arguments)
            }
        }

        function l(t, e) {
            if (null == e) e = 1;
            else if (0 === e) throw new Error("Concurrency must not be zero");
            var n = 0,
                i = {
                    _tasks: [],
                    concurrency: e,
                    saturated: a,
                    unsaturated: a,
                    buffer: e / 4,
                    empty: a,
                    drain: a,
                    error: a,
                    started: !1,
                    paused: !1,
                    push: function(t, e) {
                        r(t, !1, e)
                    },
                    kill: function() {
                        n = 0, i.drain = a, i.started = !1, i._tasks = []
                    },
                    unshift: function(t, e) {
                        r(t, !0, e)
                    },
                    process: function() {
                        for (; !i.paused && n < i.concurrency && i._tasks.length;) {
                            var e = i._tasks.shift();
                            0 === i._tasks.length && i.empty(), (n += 1) === i.concurrency && i.saturated(), t(e.data, c(o(e)))
                        }
                    },
                    length: function() {
                        return i._tasks.length
                    },
                    running: function() {
                        return n
                    },
                    idle: function() {
                        return i._tasks.length + n === 0
                    },
                    pause: function() {
                        !0 !== i.paused && (i.paused = !0)
                    },
                    resume: function() {
                        if (!1 !== i.paused) {
                            i.paused = !1;
                            for (var t = 1; t <= i.concurrency; t++) i.process()
                        }
                    }
                };

            function r(t, e, n) {
                if (null != n && "function" != typeof n) throw new Error("task callback must be a function");
                if (i.started = !0, null == t && i.idle()) setTimeout(function() {
                    return i.drain()
                }, 1);
                else {
                    var r = {
                        data: t,
                        callback: "function" == typeof n ? n : a
                    };
                    e ? i._tasks.unshift(r) : i._tasks.push(r), setTimeout(function() {
                        return i.process()
                    }, 1)
                }
            }

            function o(t) {
                return function() {
                    n -= 1, t.callback.apply(t, arguments), null != arguments[0] && i.error(arguments[0], t.data), n <= i.concurrency - i.buffer && i.unsaturated(), i.idle() && i.drain(), i.process()
                }
            }
            return i
        }
        var h = {
                eachSeries: s,
                queue: l
            },
            u = {};

        function p(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function d(t, e, n) {
            return e && p(t.prototype, e), n && p(t, n), t
        }
        var f = !(!window.XDomainRequest || "withCredentials" in new XMLHttpRequest),
            m = null;

        function v() {}
        var g = function() {
            function t(e, n, i) {
                if ("string" != typeof e || "string" != typeof n) throw new Error("Both name and url are required for constructing a resource.");
                i = i || {}, this._flags = 0, this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === n.indexOf("data:")), this.name = e, this.url = n, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === i.crossOrigin ? "anonymous" : i.crossOrigin, this.timeout = i.timeout || 0, this.loadType = i.loadType || this._determineLoadType(), this.xhrType = i.xhrType, this.metadata = i.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = v, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new o, this.onProgress = new o, this.onComplete = new o, this.onAfterMiddleware = new o
            }
            t.setExtensionLoadType = function(e, n) {
                y(t._loadTypeMap, e, n)
            }, t.setExtensionXhrType = function(e, n) {
                y(t._xhrTypeMap, e, n)
            };
            var e = t.prototype;
            return e.complete = function() {
                this._clearEvents(), this._finish()
            }, e.abort = function(e) {
                if (!this.error) {
                    if (this.error = new Error(e), this._clearEvents(), this.xhr) this.xhr.abort();
                    else if (this.xdr) this.xdr.abort();
                    else if (this.data)
                        if (this.data.src) this.data.src = t.EMPTY_GIF;
                        else
                            for (; this.data.firstChild;) this.data.removeChild(this.data.firstChild);
                    this._finish()
                }
            }, e.load = function(e) {
                var n = this;
                if (!this.isLoading)
                    if (this.isComplete) e && setTimeout(function() {
                        return e(n)
                    }, 1);
                    else switch (e && this.onComplete.once(e), this._setFlag(t.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
                        case t.LOAD_TYPE.IMAGE:
                            this.type = t.TYPE.IMAGE, this._loadElement("image");
                            break;
                        case t.LOAD_TYPE.AUDIO:
                            this.type = t.TYPE.AUDIO, this._loadSourceElement("audio");
                            break;
                        case t.LOAD_TYPE.VIDEO:
                            this.type = t.TYPE.VIDEO, this._loadSourceElement("video");
                            break;
                        case t.LOAD_TYPE.XHR:
                        default:
                            f && this.crossOrigin ? this._loadXdr() : this._loadXhr()
                    }
            }, e._hasFlag = function(t) {
                return 0 != (this._flags & t)
            }, e._setFlag = function(t, e) {
                this._flags = e ? this._flags | t : this._flags & ~t
            }, e._clearEvents = function() {
                clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null))
            }, e._finish = function() {
                if (this.isComplete) throw new Error("Complete called again for an already completed resource.");
                this._setFlag(t.STATUS_FLAGS.COMPLETE, !0), this._setFlag(t.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this)
            }, e._loadElement = function(t) {
                this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && void 0 !== window.Image ? this.data = new Image : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
            }, e._loadSourceElement = function(t) {
                if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && void 0 !== window.Audio ? this.data = new Audio : this.data = document.createElement(t), null !== this.data) {
                    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
                        if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
                        else if (Array.isArray(this.url))
                        for (var e = this.metadata.mimeType, n = 0; n < this.url.length; ++n) this.data.appendChild(this._createSource(t, this.url[n], Array.isArray(e) ? e[n] : e));
                    else {
                        var i = this.metadata.mimeType;
                        this.data.appendChild(this._createSource(t, this.url, Array.isArray(i) ? i[0] : i))
                    }
                    this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
                } else this.abort("Unsupported element: " + t)
            }, e._loadXhr = function() {
                "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                var e = this.xhr = new XMLHttpRequest;
                e.open("GET", this.url, !0), e.timeout = this.timeout, this.xhrType === t.XHR_RESPONSE_TYPE.JSON || this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = t.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener("error", this._boundXhrOnError, !1), e.addEventListener("timeout", this._boundXhrOnTimeout, !1), e.addEventListener("abort", this._boundXhrOnAbort, !1), e.addEventListener("progress", this._boundOnProgress, !1), e.addEventListener("load", this._boundXhrOnLoad, !1), e.send()
            }, e._loadXdr = function() {
                "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                var t = this.xhr = new XDomainRequest;
                t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
                    return t.send()
                }, 1)
            }, e._createSource = function(t, e, n) {
                n || (n = t + "/" + this._getExtension(e));
                var i = document.createElement("source");
                return i.src = e, i.type = n, i
            }, e._onError = function(t) {
                this.abort("Failed to load element using: " + t.target.nodeName)
            }, e._onProgress = function(t) {
                t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total)
            }, e._onTimeout = function() {
                this.abort("Load timed out.")
            }, e._xhrOnError = function() {
                var t = this.xhr;
                this.abort(_(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"')
            }, e._xhrOnTimeout = function() {
                var t = this.xhr;
                this.abort(_(t) + " Request timed out.")
            }, e._xhrOnAbort = function() {
                var t = this.xhr;
                this.abort(_(t) + " Request was aborted by the user.")
            }, e._xhrOnLoad = function() {
                var e = this.xhr,
                    n = "",
                    i = void 0 === e.status ? 200 : e.status;
                if ("" !== e.responseType && "text" !== e.responseType && void 0 !== e.responseType || (n = e.responseText), 0 === i && (n.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER) ? i = 200 : 1223 === i && (i = 204), 2 === (i / 100 | 0)) {
                    if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT) this.data = n, this.type = t.TYPE.TEXT;
                    else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON) try {
                        this.data = JSON.parse(n), this.type = t.TYPE.JSON
                    } catch (t) {
                        return void this.abort("Error trying to parse loaded json: " + t)
                    } else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT) try {
                        if (window.DOMParser) {
                            var r = new DOMParser;
                            this.data = r.parseFromString(n, "text/xml")
                        } else {
                            var o = document.createElement("div");
                            o.innerHTML = n, this.data = o
                        }
                        this.type = t.TYPE.XML
                    } catch (t) {
                        return void this.abort("Error trying to parse loaded xml: " + t)
                    } else this.data = e.response || n;
                    this.complete()
                } else this.abort("[" + e.status + "] " + e.statusText + ": " + e.responseURL)
            }, e._determineCrossOrigin = function(t, e) {
                if (0 === t.indexOf("data:")) return "";
                if (window.origin !== window.location.origin) return "anonymous";
                e = e || window.location, m || (m = document.createElement("a")), m.href = t;
                var n = !(t = r(m.href, {
                        strictMode: !0
                    })).port && "" === e.port || t.port === e.port,
                    i = t.protocol ? t.protocol + ":" : "";
                return t.host === e.hostname && n && i === e.protocol ? "" : "anonymous"
            }, e._determineXhrType = function() {
                return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT
            }, e._determineLoadType = function() {
                return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR
            }, e._getExtension = function() {
                var t = this.url,
                    e = "";
                if (this.isDataUrl) {
                    var n = t.indexOf("/");
                    e = t.substring(n + 1, t.indexOf(";", n))
                } else {
                    var i = t.indexOf("?"),
                        r = t.indexOf("#"),
                        o = Math.min(i > -1 ? i : t.length, r > -1 ? r : t.length);
                    e = (t = t.substring(0, o)).substring(t.lastIndexOf(".") + 1)
                }
                return e.toLowerCase()
            }, e._getMimeFromXhrType = function(e) {
                switch (e) {
                    case t.XHR_RESPONSE_TYPE.BUFFER:
                        return "application/octet-binary";
                    case t.XHR_RESPONSE_TYPE.BLOB:
                        return "application/blob";
                    case t.XHR_RESPONSE_TYPE.DOCUMENT:
                        return "application/xml";
                    case t.XHR_RESPONSE_TYPE.JSON:
                        return "application/json";
                    case t.XHR_RESPONSE_TYPE.DEFAULT:
                    case t.XHR_RESPONSE_TYPE.TEXT:
                    default:
                        return "text/plain"
                }
            }, d(t, [{
                key: "isDataUrl",
                get: function() {
                    return this._hasFlag(t.STATUS_FLAGS.DATA_URL)
                }
            }, {
                key: "isComplete",
                get: function() {
                    return this._hasFlag(t.STATUS_FLAGS.COMPLETE)
                }
            }, {
                key: "isLoading",
                get: function() {
                    return this._hasFlag(t.STATUS_FLAGS.LOADING)
                }
            }]), t
        }();

        function y(t, e, n) {
            e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = n)
        }

        function _(t) {
            return t.toString().replace("object ", "")
        }
        g.STATUS_FLAGS = {
            NONE: 0,
            DATA_URL: 1,
            COMPLETE: 2,
            LOADING: 4
        }, g.TYPE = {
            UNKNOWN: 0,
            JSON: 1,
            XML: 2,
            IMAGE: 3,
            AUDIO: 4,
            VIDEO: 5,
            TEXT: 6
        }, g.LOAD_TYPE = {
            XHR: 1,
            IMAGE: 2,
            AUDIO: 3,
            VIDEO: 4
        }, g.XHR_RESPONSE_TYPE = {
            DEFAULT: "text",
            BUFFER: "arraybuffer",
            BLOB: "blob",
            DOCUMENT: "document",
            JSON: "json",
            TEXT: "text"
        }, g._loadTypeMap = {
            gif: g.LOAD_TYPE.IMAGE,
            png: g.LOAD_TYPE.IMAGE,
            bmp: g.LOAD_TYPE.IMAGE,
            jpg: g.LOAD_TYPE.IMAGE,
            jpeg: g.LOAD_TYPE.IMAGE,
            tif: g.LOAD_TYPE.IMAGE,
            tiff: g.LOAD_TYPE.IMAGE,
            webp: g.LOAD_TYPE.IMAGE,
            tga: g.LOAD_TYPE.IMAGE,
            svg: g.LOAD_TYPE.IMAGE,
            "svg+xml": g.LOAD_TYPE.IMAGE,
            mp3: g.LOAD_TYPE.AUDIO,
            ogg: g.LOAD_TYPE.AUDIO,
            wav: g.LOAD_TYPE.AUDIO,
            mp4: g.LOAD_TYPE.VIDEO,
            webm: g.LOAD_TYPE.VIDEO
        }, g._xhrTypeMap = {
            xhtml: g.XHR_RESPONSE_TYPE.DOCUMENT,
            html: g.XHR_RESPONSE_TYPE.DOCUMENT,
            htm: g.XHR_RESPONSE_TYPE.DOCUMENT,
            xml: g.XHR_RESPONSE_TYPE.DOCUMENT,
            tmx: g.XHR_RESPONSE_TYPE.DOCUMENT,
            svg: g.XHR_RESPONSE_TYPE.DOCUMENT,
            tsx: g.XHR_RESPONSE_TYPE.DOCUMENT,
            gif: g.XHR_RESPONSE_TYPE.BLOB,
            png: g.XHR_RESPONSE_TYPE.BLOB,
            bmp: g.XHR_RESPONSE_TYPE.BLOB,
            jpg: g.XHR_RESPONSE_TYPE.BLOB,
            jpeg: g.XHR_RESPONSE_TYPE.BLOB,
            tif: g.XHR_RESPONSE_TYPE.BLOB,
            tiff: g.XHR_RESPONSE_TYPE.BLOB,
            webp: g.XHR_RESPONSE_TYPE.BLOB,
            tga: g.XHR_RESPONSE_TYPE.BLOB,
            json: g.XHR_RESPONSE_TYPE.JSON,
            text: g.XHR_RESPONSE_TYPE.TEXT,
            txt: g.XHR_RESPONSE_TYPE.TEXT,
            ttf: g.XHR_RESPONSE_TYPE.BUFFER,
            otf: g.XHR_RESPONSE_TYPE.BUFFER
        }, g.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
        var x = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

        function b(t) {
            for (var e = "", n = 0; n < t.length;) {
                for (var i = [0, 0, 0], r = [0, 0, 0, 0], o = 0; o < i.length; ++o) n < t.length ? i[o] = 255 & t.charCodeAt(n++) : i[o] = 0;
                switch (r[0] = i[0] >> 2, r[1] = (3 & i[0]) << 4 | i[1] >> 4, r[2] = (15 & i[1]) << 2 | i[2] >> 6, r[3] = 63 & i[2], n - (t.length - 1)) {
                    case 2:
                        r[3] = 64, r[2] = 64;
                        break;
                    case 1:
                        r[3] = 64
                }
                for (var a = 0; a < r.length; ++a) e += x.charAt(r[a])
            }
            return e
        }
        var w = window.URL || window.webkitURL;
        var M = {
                caching: function(t, e) {
                    var n = this;
                    u[t.url] ? (t.data = u[t.url], t.complete()) : t.onComplete.once(function() {
                        return u[n.url] = n.data
                    }), e()
                },
                parsing: function(t, e) {
                    if (t.data) {
                        if (t.xhr && t.xhrType === g.XHR_RESPONSE_TYPE.BLOB)
                            if (window.Blob && "string" != typeof t.data) {
                                if (0 === t.data.type.indexOf("image")) {
                                    var n = w.createObjectURL(t.data);
                                    return t.blob = t.data, t.data = new Image, t.data.src = n, t.type = g.TYPE.IMAGE, void(t.data.onload = function() {
                                        w.revokeObjectURL(n), t.data.onload = null, e()
                                    })
                                }
                            } else {
                                var i = t.xhr.getResponseHeader("content-type");
                                if (i && 0 === i.indexOf("image")) return t.data = new Image, t.data.src = "data:" + i + ";base64," + b(t.xhr.responseText), t.type = g.TYPE.IMAGE, void(t.data.onload = function() {
                                    t.data.onload = null, e()
                                })
                            }
                        e()
                    } else e()
                }
            },
            T = /(#[\w-]+)?$/,
            E = function() {
                function t(e, n) {
                    var i = this;
                    void 0 === e && (e = ""), void 0 === n && (n = 10), this.baseUrl = e, this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t, e) {
                        return i._loadResource(t, e)
                    }, this._queue = l(this._boundLoadResource, n), this._queue.pause(), this.resources = {}, this.onProgress = new o, this.onError = new o, this.onLoad = new o, this.onStart = new o, this.onComplete = new o;
                    for (var r = 0; r < t._defaultBeforeMiddleware.length; ++r) this.pre(t._defaultBeforeMiddleware[r]);
                    for (var a = 0; a < t._defaultAfterMiddleware.length; ++a) this.use(t._defaultAfterMiddleware[a])
                }
                var e = t.prototype;
                return e.add = function(t, e, n, i) {
                    if (Array.isArray(t)) {
                        for (var r = 0; r < t.length; ++r) this.add(t[r]);
                        return this
                    }
                    if ("object" == typeof t && (i = e || t.callback || t.onComplete, n = t, e = t.url, t = t.name || t.key || t.url), "string" != typeof e && (i = n, n = e, e = t), "string" != typeof e) throw new Error("No url passed to add resource to loader.");
                    if ("function" == typeof n && (i = n, n = null), this.loading && (!n || !n.parentResource)) throw new Error("Cannot add resources while the loader is running.");
                    if (this.resources[t]) throw new Error('Resource named "' + t + '" already exists.');
                    if (e = this._prepareUrl(e), this.resources[t] = new g(t, e, n), "function" == typeof i && this.resources[t].onAfterMiddleware.once(i), this.loading) {
                        for (var o = n.parentResource, a = [], s = 0; s < o.children.length; ++s) o.children[s].isComplete || a.push(o.children[s]);
                        var c = o.progressChunk * (a.length + 1) / (a.length + 2);
                        o.children.push(this.resources[t]), o.progressChunk = c;
                        for (var l = 0; l < a.length; ++l) a[l].progressChunk = c;
                        this.resources[t].progressChunk = c
                    }
                    return this._queue.push(this.resources[t]), this
                }, e.pre = function(t) {
                    return this._beforeMiddleware.push(t), this
                }, e.use = function(t) {
                    return this._afterMiddleware.push(t), this
                }, e.reset = function() {
                    for (var t in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) {
                        var e = this.resources[t];
                        e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort()
                    }
                    return this.resources = {}, this
                }, e.load = function(t) {
                    if ("function" == typeof t && this.onComplete.once(t), this.loading) return this;
                    if (this._queue.idle()) this._onStart(), this._onComplete();
                    else {
                        for (var e = 100 / this._queue._tasks.length, n = 0; n < this._queue._tasks.length; ++n) this._queue._tasks[n].data.progressChunk = e;
                        this._onStart(), this._queue.resume()
                    }
                    return this
                }, e._prepareUrl = function(t) {
                    var e, n = r(t, {
                        strictMode: !0
                    });
                    if (e = n.protocol || !n.path || 0 === t.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t, this.defaultQueryString) {
                        var i = T.exec(e)[0]; - 1 !== (e = e.substr(0, e.length - i.length)).indexOf("?") ? e += "&" + this.defaultQueryString : e += "?" + this.defaultQueryString, e += i
                    }
                    return e
                }, e._loadResource = function(t, e) {
                    var n = this;
                    t._dequeue = e, s(this._beforeMiddleware, function(e, i) {
                        e.call(n, t, function() {
                            i(t.isComplete ? {} : null)
                        })
                    }, function() {
                        t.isComplete ? n._onLoad(t) : (t._onLoadBinding = t.onComplete.once(n._onLoad, n), t.load())
                    }, !0)
                }, e._onStart = function() {
                    this.progress = 0, this.loading = !0, this.onStart.dispatch(this)
                }, e._onComplete = function() {
                    this.progress = 100, this.loading = !1, this.onComplete.dispatch(this, this.resources)
                }, e._onLoad = function(t) {
                    var e = this;
                    t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), s(this._afterMiddleware, function(n, i) {
                        n.call(e, t, i)
                    }, function() {
                        t.onAfterMiddleware.dispatch(t), e.progress = Math.min(100, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && 0 === e._resourcesParsing.length && e._onComplete()
                    }, !0)
                }, d(t, [{
                    key: "concurrency",
                    get: function() {
                        return this._queue.concurrency
                    },
                    set: function(t) {
                        this._queue.concurrency = t
                    }
                }]), t
            }();
        E._defaultBeforeMiddleware = [], E._defaultAfterMiddleware = [], E.pre = function(t) {
            return E._defaultBeforeMiddleware.push(t), E
        }, E.use = function(t) {
            return E._defaultAfterMiddleware.push(t), E
        }, e.Loader = E, e.Resource = g, e.async = h, e.encodeBinary = b, e.middleware = M
    }, function(t, e) {
        var n = 9007199254740991;
        t.exports = function(t) {
            return "number" == typeof t && t > -1 && t % 1 == 0 && t <= n
        }
    }, function(t, e, n) {
        var i = n(79),
            r = n(78),
            o = n(77),
            a = o && o.isTypedArray,
            s = a ? r(a) : i;
        t.exports = s
    }, function(t, e) {
        t.exports = function(t) {
            return t.webpackPolyfill || (t.deprecate = function() {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
                enumerable: !0,
                get: function() {
                    return t.l
                }
            }), Object.defineProperty(t, "id", {
                enumerable: !0,
                get: function() {
                    return t.i
                }
            }), t.webpackPolyfill = 1), t
        }
    }, function(t, e, n) {
        (function(t) {
            var i = n(14),
                r = n(81),
                o = "object" == typeof e && e && !e.nodeType && e,
                a = o && "object" == typeof t && t && !t.nodeType && t,
                s = a && a.exports === o ? i.Buffer : void 0,
                c = (s ? s.isBuffer : void 0) || r;
            t.exports = c
        }).call(this, n(37)(t))
    }, function(t, e, n) {
        var i = n(102),
            r = n(99),
            o = n(98),
            a = 1,
            s = 2;
        t.exports = function(t, e, n, c, l, h) {
            var u = n & a,
                p = t.length,
                d = e.length;
            if (p != d && !(u && d > p)) return !1;
            var f = h.get(t);
            if (f && h.get(e)) return f == e;
            var m = -1,
                v = !0,
                g = n & s ? new i : void 0;
            for (h.set(t, e), h.set(e, t); ++m < p;) {
                var y = t[m],
                    _ = e[m];
                if (c) var x = u ? c(_, y, m, e, t, h) : c(y, _, m, t, e, h);
                if (void 0 !== x) {
                    if (x) continue;
                    v = !1;
                    break
                }
                if (g) {
                    if (!r(e, function(t, e) {
                            if (!o(g, e) && (y === t || l(y, t, n, c, h))) return g.push(e)
                        })) {
                        v = !1;
                        break
                    }
                } else if (y !== _ && !l(y, _, n, c, h)) {
                    v = !1;
                    break
                }
            }
            return h.delete(t), h.delete(e), v
        }
    }, function(t, e, n) {
        var i = n(114),
            r = n(107),
            o = n(105),
            a = n(104),
            s = n(103);

        function c(t) {
            var e = -1,
                n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }
        c.prototype.clear = i, c.prototype.delete = r, c.prototype.get = o, c.prototype.has = a, c.prototype.set = s, t.exports = c
    }, function(t, e) {
        var n = Function.prototype.toString;
        t.exports = function(t) {
            if (null != t) {
                try {
                    return n.call(t)
                } catch (t) {}
                try {
                    return t + ""
                } catch (t) {}
            }
            return ""
        }
    }, function(t, e) {
        t.exports = function(t) {
            var e = typeof t;
            return null != t && ("object" == e || "function" == e)
        }
    }, function(t, e, n) {
        (function(e) {
            var n = "object" == typeof e && e && e.Object === Object && e;
            t.exports = n
        }).call(this, n(27))
    }, function(t, e, n) {
        var i = n(24),
            r = n(42),
            o = "[object AsyncFunction]",
            a = "[object Function]",
            s = "[object GeneratorFunction]",
            c = "[object Proxy]";
        t.exports = function(t) {
            if (!r(t)) return !1;
            var e = i(t);
            return e == a || e == s || e == o || e == c
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            return t === e || t != t && e != e
        }
    }, , , function(t, e, n) {
        var i = n(133);
        t.exports = function(t, e) {
            return i(t, e)
        }
    }, function(t, e, n) {
        t.exports = function(t) {
            "use strict";

            function e(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }

            function n(t) {
                return (n = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
            }

            function i(t, e) {
                return (i = Object.setPrototypeOf || function(t, e) {
                    return t.__proto__ = e, t
                })(t, e)
            }

            function r(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }
            return function(o) {
                function a(e, i) {
                    var o;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, a), (o = function(t, e) {
                        return !e || "object" != typeof e && "function" != typeof e ? r(t) : e
                    }(this, n(a).call(this))).object = e, o.domElement = void 0 !== i ? i : document, o.enabled = !0, o.target = new t.Vector3, o.minDistance = 0, o.maxDistance = 1 / 0, o.minZoom = 0, o.maxZoom = 1 / 0, o.minPolarAngle = 0, o.maxPolarAngle = Math.PI, o.minAzimuthAngle = -1 / 0, o.maxAzimuthAngle = 1 / 0, o.enableDamping = !1, o.dampingFactor = .25, o.enableZoom = !0, o.zoomSpeed = 1, o.enableRotate = !0, o.rotateSpeed = 1, o.enablePan = !0, o.keyPanSpeed = 7, o.autoRotate = !1, o.autoRotateSpeed = 2, o.enableKeys = !0, o.keys = {
                        LEFT: 37,
                        UP: 38,
                        RIGHT: 39,
                        BOTTOM: 40
                    }, o.mouseButtons = {
                        ORBIT: t.MOUSE.LEFT,
                        ZOOM: t.MOUSE.MIDDLE,
                        PAN: t.MOUSE.RIGHT
                    }, o.target0 = o.target.clone(), o.position0 = o.object.position.clone(), o.zoom0 = o.object.zoom, o.getPolarAngle = function() {
                        return f.phi
                    }, o.getAzimuthalAngle = function() {
                        return f.theta
                    }, o.reset = function() {
                        s.target.copy(s.target0), s.object.position.copy(s.position0), s.object.zoom = s.zoom0, s.object.updateProjectionMatrix(), s.dispatchEvent(c), s.update(), p = u.NONE
                    }, o.update = function() {
                        var n = new t.Vector3,
                            i = (new t.Quaternion).setFromUnitVectors(e.up, new t.Vector3(0, 1, 0)),
                            r = i.clone().inverse(),
                            o = new t.Vector3,
                            a = new t.Quaternion;
                        return function() {
                            var t = s.object.position;
                            return n.copy(t).sub(s.target), n.applyQuaternion(i), f.setFromVector3(n), s.autoRotate && p === u.NONE && L(2 * Math.PI / 60 / 60 * s.autoRotateSpeed), f.theta += m.theta, f.phi += m.phi, f.theta = Math.max(s.minAzimuthAngle, Math.min(s.maxAzimuthAngle, f.theta)), f.phi = Math.max(s.minPolarAngle, Math.min(s.maxPolarAngle, f.phi)), f.makeSafe(), f.radius *= v, f.radius = Math.max(s.minDistance, Math.min(s.maxDistance, f.radius)), s.target.add(g), n.setFromSpherical(f), n.applyQuaternion(r), t.copy(s.target).add(n), s.object.lookAt(s.target), !0 === s.enableDamping ? (m.theta *= 1 - s.dampingFactor, m.phi *= 1 - s.dampingFactor) : m.set(0, 0, 0), v = 1, g.set(0, 0, 0), !!(y || o.distanceToSquared(s.object.position) > d || 8 * (1 - a.dot(s.object.quaternion)) > d) && (s.dispatchEvent(c), o.copy(s.object.position), a.copy(s.object.quaternion), y = !1, !0)
                        }
                    }(), o.dispose = function() {
                        s.domElement.removeEventListener("contextmenu", V, !1), s.domElement.removeEventListener("mousedown", B, !1), s.domElement.removeEventListener("wheel", k, !1), s.domElement.removeEventListener("touchstart", z, !1), s.domElement.removeEventListener("touchend", j, !1), s.domElement.removeEventListener("touchmove", G, !1), document.removeEventListener("mousemove", H, !1), document.removeEventListener("mouseup", F, !1), window.removeEventListener("keydown", U, !1)
                    };
                    var s = r(r(o)),
                        c = {
                            type: "change"
                        },
                        l = {
                            type: "start"
                        },
                        h = {
                            type: "end"
                        },
                        u = {
                            NONE: -1,
                            ROTATE: 0,
                            DOLLY: 1,
                            PAN: 2,
                            TOUCH_ROTATE: 3,
                            TOUCH_DOLLY: 4,
                            TOUCH_PAN: 5
                        },
                        p = u.NONE,
                        d = 1e-6,
                        f = new t.Spherical,
                        m = new t.Spherical,
                        v = 1,
                        g = new t.Vector3,
                        y = !1,
                        _ = new t.Vector2,
                        x = new t.Vector2,
                        b = new t.Vector2,
                        w = new t.Vector2,
                        M = new t.Vector2,
                        T = new t.Vector2,
                        E = new t.Vector2,
                        S = new t.Vector2,
                        A = new t.Vector2;

                    function P() {
                        return Math.pow(.95, s.zoomSpeed)
                    }

                    function L(t) {
                        m.theta -= t
                    }

                    function R(t) {
                        m.phi -= t
                    }
                    var C = function() {
                            var e = new t.Vector3;
                            return function(t, n) {
                                e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), g.add(e)
                            }
                        }(),
                        O = function() {
                            var e = new t.Vector3;
                            return function(t, n) {
                                e.setFromMatrixColumn(n, 1), e.multiplyScalar(t), g.add(e)
                            }
                        }(),
                        I = function() {
                            var e = new t.Vector3;
                            return function(t, n) {
                                var i = s.domElement === document ? s.domElement.body : s.domElement;
                                if (Object.getPrototypeOf(s.object).isPerspectiveCamera) {
                                    var r = s.object.position;
                                    e.copy(r).sub(s.target);
                                    var o = e.length();
                                    o *= Math.tan(s.object.fov / 2 * Math.PI / 180), C(2 * t * o / i.clientHeight, s.object.matrix), O(2 * n * o / i.clientHeight, s.object.matrix)
                                } else Object.getPrototypeOf(s.object).isOrthographicCamera ? (C(t * (s.object.right - s.object.left) / s.object.zoom / i.clientWidth, s.object.matrix), O(n * (s.object.top - s.object.bottom) / s.object.zoom / i.clientHeight, s.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), s.enablePan = !1)
                            }
                        }();

                    function D(t) {
                        Object.getPrototypeOf(s.object).isPerspectiveCamera ? v /= t : Object.getPrototypeOf(s.object).isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom * t)), s.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1)
                    }

                    function N(t) {
                        Object.getPrototypeOf(s.object).isPerspectiveCamera ? v *= t : Object.getPrototypeOf(s.object).isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom / t)), s.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1)
                    }

                    function B(t) {
                        if (!1 !== s.enabled) {
                            if (t.preventDefault(), t.button === s.mouseButtons.ORBIT) {
                                if (!1 === s.enableRotate) return;
                                ! function(t) {
                                    _.set(t.clientX, t.clientY)
                                }(t), p = u.ROTATE
                            } else if (t.button === s.mouseButtons.ZOOM) {
                                if (!1 === s.enableZoom) return;
                                ! function(t) {
                                    E.set(t.clientX, t.clientY)
                                }(t), p = u.DOLLY
                            } else if (t.button === s.mouseButtons.PAN) {
                                if (!1 === s.enablePan) return;
                                ! function(t) {
                                    w.set(t.clientX, t.clientY)
                                }(t), p = u.PAN
                            }
                            p !== u.NONE && (document.addEventListener("mousemove", H, !1), document.addEventListener("mouseup", F, !1), s.dispatchEvent(l))
                        }
                    }

                    function H(t) {
                        if (!1 !== s.enabled)
                            if (t.preventDefault(), p === u.ROTATE) {
                                if (!1 === s.enableRotate) return;
                                ! function(t) {
                                    x.set(t.clientX, t.clientY), b.subVectors(x, _);
                                    var e = s.domElement === document ? s.domElement.body : s.domElement;
                                    L(2 * Math.PI * b.x / e.clientWidth * s.rotateSpeed), R(2 * Math.PI * b.y / e.clientHeight * s.rotateSpeed), _.copy(x), s.update()
                                }(t)
                            } else if (p === u.DOLLY) {
                            if (!1 === s.enableZoom) return;
                            ! function(t) {
                                S.set(t.clientX, t.clientY), A.subVectors(S, E), A.y > 0 ? D(P()) : A.y < 0 && N(P()), E.copy(S), s.update()
                            }(t)
                        } else if (p === u.PAN) {
                            if (!1 === s.enablePan) return;
                            ! function(t) {
                                M.set(t.clientX, t.clientY), T.subVectors(M, w), I(T.x, T.y), w.copy(M), s.update()
                            }(t)
                        }
                    }

                    function F(t) {
                        !1 !== s.enabled && (document.removeEventListener("mousemove", H, !1), document.removeEventListener("mouseup", F, !1), s.dispatchEvent(h), p = u.NONE)
                    }

                    function k(t) {
                        !1 === s.enabled || !1 === s.enableZoom || p !== u.NONE && p !== u.ROTATE || (t.preventDefault(), t.stopPropagation(), function(t) {
                            t.deltaY < 0 ? N(P()) : t.deltaY > 0 && D(P()), s.update()
                        }(t), s.dispatchEvent(l), s.dispatchEvent(h))
                    }

                    function U(t) {
                        !1 !== s.enabled && !1 !== s.enableKeys && !1 !== s.enablePan && function(t) {
                            switch (t.keyCode) {
                                case s.keys.UP:
                                    I(0, s.keyPanSpeed), s.update();
                                    break;
                                case s.keys.BOTTOM:
                                    I(0, -s.keyPanSpeed), s.update();
                                    break;
                                case s.keys.LEFT:
                                    I(s.keyPanSpeed, 0), s.update();
                                    break;
                                case s.keys.RIGHT:
                                    I(-s.keyPanSpeed, 0), s.update()
                            }
                        }(t)
                    }

                    function z(t) {
                        if (!1 !== s.enabled) {
                            switch (t.touches.length) {
                                case 1:
                                    if (!1 === s.enableRotate) return;
                                    ! function(t) {
                                        _.set(t.touches[0].pageX, t.touches[0].pageY)
                                    }(t), p = u.TOUCH_ROTATE;
                                    break;
                                case 2:
                                    if (!1 === s.enableZoom) return;
                                    ! function(t) {
                                        var e = t.touches[0].pageX - t.touches[1].pageX,
                                            n = t.touches[0].pageY - t.touches[1].pageY,
                                            i = Math.sqrt(e * e + n * n);
                                        E.set(0, i)
                                    }(t), p = u.TOUCH_DOLLY;
                                    break;
                                case 3:
                                    if (!1 === s.enablePan) return;
                                    ! function(t) {
                                        w.set(t.touches[0].pageX, t.touches[0].pageY)
                                    }(t), p = u.TOUCH_PAN;
                                    break;
                                default:
                                    p = u.NONE
                            }
                            p !== u.NONE && s.dispatchEvent(l)
                        }
                    }

                    function G(t) {
                        if (!1 !== s.enabled) switch (t.preventDefault(), t.stopPropagation(), t.touches.length) {
                            case 1:
                                if (!1 === s.enableRotate) return;
                                if (p !== u.TOUCH_ROTATE) return;
                                ! function(t) {
                                    x.set(t.touches[0].pageX, t.touches[0].pageY), b.subVectors(x, _);
                                    var e = s.domElement === document ? s.domElement.body : s.domElement;
                                    L(2 * Math.PI * b.x / e.clientWidth * s.rotateSpeed), R(2 * Math.PI * b.y / e.clientHeight * s.rotateSpeed), _.copy(x), s.update()
                                }(t);
                                break;
                            case 2:
                                if (!1 === s.enableZoom) return;
                                if (p !== u.TOUCH_DOLLY) return;
                                ! function(t) {
                                    var e = t.touches[0].pageX - t.touches[1].pageX,
                                        n = t.touches[0].pageY - t.touches[1].pageY,
                                        i = Math.sqrt(e * e + n * n);
                                    S.set(0, i), A.subVectors(S, E), A.y > 0 ? N(P()) : A.y < 0 && D(P()), E.copy(S), s.update()
                                }(t);
                                break;
                            case 3:
                                if (!1 === s.enablePan) return;
                                if (p !== u.TOUCH_PAN) return;
                                ! function(t) {
                                    M.set(t.touches[0].pageX, t.touches[0].pageY), T.subVectors(M, w), I(T.x, T.y), w.copy(M), s.update()
                                }(t);
                                break;
                            default:
                                p = u.NONE
                        }
                    }

                    function j(t) {
                        !1 !== s.enabled && (s.dispatchEvent(h), p = u.NONE)
                    }

                    function V(t) {
                        t.preventDefault()
                    }
                    return s.domElement.addEventListener("contextmenu", V, !1), s.domElement.addEventListener("mousedown", B, !1), s.domElement.addEventListener("wheel", k, !1), s.domElement.addEventListener("touchstart", z, !1), s.domElement.addEventListener("touchend", j, !1), s.domElement.addEventListener("touchmove", G, !1), window.addEventListener("keydown", U, !1), o.update(), o
                }
                return function(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && i(t, e)
                    }(a, o),
                    function(t, n, i) {
                        n && e(t.prototype, n), i && e(t, i)
                    }(a, [{
                        key: "center",
                        get: function() {
                            return console.warn("OrbitControls: .center has been renamed to .target"), this.target
                        }
                    }, {
                        key: "noZoom",
                        get: function() {
                            return console.warn("OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
                        },
                        set: function(t) {
                            console.warn("OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !t
                        }
                    }, {
                        key: "noRotate",
                        get: function() {
                            return console.warn("OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
                        },
                        set: function(t) {
                            console.warn("OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !t
                        }
                    }, {
                        key: "noPan",
                        get: function() {
                            return console.warn("OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
                        },
                        set: function(t) {
                            console.warn("OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !t
                        }
                    }, {
                        key: "noKeys",
                        get: function() {
                            return console.warn("OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
                        },
                        set: function(t) {
                            console.warn("OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !t
                        }
                    }, {
                        key: "staticMoving",
                        get: function() {
                            return console.warn("OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
                        },
                        set: function(t) {
                            console.warn("OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !t
                        }
                    }, {
                        key: "dynamicDampingFactor",
                        get: function() {
                            return console.warn("OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
                        },
                        set: function(t) {
                            console.warn("OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = t
                        }
                    }]), a
            }(t.EventDispatcher)
        }(n(165))
    }, function(t, e, n) {
        ! function(t) {
            "use strict";
            var e = function() {
                function t(t) {
                    this.cache = new Map, this.userAgent = t || (window && window.navigator ? window.navigator.userAgent : ""), this.android = !/like android/i.test(this.userAgent) && /android/i.test(this.userAgent), this.iOS = this.match(1, /(iphone|ipod|ipad)/i).toLowerCase()
                }
                return t.prototype.match = function(t, e) {
                    var n = this.userAgent.match(e);
                    return n && 1 < n.length && n[t] || ""
                }, Object.defineProperty(t.prototype, "isMobile", {
                    get: function() {
                        var t = this.cache.get("isMobile");
                        return t || (!this.isTablet && (/[^-]mobi/i.test(this.userAgent) || "iphone" === this.iOS || "ipod" === this.iOS || this.android || /nexus\s*[0-6]\s*/i.test(this.userAgent)) ? (this.cache.set("isMobile", !0), !0) : (this.cache.set("isMobile", !1), !1))
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "isTablet", {
                    get: function() {
                        var t = this.cache.get("isTablet");
                        return t || (/tablet/i.test(this.userAgent) && !/tablet pc/i.test(this.userAgent) || "ipad" === this.iOS || this.android && !/[^-]mobi/i.test(this.userAgent) || !/nexus\s*[0-6]\s*/i.test(this.userAgent) && /nexus\s*[0-9]+/i.test(this.userAgent) ? (this.cache.set("isTablet", !0), !0) : (this.cache.set("isTablet", !1), !1))
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "isDesktop", {
                    get: function() {
                        var t = this.cache.get("isDesktop");
                        if (t) return t;
                        var e = !this.isMobile && !this.isTablet;
                        return this.cache.set("isDesktop", e), e
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "isiOS", {
                    get: function() {
                        var t = this.cache.get("isiOS");
                        return t || !!this.iOS && {
                            name: "iOS",
                            version: this.match(1, /os (\d+([_\s]\d+)*) like mac os x/i).replace(/[_\s]/g, ".")
                        }
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "isAndroid", {
                    get: function() {
                        var t = this.cache.get("isAndroid");
                        return t || !!this.android && {
                            name: "Android",
                            version: this.match(1, /android[ \/-](\d+(\.\d+)*)/i)
                        }
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "browser", {
                    get: function() {
                        var t = this.cache.get("browser");
                        if (t) return t;
                        var e = this.match(1, /version\/(\d+(\.\d+)?)/i),
                            n = void 0;
                        return n = /opera/i.test(this.userAgent) ? {
                            name: "Opera",
                            version: e || this.match(1, /(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
                        } : /opr\/|opios/i.test(this.userAgent) ? {
                            name: "Opera",
                            version: this.match(1, /(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || e
                        } : /SamsungBrowser/i.test(this.userAgent) ? {
                            name: "Samsung Internet for Android",
                            version: e || this.match(1, /(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
                        } : /yabrowser/i.test(this.userAgent) ? {
                            name: "Yandex Browser",
                            version: e || this.match(1, /(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
                        } : /ucbrowser/i.test(this.userAgent) ? {
                            name: "UC Browser",
                            version: this.match(1, /(?:ucbrowser)[\s\/](\d+(\.\d+)?)/i)
                        } : /msie|trident/i.test(this.userAgent) ? {
                            name: "Internet Explorer",
                            version: this.match(1, /(?:msie |rv:)(\d+(\.\d+)?)/i)
                        } : /edg([ea]|ios)/i.test(this.userAgent) ? {
                            name: "Microsoft Edge",
                            version: this.match(2, /edg([ea]|ios)\/(\d+(\.\d+)?)/i)
                        } : /firefox|iceweasel|fxios/i.test(this.userAgent) ? {
                            name: "Firefox",
                            version: this.match(1, /(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
                        } : /chromium/i.test(this.userAgent) ? {
                            name: "Chromium",
                            version: this.match(1, /(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || e
                        } : /chrome|crios|crmo/i.test(this.userAgent) ? {
                            name: "Chrome",
                            version: this.match(1, /(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
                        } : /safari|applewebkit/i.test(this.userAgent) ? {
                            name: "Safari",
                            version: e
                        } : {
                            name: this.match(1, /^(.*)\/(.*) /),
                            version: this.match(2, /^(.*)\/(.*) /)
                        }, this.cache.set("browser", n), n
                    },
                    enumerable: !0,
                    configurable: !0
                }), t
            }();
            t.DetectUA = e, Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }(e)
    }, function(t, e, n) {
        var i;
        ! function() {
            function r(t, e, n) {
                return t.call.apply(t.bind, arguments)
            }

            function o(t, e, n) {
                if (!t) throw Error();
                if (2 < arguments.length) {
                    var i = Array.prototype.slice.call(arguments, 2);
                    return function() {
                        var n = Array.prototype.slice.call(arguments);
                        return Array.prototype.unshift.apply(n, i), t.apply(e, n)
                    }
                }
                return function() {
                    return t.apply(e, arguments)
                }
            }

            function a(t, e, n) {
                return (a = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? r : o).apply(null, arguments)
            }
            var s = Date.now || function() {
                return +new Date
            };
            var c = !!window.FontFace;

            function l(t, e, n, i) {
                if (e = t.c.createElement(e), n)
                    for (var r in n) n.hasOwnProperty(r) && ("style" == r ? e.style.cssText = n[r] : e.setAttribute(r, n[r]));
                return i && e.appendChild(t.c.createTextNode(i)), e
            }

            function h(t, e, n) {
                (t = t.c.getElementsByTagName(e)[0]) || (t = document.documentElement), t.insertBefore(n, t.lastChild)
            }

            function u(t) {
                t.parentNode && t.parentNode.removeChild(t)
            }

            function p(t, e, n) {
                e = e || [], n = n || [];
                for (var i = t.className.split(/\s+/), r = 0; r < e.length; r += 1) {
                    for (var o = !1, a = 0; a < i.length; a += 1)
                        if (e[r] === i[a]) {
                            o = !0;
                            break
                        }
                    o || i.push(e[r])
                }
                for (e = [], r = 0; r < i.length; r += 1) {
                    for (o = !1, a = 0; a < n.length; a += 1)
                        if (i[r] === n[a]) {
                            o = !0;
                            break
                        }
                    o || e.push(i[r])
                }
                t.className = e.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
            }

            function d(t, e) {
                for (var n = t.className.split(/\s+/), i = 0, r = n.length; i < r; i++)
                    if (n[i] == e) return !0;
                return !1
            }

            function f(t, e, n) {
                function i() {
                    s && r && o && (s(a), s = null)
                }
                e = l(t, "link", {
                    rel: "stylesheet",
                    href: e,
                    media: "all"
                });
                var r = !1,
                    o = !0,
                    a = null,
                    s = n || null;
                c ? (e.onload = function() {
                    r = !0, i()
                }, e.onerror = function() {
                    r = !0, a = Error("Stylesheet failed to load"), i()
                }) : setTimeout(function() {
                    r = !0, i()
                }, 0), h(t, "head", e)
            }

            function m(t, e, n, i) {
                var r = t.c.getElementsByTagName("head")[0];
                if (r) {
                    var o = l(t, "script", {
                            src: e
                        }),
                        a = !1;
                    return o.onload = o.onreadystatechange = function() {
                        a || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (a = !0, n && n(null), o.onload = o.onreadystatechange = null, "HEAD" == o.parentNode.tagName && r.removeChild(o))
                    }, r.appendChild(o), setTimeout(function() {
                        a || (a = !0, n && n(Error("Script load timeout")))
                    }, i || 5e3), o
                }
                return null
            }

            function v() {
                this.a = 0, this.c = null
            }

            function g(t) {
                return t.a++,
                    function() {
                        t.a--, _(t)
                    }
            }

            function y(t, e) {
                t.c = e, _(t)
            }

            function _(t) {
                0 == t.a && t.c && (t.c(), t.c = null)
            }

            function x(t) {
                this.a = t || "-"
            }

            function b(t, e) {
                this.c = t, this.f = 4, this.a = "n";
                var n = (e || "n4").match(/^([nio])([1-9])$/i);
                n && (this.a = n[1], this.f = parseInt(n[2], 10))
            }

            function w(t) {
                var e = [];
                t = t.split(/,\s*/);
                for (var n = 0; n < t.length; n++) {
                    var i = t[n].replace(/['"]/g, ""); - 1 != i.indexOf(" ") || /^\d/.test(i) ? e.push("'" + i + "'") : e.push(i)
                }
                return e.join(",")
            }

            function M(t) {
                return t.a + t.f
            }

            function T(t) {
                var e = "normal";
                return "o" === t.a ? e = "oblique" : "i" === t.a && (e = "italic"), e
            }

            function E(t) {
                var e = 4,
                    n = "n",
                    i = null;
                return t && ((i = t.match(/(normal|oblique|italic)/i)) && i[1] && (n = i[1].substr(0, 1).toLowerCase()), (i = t.match(/([1-9]00|normal|bold)/i)) && i[1] && (/bold/i.test(i[1]) ? e = 7 : /[1-9]00/.test(i[1]) && (e = parseInt(i[1].substr(0, 1), 10)))), n + e
            }

            function S(t) {
                if (t.g) {
                    var e = d(t.f, t.a.c("wf", "active")),
                        n = [],
                        i = [t.a.c("wf", "loading")];
                    e || n.push(t.a.c("wf", "inactive")), p(t.f, n, i)
                }
                A(t, "inactive")
            }

            function A(t, e, n) {
                t.j && t.h[e] && (n ? t.h[e](n.c, M(n)) : t.h[e]())
            }

            function P(t, e) {
                this.c = t, this.f = e, this.a = l(this.c, "span", {
                    "aria-hidden": "true"
                }, this.f)
            }

            function L(t) {
                h(t.c, "body", t.a)
            }

            function R(t) {
                return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + w(t.c) + ";font-style:" + T(t) + ";font-weight:" + t.f + "00;"
            }

            function C(t, e, n, i, r, o) {
                this.g = t, this.j = e, this.a = i, this.c = n, this.f = r || 3e3, this.h = o || void 0
            }

            function O(t, e, n, i, r, o, a) {
                this.v = t, this.B = e, this.c = n, this.a = i, this.s = a || "BESbswy", this.f = {}, this.w = r || 3e3, this.u = o || null, this.m = this.j = this.h = this.g = null, this.g = new P(this.c, this.s), this.h = new P(this.c, this.s), this.j = new P(this.c, this.s), this.m = new P(this.c, this.s), t = R(t = new b(this.a.c + ",serif", M(this.a))), this.g.a.style.cssText = t, t = R(t = new b(this.a.c + ",sans-serif", M(this.a))), this.h.a.style.cssText = t, t = R(t = new b("serif", M(this.a))), this.j.a.style.cssText = t, t = R(t = new b("sans-serif", M(this.a))), this.m.a.style.cssText = t, L(this.g), L(this.h), L(this.j), L(this.m)
            }
            x.prototype.c = function(t) {
                for (var e = [], n = 0; n < arguments.length; n++) e.push(arguments[n].replace(/[\W_]+/g, "").toLowerCase());
                return e.join(this.a)
            }, C.prototype.start = function() {
                var t = this.c.o.document,
                    e = this,
                    n = s(),
                    i = new Promise(function(i, r) {
                        ! function o() {
                            s() - n >= e.f ? r() : t.fonts.load(function(t) {
                                return T(t) + " " + t.f + "00 300px " + w(t.c)
                            }(e.a), e.h).then(function(t) {
                                1 <= t.length ? i() : setTimeout(o, 25)
                            }, function() {
                                r()
                            })
                        }()
                    }),
                    r = null,
                    o = new Promise(function(t, n) {
                        r = setTimeout(n, e.f)
                    });
                Promise.race([o, i]).then(function() {
                    r && (clearTimeout(r), r = null), e.g(e.a)
                }, function() {
                    e.j(e.a)
                })
            };
            var I = {
                    D: "serif",
                    C: "sans-serif"
                },
                D = null;

            function N() {
                if (null === D) {
                    var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                    D = !!t && (536 > parseInt(t[1], 10) || 536 === parseInt(t[1], 10) && 11 >= parseInt(t[2], 10))
                }
                return D
            }

            function B(t, e, n) {
                for (var i in I)
                    if (I.hasOwnProperty(i) && e === t.f[I[i]] && n === t.f[I[i]]) return !0;
                return !1
            }

            function H(t) {
                var e, n = t.g.a.offsetWidth,
                    i = t.h.a.offsetWidth;
                (e = n === t.f.serif && i === t.f["sans-serif"]) || (e = N() && B(t, n, i)), e ? s() - t.A >= t.w ? N() && B(t, n, i) && (null === t.u || t.u.hasOwnProperty(t.a.c)) ? F(t, t.v) : F(t, t.B) : function(t) {
                    setTimeout(a(function() {
                        H(this)
                    }, t), 50)
                }(t) : F(t, t.v)
            }

            function F(t, e) {
                setTimeout(a(function() {
                    u(this.g.a), u(this.h.a), u(this.j.a), u(this.m.a), e(this.a)
                }, t), 0)
            }

            function k(t, e, n) {
                this.c = t, this.a = e, this.f = 0, this.m = this.j = !1, this.s = n
            }
            O.prototype.start = function() {
                this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = s(), H(this)
            };
            var U = null;

            function z(t) {
                0 == --t.f && t.j && (t.m ? ((t = t.a).g && p(t.f, [t.a.c("wf", "active")], [t.a.c("wf", "loading"), t.a.c("wf", "inactive")]), A(t, "active")) : S(t.a))
            }

            function G(t) {
                this.j = t, this.a = new function() {
                    this.c = {}
                }, this.h = 0, this.f = this.g = !0
            }

            function j(t, e, n, i, r) {
                var o = 0 == --t.h;
                (t.f || t.g) && setTimeout(function() {
                    var t = r || null,
                        s = i || {};
                    if (0 === n.length && o) S(e.a);
                    else {
                        e.f += n.length, o && (e.j = o);
                        var c, l = [];
                        for (c = 0; c < n.length; c++) {
                            var h = n[c],
                                u = s[h.c],
                                d = e.a,
                                f = h;
                            if (d.g && p(d.f, [d.a.c("wf", f.c, M(f).toString(), "loading")]), A(d, "fontloading", f), d = null, null === U)
                                if (window.FontFace) {
                                    f = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent);
                                    var m = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                    U = f ? 42 < parseInt(f[1], 10) : !m
                                } else U = !1;
                            d = U ? new C(a(e.g, e), a(e.h, e), e.c, h, e.s, u) : new O(a(e.g, e), a(e.h, e), e.c, h, e.s, t, u), l.push(d)
                        }
                        for (c = 0; c < l.length; c++) l[c].start()
                    }
                }, 0)
            }

            function V(t, e) {
                this.c = t, this.a = e
            }

            function W(t, e) {
                this.c = t, this.a = e
            }
            k.prototype.g = function(t) {
                var e = this.a;
                e.g && p(e.f, [e.a.c("wf", t.c, M(t).toString(), "active")], [e.a.c("wf", t.c, M(t).toString(), "loading"), e.a.c("wf", t.c, M(t).toString(), "inactive")]), A(e, "fontactive", t), this.m = !0, z(this)
            }, k.prototype.h = function(t) {
                var e = this.a;
                if (e.g) {
                    var n = d(e.f, e.a.c("wf", t.c, M(t).toString(), "active")),
                        i = [],
                        r = [e.a.c("wf", t.c, M(t).toString(), "loading")];
                    n || i.push(e.a.c("wf", t.c, M(t).toString(), "inactive")), p(e.f, i, r)
                }
                A(e, "fontinactive", t), z(this)
            }, G.prototype.load = function(t) {
                this.c = new function(t, e) {
                        this.a = t, this.o = e || t, this.c = this.o.document
                    }(this.j, t.context || this.j), this.g = !1 !== t.events, this.f = !1 !== t.classes,
                    function(t, e, n) {
                        var i = [],
                            r = n.timeout;
                        ! function(t) {
                            t.g && p(t.f, [t.a.c("wf", "loading")]), A(t, "loading")
                        }(e);
                        var i = function(t, e, n) {
                                var i, r = [];
                                for (i in e)
                                    if (e.hasOwnProperty(i)) {
                                        var o = t.c[i];
                                        o && r.push(o(e[i], n))
                                    }
                                return r
                            }(t.a, n, t.c),
                            o = new k(t.c, e, r);
                        for (t.h = i.length, e = 0, n = i.length; e < n; e++) i[e].load(function(e, n, i) {
                            j(t, o, e, n, i)
                        })
                    }(this, new function(t, e) {
                        this.c = t, this.f = t.o.document.documentElement, this.h = e, this.a = new x("-"), this.j = !1 !== e.events, this.g = !1 !== e.classes
                    }(this.c, t), t)
            }, V.prototype.load = function(t) {
                var e = this,
                    n = e.a.projectId,
                    i = e.a.version;
                if (n) {
                    var r = e.c.o;
                    m(this.c, (e.a.api || "https://fast.fonts.net/jsapi") + "/" + n + ".js" + (i ? "?v=" + i : ""), function(i) {
                        i ? t([]) : (r["__MonotypeConfiguration__" + n] = function() {
                            return e.a
                        }, function e() {
                            if (r["__mti_fntLst" + n]) {
                                var i, o = r["__mti_fntLst" + n](),
                                    a = [];
                                if (o)
                                    for (var s = 0; s < o.length; s++) {
                                        var c = o[s].fontfamily;
                                        void 0 != o[s].fontStyle && void 0 != o[s].fontWeight ? (i = o[s].fontStyle + o[s].fontWeight, a.push(new b(c, i))) : a.push(new b(c))
                                    }
                                t(a)
                            } else setTimeout(function() {
                                e()
                            }, 50)
                        }())
                    }).id = "__MonotypeAPIScript__" + n
                } else t([])
            }, W.prototype.load = function(t) {
                var e, n, i = this.a.urls || [],
                    r = this.a.families || [],
                    o = this.a.testStrings || {},
                    a = new v;
                for (e = 0, n = i.length; e < n; e++) f(this.c, i[e], g(a));
                var s = [];
                for (e = 0, n = r.length; e < n; e++)
                    if ((i = r[e].split(":"))[1])
                        for (var c = i[1].split(","), l = 0; l < c.length; l += 1) s.push(new b(i[0], c[l]));
                    else s.push(new b(i[0]));
                y(a, function() {
                    t(s, o)
                })
            };
            var X = "https://fonts.googleapis.com/css";
            var q = {
                    latin: "BESbswy",
                    "latin-ext": "",
                    cyrillic: "",
                    greek: "",
                    khmer: "",
                    Hanuman: ""
                },
                Y = {
                    thin: "1",
                    extralight: "2",
                    "extra-light": "2",
                    ultralight: "2",
                    "ultra-light": "2",
                    light: "3",
                    regular: "4",
                    book: "4",
                    medium: "5",
                    "semi-bold": "6",
                    semibold: "6",
                    "demi-bold": "6",
                    demibold: "6",
                    bold: "7",
                    "extra-bold": "8",
                    extrabold: "8",
                    "ultra-bold": "8",
                    ultrabold: "8",
                    black: "9",
                    heavy: "9",
                    l: "3",
                    r: "4",
                    b: "7"
                },
                Z = {
                    i: "i",
                    italic: "i",
                    n: "n",
                    normal: "n"
                },
                J = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;

            function K(t, e) {
                this.c = t, this.a = e
            }
            var Q = {
                Arimo: !0,
                Cousine: !0,
                Tinos: !0
            };

            function $(t, e) {
                this.c = t, this.a = e
            }

            function tt(t, e) {
                this.c = t, this.f = e, this.a = []
            }
            K.prototype.load = function(t) {
                var e = new v,
                    n = this.c,
                    i = new function(t, e) {
                        this.c = t || X, this.a = [], this.f = [], this.g = e || ""
                    }(this.a.api, this.a.text),
                    r = this.a.families;
                ! function(t, e) {
                    for (var n = e.length, i = 0; i < n; i++) {
                        var r = e[i].split(":");
                        3 == r.length && t.f.push(r.pop());
                        var o = "";
                        2 == r.length && "" != r[1] && (o = ":"), t.a.push(r.join(o))
                    }
                }(i, r);
                var o = new function(t) {
                    this.f = t, this.a = [], this.c = {}
                }(r);
                ! function(t) {
                    for (var e = t.f.length, n = 0; n < e; n++) {
                        var i = t.f[n].split(":"),
                            r = i[0].replace(/\+/g, " "),
                            o = ["n4"];
                        if (2 <= i.length) {
                            var a;
                            if (a = [], s = i[1])
                                for (var s, c = (s = s.split(",")).length, l = 0; l < c; l++) {
                                    var h;
                                    if ((h = s[l]).match(/^[\w-]+$/))
                                        if (null == (p = J.exec(h.toLowerCase()))) h = "";
                                        else {
                                            if (h = null == (h = p[2]) || "" == h ? "n" : Z[h], null == (p = p[1]) || "" == p) p = "4";
                                            else var u = Y[p],
                                                p = u || (isNaN(p) ? "4" : p.substr(0, 1));
                                            h = [h, p].join("")
                                        }
                                    else h = "";
                                    h && a.push(h)
                                }
                            0 < a.length && (o = a), 3 == i.length && (a = [], 0 < (i = (i = i[2]) ? i.split(",") : a).length && (i = q[i[0]]) && (t.c[r] = i))
                        }
                        for (t.c[r] || (i = q[r]) && (t.c[r] = i), i = 0; i < o.length; i += 1) t.a.push(new b(r, o[i]))
                    }
                }(o), f(n, function(t) {
                    if (0 == t.a.length) throw Error("No fonts to load!");
                    if (-1 != t.c.indexOf("kit=")) return t.c;
                    for (var e = t.a.length, n = [], i = 0; i < e; i++) n.push(t.a[i].replace(/ /g, "+"));
                    return e = t.c + "?family=" + n.join("%7C"), 0 < t.f.length && (e += "&subset=" + t.f.join(",")), 0 < t.g.length && (e += "&text=" + encodeURIComponent(t.g)), e
                }(i), g(e)), y(e, function() {
                    t(o.a, o.c, Q)
                })
            }, $.prototype.load = function(t) {
                var e = this.a.id,
                    n = this.c.o;
                e ? m(this.c, (this.a.api || "https://use.typekit.net") + "/" + e + ".js", function(e) {
                    if (e) t([]);
                    else if (n.Typekit && n.Typekit.config && n.Typekit.config.fn) {
                        e = n.Typekit.config.fn;
                        for (var i = [], r = 0; r < e.length; r += 2)
                            for (var o = e[r], a = e[r + 1], s = 0; s < a.length; s++) i.push(new b(o, a[s]));
                        try {
                            n.Typekit.load({
                                events: !1,
                                classes: !1,
                                async: !0
                            })
                        } catch (t) {}
                        t(i)
                    }
                }, 2e3) : t([])
            }, tt.prototype.load = function(t) {
                var e = this.f.id,
                    n = this.c.o,
                    i = this;
                e ? (n.__webfontfontdeckmodule__ || (n.__webfontfontdeckmodule__ = {}), n.__webfontfontdeckmodule__[e] = function(e, n) {
                    for (var r = 0, o = n.fonts.length; r < o; ++r) {
                        var a = n.fonts[r];
                        i.a.push(new b(a.name, E("font-weight:" + a.weight + ";font-style:" + a.style)))
                    }
                    t(i.a)
                }, m(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + function(t) {
                    return t.o.location.hostname || t.a.location.hostname
                }(this.c) + "/" + e + ".js", function(e) {
                    e && t([])
                })) : t([])
            };
            var et = new G(window);
            et.a.c.custom = function(t, e) {
                return new W(e, t)
            }, et.a.c.fontdeck = function(t, e) {
                return new tt(e, t)
            }, et.a.c.monotype = function(t, e) {
                return new V(e, t)
            }, et.a.c.typekit = function(t, e) {
                return new $(e, t)
            }, et.a.c.google = function(t, e) {
                return new K(e, t)
            };
            var nt = {
                load: a(et.load, et)
            };
            void 0 === (i = function() {
                return nt
            }.call(e, n, e, t)) || (t.exports = i)
        }()
    }, , , , , , , , , , , , , , , , function(t, e, n) {
        var i = n(16)(n(14), "WeakMap");
        t.exports = i
    }, function(t, e, n) {
        var i = n(16)(n(14), "Set");
        t.exports = i
    }, function(t, e, n) {
        var i = n(16)(n(14), "Promise");
        t.exports = i
    }, function(t, e, n) {
        var i = n(16)(n(14), "DataView");
        t.exports = i
    }, function(t, e, n) {
        var i = n(70),
            r = n(32),
            o = n(69),
            a = n(68),
            s = n(67),
            c = n(24),
            l = n(41),
            h = l(i),
            u = l(r),
            p = l(o),
            d = l(a),
            f = l(s),
            m = c;
        (i && "[object DataView]" != m(new i(new ArrayBuffer(1))) || r && "[object Map]" != m(new r) || o && "[object Promise]" != m(o.resolve()) || a && "[object Set]" != m(new a) || s && "[object WeakMap]" != m(new s)) && (m = function(t) {
            var e = c(t),
                n = "[object Object]" == e ? t.constructor : void 0,
                i = n ? l(n) : "";
            if (i) switch (i) {
                case h:
                    return "[object DataView]";
                case u:
                    return "[object Map]";
                case p:
                    return "[object Promise]";
                case d:
                    return "[object Set]";
                case f:
                    return "[object WeakMap]"
            }
            return e
        }), t.exports = m
    }, function(t, e, n) {
        var i = n(44),
            r = n(35);
        t.exports = function(t) {
            return null != t && r(t.length) && !i(t)
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            return function(n) {
                return t(e(n))
            }
        }
    }, function(t, e, n) {
        var i = n(73)(Object.keys, Object);
        t.exports = i
    }, function(t, e) {
        var n = Object.prototype;
        t.exports = function(t) {
            var e = t && t.constructor;
            return t === ("function" == typeof e && e.prototype || n)
        }
    }, function(t, e, n) {
        var i = n(75),
            r = n(74),
            o = Object.prototype.hasOwnProperty;
        t.exports = function(t) {
            if (!i(t)) return r(t);
            var e = [];
            for (var n in Object(t)) o.call(t, n) && "constructor" != n && e.push(n);
            return e
        }
    }, function(t, e, n) {
        (function(t) {
            var i = n(43),
                r = "object" == typeof e && e && !e.nodeType && e,
                o = r && "object" == typeof t && t && !t.nodeType && t,
                a = o && o.exports === r && i.process,
                s = function() {
                    try {
                        var t = o && o.require && o.require("util").types;
                        return t || a && a.binding && a.binding("util")
                    } catch (t) {}
                }();
            t.exports = s
        }).call(this, n(37)(t))
    }, function(t, e) {
        t.exports = function(t) {
            return function(e) {
                return t(e)
            }
        }
    }, function(t, e, n) {
        var i = n(24),
            r = n(35),
            o = n(21),
            a = {};
        a["[object Float32Array]"] = a["[object Float64Array]"] = a["[object Int8Array]"] = a["[object Int16Array]"] = a["[object Int32Array]"] = a["[object Uint8Array]"] = a["[object Uint8ClampedArray]"] = a["[object Uint16Array]"] = a["[object Uint32Array]"] = !0, a["[object Arguments]"] = a["[object Array]"] = a["[object ArrayBuffer]"] = a["[object Boolean]"] = a["[object DataView]"] = a["[object Date]"] = a["[object Error]"] = a["[object Function]"] = a["[object Map]"] = a["[object Number]"] = a["[object Object]"] = a["[object RegExp]"] = a["[object Set]"] = a["[object String]"] = a["[object WeakMap]"] = !1, t.exports = function(t) {
            return o(t) && r(t.length) && !!a[i(t)]
        }
    }, function(t, e) {
        var n = 9007199254740991,
            i = /^(?:0|[1-9]\d*)$/;
        t.exports = function(t, e) {
            var r = typeof t;
            return !!(e = null == e ? n : e) && ("number" == r || "symbol" != r && i.test(t)) && t > -1 && t % 1 == 0 && t < e
        }
    }, function(t, e) {
        t.exports = function() {
            return !1
        }
    }, function(t, e, n) {
        var i = n(24),
            r = n(21),
            o = "[object Arguments]";
        t.exports = function(t) {
            return r(t) && i(t) == o
        }
    }, function(t, e, n) {
        var i = n(82),
            r = n(21),
            o = Object.prototype,
            a = o.hasOwnProperty,
            s = o.propertyIsEnumerable,
            c = i(function() {
                return arguments
            }()) ? i : function(t) {
                return r(t) && a.call(t, "callee") && !s.call(t, "callee")
            };
        t.exports = c
    }, function(t, e) {
        t.exports = function(t, e) {
            for (var n = -1, i = Array(t); ++n < t;) i[n] = e(n);
            return i
        }
    }, function(t, e, n) {
        var i = n(84),
            r = n(83),
            o = n(30),
            a = n(38),
            s = n(80),
            c = n(36),
            l = Object.prototype.hasOwnProperty;
        t.exports = function(t, e) {
            var n = o(t),
                h = !n && r(t),
                u = !n && !h && a(t),
                p = !n && !h && !u && c(t),
                d = n || h || u || p,
                f = d ? i(t.length, String) : [],
                m = f.length;
            for (var v in t) !e && !l.call(t, v) || d && ("length" == v || u && ("offset" == v || "parent" == v) || p && ("buffer" == v || "byteLength" == v || "byteOffset" == v) || s(v, m)) || f.push(v);
            return f
        }
    }, function(t, e, n) {
        var i = n(85),
            r = n(76),
            o = n(72);
        t.exports = function(t) {
            return o(t) ? i(t) : r(t)
        }
    }, function(t, e) {
        t.exports = function() {
            return []
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            for (var n = -1, i = null == t ? 0 : t.length, r = 0, o = []; ++n < i;) {
                var a = t[n];
                e(a, n, t) && (o[r++] = a)
            }
            return o
        }
    }, function(t, e, n) {
        var i = n(88),
            r = n(87),
            o = Object.prototype.propertyIsEnumerable,
            a = Object.getOwnPropertySymbols,
            s = a ? function(t) {
                return null == t ? [] : (t = Object(t), i(a(t), function(e) {
                    return o.call(t, e)
                }))
            } : r;
        t.exports = s
    }, function(t, e) {
        t.exports = function(t, e) {
            for (var n = -1, i = e.length, r = t.length; ++n < i;) t[r + n] = e[n];
            return t
        }
    }, function(t, e, n) {
        var i = n(90),
            r = n(30);
        t.exports = function(t, e, n) {
            var o = e(t);
            return r(t) ? o : i(o, n(t))
        }
    }, function(t, e, n) {
        var i = n(91),
            r = n(89),
            o = n(86);
        t.exports = function(t) {
            return i(t, o, r)
        }
    }, function(t, e, n) {
        var i = n(92),
            r = 1,
            o = Object.prototype.hasOwnProperty;
        t.exports = function(t, e, n, a, s, c) {
            var l = n & r,
                h = i(t),
                u = h.length;
            if (u != i(e).length && !l) return !1;
            for (var p = u; p--;) {
                var d = h[p];
                if (!(l ? d in e : o.call(e, d))) return !1
            }
            var f = c.get(t);
            if (f && c.get(e)) return f == e;
            var m = !0;
            c.set(t, e), c.set(e, t);
            for (var v = l; ++p < u;) {
                var g = t[d = h[p]],
                    y = e[d];
                if (a) var _ = l ? a(y, g, d, e, t, c) : a(g, y, d, t, e, c);
                if (!(void 0 === _ ? g === y || s(g, y, n, a, c) : _)) {
                    m = !1;
                    break
                }
                v || (v = "constructor" == d)
            }
            if (m && !v) {
                var x = t.constructor,
                    b = e.constructor;
                x != b && "constructor" in t && "constructor" in e && !("function" == typeof x && x instanceof x && "function" == typeof b && b instanceof b) && (m = !1)
            }
            return c.delete(t), c.delete(e), m
        }
    }, function(t, e) {
        t.exports = function(t) {
            var e = -1,
                n = Array(t.size);
            return t.forEach(function(t) {
                n[++e] = t
            }), n
        }
    }, function(t, e) {
        t.exports = function(t) {
            var e = -1,
                n = Array(t.size);
            return t.forEach(function(t, i) {
                n[++e] = [i, t]
            }), n
        }
    }, function(t, e, n) {
        var i = n(14).Uint8Array;
        t.exports = i
    }, function(t, e, n) {
        var i = n(31),
            r = n(96),
            o = n(45),
            a = n(39),
            s = n(95),
            c = n(94),
            l = 1,
            h = 2,
            u = "[object Boolean]",
            p = "[object Date]",
            d = "[object Error]",
            f = "[object Map]",
            m = "[object Number]",
            v = "[object RegExp]",
            g = "[object Set]",
            y = "[object String]",
            _ = "[object Symbol]",
            x = "[object ArrayBuffer]",
            b = "[object DataView]",
            w = i ? i.prototype : void 0,
            M = w ? w.valueOf : void 0;
        t.exports = function(t, e, n, i, w, T, E) {
            switch (n) {
                case b:
                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                    t = t.buffer, e = e.buffer;
                case x:
                    return !(t.byteLength != e.byteLength || !T(new r(t), new r(e)));
                case u:
                case p:
                case m:
                    return o(+t, +e);
                case d:
                    return t.name == e.name && t.message == e.message;
                case v:
                case y:
                    return t == e + "";
                case f:
                    var S = s;
                case g:
                    var A = i & l;
                    if (S || (S = c), t.size != e.size && !A) return !1;
                    var P = E.get(t);
                    if (P) return P == e;
                    i |= h, E.set(t, e);
                    var L = a(S(t), S(e), i, w, T, E);
                    return E.delete(t), L;
                case _:
                    if (M) return M.call(t) == M.call(e)
            }
            return !1
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            return t.has(e)
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            for (var n = -1, i = null == t ? 0 : t.length; ++n < i;)
                if (e(t[n], n, t)) return !0;
            return !1
        }
    }, function(t, e) {
        t.exports = function(t) {
            return this.__data__.has(t)
        }
    }, function(t, e) {
        var n = "__lodash_hash_undefined__";
        t.exports = function(t) {
            return this.__data__.set(t, n), this
        }
    }, function(t, e, n) {
        var i = n(40),
            r = n(101),
            o = n(100);

        function a(t) {
            var e = -1,
                n = null == t ? 0 : t.length;
            for (this.__data__ = new i; ++e < n;) this.add(t[e])
        }
        a.prototype.add = a.prototype.push = r, a.prototype.has = o, t.exports = a
    }, function(t, e, n) {
        var i = n(22);
        t.exports = function(t, e) {
            var n = i(this, t),
                r = n.size;
            return n.set(t, e), this.size += n.size == r ? 0 : 1, this
        }
    }, function(t, e, n) {
        var i = n(22);
        t.exports = function(t) {
            return i(this, t).has(t)
        }
    }, function(t, e, n) {
        var i = n(22);
        t.exports = function(t) {
            return i(this, t).get(t)
        }
    }, function(t, e) {
        t.exports = function(t) {
            var e = typeof t;
            return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
        }
    }, function(t, e, n) {
        var i = n(22);
        t.exports = function(t) {
            var e = i(this, t).delete(t);
            return this.size -= e ? 1 : 0, e
        }
    }, function(t, e, n) {
        var i = n(23),
            r = "__lodash_hash_undefined__";
        t.exports = function(t, e) {
            var n = this.__data__;
            return this.size += this.has(t) ? 0 : 1, n[t] = i && void 0 === e ? r : e, this
        }
    }, function(t, e, n) {
        var i = n(23),
            r = Object.prototype.hasOwnProperty;
        t.exports = function(t) {
            var e = this.__data__;
            return i ? void 0 !== e[t] : r.call(e, t)
        }
    }, function(t, e, n) {
        var i = n(23),
            r = "__lodash_hash_undefined__",
            o = Object.prototype.hasOwnProperty;
        t.exports = function(t) {
            var e = this.__data__;
            if (i) {
                var n = e[t];
                return n === r ? void 0 : n
            }
            return o.call(e, t) ? e[t] : void 0
        }
    }, function(t, e) {
        t.exports = function(t) {
            var e = this.has(t) && delete this.__data__[t];
            return this.size -= e ? 1 : 0, e
        }
    }, function(t, e, n) {
        var i = n(23);
        t.exports = function() {
            this.__data__ = i ? i(null) : {}, this.size = 0
        }
    }, function(t, e, n) {
        var i = n(112),
            r = n(111),
            o = n(110),
            a = n(109),
            s = n(108);

        function c(t) {
            var e = -1,
                n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }
        c.prototype.clear = i, c.prototype.delete = r, c.prototype.get = o, c.prototype.has = a, c.prototype.set = s, t.exports = c
    }, function(t, e, n) {
        var i = n(113),
            r = n(26),
            o = n(32);
        t.exports = function() {
            this.size = 0, this.__data__ = {
                hash: new i,
                map: new(o || r),
                string: new i
            }
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            return null == t ? void 0 : t[e]
        }
    }, function(t, e, n) {
        var i = n(14)["__core-js_shared__"];
        t.exports = i
    }, function(t, e, n) {
        var i = n(116),
            r = function() {
                var t = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || "");
                return t ? "Symbol(src)_1." + t : ""
            }();
        t.exports = function(t) {
            return !!r && r in t
        }
    }, function(t, e) {
        var n = Object.prototype.toString;
        t.exports = function(t) {
            return n.call(t)
        }
    }, function(t, e, n) {
        var i = n(31),
            r = Object.prototype,
            o = r.hasOwnProperty,
            a = r.toString,
            s = i ? i.toStringTag : void 0;
        t.exports = function(t) {
            var e = o.call(t, s),
                n = t[s];
            try {
                t[s] = void 0;
                var i = !0
            } catch (t) {}
            var r = a.call(t);
            return i && (e ? t[s] = n : delete t[s]), r
        }
    }, function(t, e, n) {
        var i = n(44),
            r = n(117),
            o = n(42),
            a = n(41),
            s = /^\[object .+?Constructor\]$/,
            c = Function.prototype,
            l = Object.prototype,
            h = c.toString,
            u = l.hasOwnProperty,
            p = RegExp("^" + h.call(u).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        t.exports = function(t) {
            return !(!o(t) || r(t)) && (i(t) ? p : s).test(a(t))
        }
    }, function(t, e, n) {
        var i = n(26),
            r = n(32),
            o = n(40),
            a = 200;
        t.exports = function(t, e) {
            var n = this.__data__;
            if (n instanceof i) {
                var s = n.__data__;
                if (!r || s.length < a - 1) return s.push([t, e]), this.size = ++n.size, this;
                n = this.__data__ = new o(s)
            }
            return n.set(t, e), this.size = n.size, this
        }
    }, function(t, e) {
        t.exports = function(t) {
            return this.__data__.has(t)
        }
    }, function(t, e) {
        t.exports = function(t) {
            return this.__data__.get(t)
        }
    }, function(t, e) {
        t.exports = function(t) {
            var e = this.__data__,
                n = e.delete(t);
            return this.size = e.size, n
        }
    }, function(t, e, n) {
        var i = n(26);
        t.exports = function() {
            this.__data__ = new i, this.size = 0
        }
    }, function(t, e, n) {
        var i = n(25);
        t.exports = function(t, e) {
            var n = this.__data__,
                r = i(n, t);
            return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
        }
    }, function(t, e, n) {
        var i = n(25);
        t.exports = function(t) {
            return i(this.__data__, t) > -1
        }
    }, function(t, e, n) {
        var i = n(25);
        t.exports = function(t) {
            var e = this.__data__,
                n = i(e, t);
            return n < 0 ? void 0 : e[n][1]
        }
    }, function(t, e, n) {
        var i = n(25),
            r = Array.prototype.splice;
        t.exports = function(t) {
            var e = this.__data__,
                n = i(e, t);
            return !(n < 0 || (n == e.length - 1 ? e.pop() : r.call(e, n, 1), --this.size, 0))
        }
    }, function(t, e) {
        t.exports = function() {
            this.__data__ = [], this.size = 0
        }
    }, function(t, e, n) {
        var i = n(26),
            r = n(125),
            o = n(124),
            a = n(123),
            s = n(122),
            c = n(121);

        function l(t) {
            var e = this.__data__ = new i(t);
            this.size = e.size
        }
        l.prototype.clear = r, l.prototype.delete = o, l.prototype.get = a, l.prototype.has = s, l.prototype.set = c, t.exports = l
    }, function(t, e, n) {
        var i = n(131),
            r = n(39),
            o = n(97),
            a = n(93),
            s = n(71),
            c = n(30),
            l = n(38),
            h = n(36),
            u = 1,
            p = "[object Arguments]",
            d = "[object Array]",
            f = "[object Object]",
            m = Object.prototype.hasOwnProperty;
        t.exports = function(t, e, n, v, g, y) {
            var _ = c(t),
                x = c(e),
                b = _ ? d : s(t),
                w = x ? d : s(e),
                M = (b = b == p ? f : b) == f,
                T = (w = w == p ? f : w) == f,
                E = b == w;
            if (E && l(t)) {
                if (!l(e)) return !1;
                _ = !0, M = !1
            }
            if (E && !M) return y || (y = new i), _ || h(t) ? r(t, e, n, v, g, y) : o(t, e, b, n, v, g, y);
            if (!(n & u)) {
                var S = M && m.call(t, "__wrapped__"),
                    A = T && m.call(e, "__wrapped__");
                if (S || A) {
                    var P = S ? t.value() : t,
                        L = A ? e.value() : e;
                    return y || (y = new i), g(P, L, n, v, y)
                }
            }
            return !!E && (y || (y = new i), a(t, e, n, v, g, y))
        }
    }, function(t, e, n) {
        var i = n(132),
            r = n(21);
        t.exports = function t(e, n, o, a, s) {
            return e === n || (null == e || null == n || !r(e) && !r(n) ? e != e && n != n : i(e, n, o, a, t, s))
        }
    }, function(t, e) {
        t.exports = function(t) {
            if (!t.webpackPolyfill) {
                var e = Object.create(t);
                e.children || (e.children = []), Object.defineProperty(e, "loaded", {
                    enumerable: !0,
                    get: function() {
                        return e.l
                    }
                }), Object.defineProperty(e, "id", {
                    enumerable: !0,
                    get: function() {
                        return e.i
                    }
                }), Object.defineProperty(e, "exports", {
                    enumerable: !0
                }), e.webpackPolyfill = 1
            }
            return e
        }
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();

        function r(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }
        var o = function() {
            function t(e, n, i) {
                void 0 === n && (n = !1), r(this, t), this._fn = e, this._once = n, this._thisArg = i, this._next = this._prev = this._owner = null
            }
            return i(t, [{
                key: "detach",
                value: function() {
                    return null !== this._owner && (this._owner.detach(this), !0)
                }
            }]), t
        }();

        function a(t, e) {
            return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e
        }
        var s = function() {
            function t() {
                r(this, t), this._head = this._tail = void 0
            }
            return i(t, [{
                key: "handlers",
                value: function() {
                    var t = !(arguments.length <= 0 || void 0 === arguments[0]) && arguments[0],
                        e = this._head;
                    if (t) return !!e;
                    for (var n = []; e;) n.push(e), e = e._next;
                    return n
                }
            }, {
                key: "has",
                value: function(t) {
                    if (!(t instanceof o)) throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
                    return t._owner === this
                }
            }, {
                key: "dispatch",
                value: function() {
                    var t = this._head;
                    if (!t) return !1;
                    for (; t;) t._once && this.detach(t), t._fn.apply(t._thisArg, arguments), t = t._next;
                    return !0
                }
            }, {
                key: "add",
                value: function(t) {
                    var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1];
                    if ("function" != typeof t) throw new Error("MiniSignal#add(): First arg must be a Function.");
                    return a(this, new o(t, !1, e))
                }
            }, {
                key: "once",
                value: function(t) {
                    var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1];
                    if ("function" != typeof t) throw new Error("MiniSignal#once(): First arg must be a Function.");
                    return a(this, new o(t, !0, e))
                }
            }, {
                key: "detach",
                value: function(t) {
                    if (!(t instanceof o)) throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
                    return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, null === t._next && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this)
                }
            }, {
                key: "detachAll",
                value: function() {
                    var t = this._head;
                    if (!t) return this;
                    for (this._head = this._tail = null; t;) t._owner = null, t = t._next;
                    return this
                }
            }]), t
        }();
        s.MiniSignalBinding = o, e.default = s, t.exports = e.default
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t, e) {
            e = e || {};
            for (var n = {
                    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                    q: {
                        name: "queryKey",
                        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                    },
                    parser: {
                        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                    }
                }, i = n.parser[e.strictMode ? "strict" : "loose"].exec(t), r = {}, o = 14; o--;) r[n.key[o]] = i[o] || "";
            return r[n.q.name] = {}, r[n.key[12]].replace(n.q.parser, function(t, e, i) {
                e && (r[n.q.name][e] = i)
            }), r
        }
    }, function(t, e, n) {
        ! function(t) {
            "use strict";

            function e() {}
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : +t
            }), "name" in Function.prototype == 0 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(t) {
                if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), n = 1; n < arguments.length; n++) {
                    var i = arguments[n];
                    if (void 0 !== i && null !== i)
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
                }
                return e
            }), Object.assign(e.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners,
                            i = n[t];
                        if (void 0 !== i) {
                            var r = i.indexOf(e); - 1 !== r && i.splice(r, 1)
                        }
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners,
                            n = e[t.type];
                        if (void 0 !== n) {
                            t.target = this;
                            for (var i = n.slice(0), r = 0, o = i.length; r < o; r++) i[r].call(this, t)
                        }
                    }
                }
            });
            var n = "97",
                i = 0,
                r = 1,
                o = 2,
                a = 1,
                s = 2,
                c = 0,
                l = 1,
                h = 2,
                u = 0,
                p = 1,
                d = 2,
                f = 0,
                m = 1,
                v = 2,
                g = 3,
                y = 4,
                _ = 5,
                x = 100,
                b = 101,
                w = 102,
                M = 103,
                T = 104,
                E = 200,
                S = 201,
                A = 202,
                P = 203,
                L = 204,
                R = 205,
                C = 206,
                O = 207,
                I = 208,
                D = 209,
                N = 210,
                B = 0,
                H = 1,
                F = 2,
                k = 3,
                U = 4,
                z = 5,
                G = 6,
                j = 7,
                V = 0,
                W = 1,
                X = 2,
                q = 0,
                Y = 1,
                Z = 2,
                J = 3,
                K = 4,
                Q = 301,
                $ = 302,
                tt = 303,
                et = 304,
                nt = 305,
                it = 306,
                rt = 307,
                ot = 1e3,
                at = 1001,
                st = 1002,
                ct = 1003,
                lt = 1004,
                ht = 1005,
                ut = 1006,
                pt = 1007,
                dt = 1008,
                ft = 1009,
                mt = 1010,
                vt = 1011,
                gt = 1012,
                yt = 1013,
                _t = 1014,
                xt = 1015,
                bt = 1016,
                wt = 1017,
                Mt = 1018,
                Tt = 1019,
                Et = 1020,
                St = 1021,
                At = 1022,
                Pt = 1023,
                Lt = 1024,
                Rt = 1025,
                Ct = Pt,
                Ot = 1026,
                It = 1027,
                Dt = 1028,
                Nt = 33776,
                Bt = 33777,
                Ht = 33778,
                Ft = 33779,
                kt = 35840,
                Ut = 35841,
                zt = 35842,
                Gt = 35843,
                jt = 36196,
                Vt = 37808,
                Wt = 37809,
                Xt = 37810,
                qt = 37811,
                Yt = 37812,
                Zt = 37813,
                Jt = 37814,
                Kt = 37815,
                Qt = 37816,
                $t = 37817,
                te = 37818,
                ee = 37819,
                ne = 37820,
                ie = 37821,
                re = 2201,
                oe = 2400,
                ae = 0,
                se = 1,
                ce = 2,
                le = 3e3,
                he = 3001,
                ue = 3007,
                pe = 3002,
                de = 3004,
                fe = 3005,
                me = 3006,
                ve = 3200,
                ge = 3201,
                ye = 0,
                _e = 1,
                xe = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                        return function() {
                            var e = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0,
                                o = t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & n] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[63 & i | 128] + t[i >> 8 & 255] + "-" + t[i >> 16 & 255] + t[i >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255];
                            return o.toUpperCase()
                        }
                    }(),
                    clamp: function(t, e, n) {
                        return Math.max(e, Math.min(n, t))
                    },
                    euclideanModulo: function(t, e) {
                        return (t % e + e) % e
                    },
                    mapLinear: function(t, e, n, i, r) {
                        return i + (t - e) * (r - i) / (n - e)
                    },
                    lerp: function(t, e, n) {
                        return (1 - n) * t + n * e
                    },
                    smoothstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    degToRad: function(t) {
                        return t * xe.DEG2RAD
                    },
                    radToDeg: function(t) {
                        return t * xe.RAD2DEG
                    },
                    isPowerOfTwo: function(t) {
                        return 0 == (t & t - 1) && 0 !== t
                    },
                    ceilPowerOfTwo: function(t) {
                        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                    },
                    floorPowerOfTwo: function(t) {
                        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                    }
                };

            function be(t, e) {
                this.x = t || 0, this.y = e || 0
            }

            function we() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function Me(t, e, n, i) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
            }

            function Te(t, e, n) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0
            }

            function Ee() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.defineProperties(be.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }
            }), Object.assign(be.prototype, {
                isVector2: !0,
                set: function(t, e) {
                    return this.x = t, this.y = e, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                },
                multiply: function(t) {
                    return this.x *= t.x, this.y *= t.y, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = t.elements;
                    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                },
                clampScalar: function() {
                    var t = new be,
                        e = new be;
                    return function(n, i) {
                        return t.set(n, n), e.set(i, i), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var t = Math.atan2(this.y, this.x);
                    return t < 0 && (t += 2 * Math.PI), t
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                },
                rotateAround: function(t, e) {
                    var n = Math.cos(e),
                        i = Math.sin(e),
                        r = this.x - t.x,
                        o = this.y - t.y;
                    return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this
                }
            }), Object.assign(we.prototype, {
                isMatrix4: !0,
                set: function(t, e, n, i, r, o, a, s, c, l, h, u, p, d, f, m) {
                    var v = this.elements;
                    return v[0] = t, v[4] = e, v[8] = n, v[12] = i, v[1] = r, v[5] = o, v[9] = a, v[13] = s, v[2] = c, v[6] = l, v[10] = h, v[14] = u, v[3] = p, v[7] = d, v[11] = f, v[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new we).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                },
                copyPosition: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                },
                extractBasis: function(t, e, n) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function() {
                    var t = new Te;
                    return function(e) {
                        var n = this.elements,
                            i = e.elements,
                            r = 1 / t.setFromMatrixColumn(e, 0).length(),
                            o = 1 / t.setFromMatrixColumn(e, 1).length(),
                            a = 1 / t.setFromMatrixColumn(e, 2).length();
                        return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[3] = 0, n[4] = i[4] * o, n[5] = i[5] * o, n[6] = i[6] * o, n[7] = 0, n[8] = i[8] * a, n[9] = i[9] * a, n[10] = i[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
                    }
                }(),
                makeRotationFromEuler: function(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z,
                        o = Math.cos(n),
                        a = Math.sin(n),
                        s = Math.cos(i),
                        c = Math.sin(i),
                        l = Math.cos(r),
                        h = Math.sin(r);
                    if ("XYZ" === t.order) {
                        var u = o * l,
                            p = o * h,
                            d = a * l,
                            f = a * h;
                        e[0] = s * l, e[4] = -s * h, e[8] = c, e[1] = p + d * c, e[5] = u - f * c, e[9] = -a * s, e[2] = f - u * c, e[6] = d + p * c, e[10] = o * s
                    } else if ("YXZ" === t.order) {
                        var m = s * l,
                            v = s * h,
                            g = c * l,
                            y = c * h;
                        e[0] = m + y * a, e[4] = g * a - v, e[8] = o * c, e[1] = o * h, e[5] = o * l, e[9] = -a, e[2] = v * a - g, e[6] = y + m * a, e[10] = o * s
                    } else if ("ZXY" === t.order) {
                        var m = s * l,
                            v = s * h,
                            g = c * l,
                            y = c * h;
                        e[0] = m - y * a, e[4] = -o * h, e[8] = g + v * a, e[1] = v + g * a, e[5] = o * l, e[9] = y - m * a, e[2] = -o * c, e[6] = a, e[10] = o * s
                    } else if ("ZYX" === t.order) {
                        var u = o * l,
                            p = o * h,
                            d = a * l,
                            f = a * h;
                        e[0] = s * l, e[4] = d * c - p, e[8] = u * c + f, e[1] = s * h, e[5] = f * c + u, e[9] = p * c - d, e[2] = -c, e[6] = a * s, e[10] = o * s
                    } else if ("YZX" === t.order) {
                        var _ = o * s,
                            x = o * c,
                            b = a * s,
                            w = a * c;
                        e[0] = s * l, e[4] = w - _ * h, e[8] = b * h + x, e[1] = h, e[5] = o * l, e[9] = -a * l, e[2] = -c * l, e[6] = x * h + b, e[10] = _ - w * h
                    } else if ("XZY" === t.order) {
                        var _ = o * s,
                            x = o * c,
                            b = a * s,
                            w = a * c;
                        e[0] = s * l, e[4] = -h, e[8] = c * l, e[1] = _ * h + w, e[5] = o * l, e[9] = x * h - b, e[2] = b * h - x, e[6] = a * l, e[10] = w * h + _
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                makeRotationFromQuaternion: function() {
                    var t = new Te(0, 0, 0),
                        e = new Te(1, 1, 1);
                    return function(n) {
                        return this.compose(t, n, e)
                    }
                }(),
                lookAt: function() {
                    var t = new Te,
                        e = new Te,
                        n = new Te;
                    return function(i, r, o) {
                        var a = this.elements;
                        return n.subVectors(i, r), 0 === n.lengthSq() && (n.z = 1), n.normalize(), t.crossVectors(o, n), 0 === t.lengthSq() && (1 === Math.abs(o.z) ? n.x += 1e-4 : n.z += 1e-4, n.normalize(), t.crossVectors(o, n)), t.normalize(), e.crossVectors(n, t), a[0] = t.x, a[4] = e.x, a[8] = n.x, a[1] = t.y, a[5] = e.y, a[9] = n.y, a[2] = t.z, a[6] = e.z, a[10] = n.z, this
                    }
                }(),
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        o = n[0],
                        a = n[4],
                        s = n[8],
                        c = n[12],
                        l = n[1],
                        h = n[5],
                        u = n[9],
                        p = n[13],
                        d = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        _ = n[11],
                        x = n[15],
                        b = i[0],
                        w = i[4],
                        M = i[8],
                        T = i[12],
                        E = i[1],
                        S = i[5],
                        A = i[9],
                        P = i[13],
                        L = i[2],
                        R = i[6],
                        C = i[10],
                        O = i[14],
                        I = i[3],
                        D = i[7],
                        N = i[11],
                        B = i[15];
                    return r[0] = o * b + a * E + s * L + c * I, r[4] = o * w + a * S + s * R + c * D, r[8] = o * M + a * A + s * C + c * N, r[12] = o * T + a * P + s * O + c * B, r[1] = l * b + h * E + u * L + p * I, r[5] = l * w + h * S + u * R + p * D, r[9] = l * M + h * A + u * C + p * N, r[13] = l * T + h * P + u * O + p * B, r[2] = d * b + f * E + m * L + v * I, r[6] = d * w + f * S + m * R + v * D, r[10] = d * M + f * A + m * C + v * N, r[14] = d * T + f * P + m * O + v * B, r[3] = g * b + y * E + _ * L + x * I, r[7] = g * w + y * S + _ * R + x * D, r[11] = g * M + y * A + _ * C + x * N, r[15] = g * T + y * P + _ * O + x * B, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                },
                applyToBufferAttribute: function() {
                    var t = new Te;
                    return function(e) {
                        for (var n = 0, i = e.count; n < i; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix4(this), e.setXYZ(n, t.x, t.y, t.z);
                        return e
                    }
                }(),
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[4],
                        i = t[8],
                        r = t[12],
                        o = t[1],
                        a = t[5],
                        s = t[9],
                        c = t[13],
                        l = t[2],
                        h = t[6],
                        u = t[10],
                        p = t[14],
                        d = t[3],
                        f = t[7],
                        m = t[11],
                        v = t[15];
                    return d * (+r * s * h - i * c * h - r * a * u + n * c * u + i * a * p - n * s * p) + f * (+e * s * p - e * c * u + r * o * u - i * o * p + i * c * l - r * s * l) + m * (+e * c * h - e * a * p - r * o * h + n * o * p + r * a * l - n * c * l) + v * (-i * a * l - e * s * h + e * a * u + i * o * h - n * o * u + n * s * l)
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                },
                setPosition: function(t) {
                    var e = this.elements;
                    return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
                },
                getInverse: function(t, e) {
                    var n = this.elements,
                        i = t.elements,
                        r = i[0],
                        o = i[1],
                        a = i[2],
                        s = i[3],
                        c = i[4],
                        l = i[5],
                        h = i[6],
                        u = i[7],
                        p = i[8],
                        d = i[9],
                        f = i[10],
                        m = i[11],
                        v = i[12],
                        g = i[13],
                        y = i[14],
                        _ = i[15],
                        x = d * y * u - g * f * u + g * h * m - l * y * m - d * h * _ + l * f * _,
                        b = v * f * u - p * y * u - v * h * m + c * y * m + p * h * _ - c * f * _,
                        w = p * g * u - v * d * u + v * l * m - c * g * m - p * l * _ + c * d * _,
                        M = v * d * h - p * g * h - v * l * f + c * g * f + p * l * y - c * d * y,
                        T = r * x + o * b + a * w + s * M;
                    if (0 === T) {
                        var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(E);
                        return console.warn(E), this.identity()
                    }
                    var S = 1 / T;
                    return n[0] = x * S, n[1] = (g * f * s - d * y * s - g * a * m + o * y * m + d * a * _ - o * f * _) * S, n[2] = (l * y * s - g * h * s + g * a * u - o * y * u - l * a * _ + o * h * _) * S, n[3] = (d * h * s - l * f * s - d * a * u + o * f * u + l * a * m - o * h * m) * S, n[4] = b * S, n[5] = (p * y * s - v * f * s + v * a * m - r * y * m - p * a * _ + r * f * _) * S, n[6] = (v * h * s - c * y * s - v * a * u + r * y * u + c * a * _ - r * h * _) * S, n[7] = (c * f * s - p * h * s + p * a * u - r * f * u - c * a * m + r * h * m) * S, n[8] = w * S, n[9] = (v * d * s - p * g * s - v * o * m + r * g * m + p * o * _ - r * d * _) * S, n[10] = (c * g * s - v * l * s + v * o * u - r * g * u - c * o * _ + r * l * _) * S, n[11] = (p * l * s - c * d * s - p * o * u + r * d * u + c * o * m - r * l * m) * S, n[12] = M * S, n[13] = (p * g * a - v * d * a + v * o * f - r * g * f - p * o * y + r * d * y) * S, n[14] = (v * l * a - c * g * a - v * o * h + r * g * h + c * o * y - r * l * y) * S, n[15] = (c * d * a - p * l * a + p * o * h - r * d * h - c * o * f + r * l * f) * S, this
                },
                scale: function(t) {
                    var e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z;
                    return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                },
                getMaxScaleOnAxis: function() {
                    var t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, i))
                },
                makeTranslation: function(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(t, e) {
                    var n = Math.cos(e),
                        i = Math.sin(e),
                        r = 1 - n,
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = r * o,
                        l = r * a;
                    return this.set(c * o + n, c * a - i * s, c * s + i * a, 0, c * a + i * s, l * a + n, l * s - i * o, 0, c * s - i * a, l * s + i * o, r * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function(t, e, n) {
                    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(t, e, n) {
                    var i = this.elements,
                        r = e._x,
                        o = e._y,
                        a = e._z,
                        s = e._w,
                        c = r + r,
                        l = o + o,
                        h = a + a,
                        u = r * c,
                        p = r * l,
                        d = r * h,
                        f = o * l,
                        m = o * h,
                        v = a * h,
                        g = s * c,
                        y = s * l,
                        _ = s * h,
                        x = n.x,
                        b = n.y,
                        w = n.z;
                    return i[0] = (1 - (f + v)) * x, i[1] = (p + _) * x, i[2] = (d - y) * x, i[3] = 0, i[4] = (p - _) * b, i[5] = (1 - (u + v)) * b, i[6] = (m + g) * b, i[7] = 0, i[8] = (d + y) * w, i[9] = (m - g) * w, i[10] = (1 - (u + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                },
                decompose: function() {
                    var t = new Te,
                        e = new we;
                    return function(n, i, r) {
                        var o = this.elements,
                            a = t.set(o[0], o[1], o[2]).length(),
                            s = t.set(o[4], o[5], o[6]).length(),
                            c = t.set(o[8], o[9], o[10]).length(),
                            l = this.determinant();
                        l < 0 && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], e.copy(this);
                        var h = 1 / a,
                            u = 1 / s,
                            p = 1 / c;
                        return e.elements[0] *= h, e.elements[1] *= h, e.elements[2] *= h, e.elements[4] *= u, e.elements[5] *= u, e.elements[6] *= u, e.elements[8] *= p, e.elements[9] *= p, e.elements[10] *= p, i.setFromRotationMatrix(e), r.x = a, r.y = s, r.z = c, this
                    }
                }(),
                makePerspective: function(t, e, n, i, r, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var a = this.elements,
                        s = 2 * r / (e - t),
                        c = 2 * r / (n - i),
                        l = (e + t) / (e - t),
                        h = (n + i) / (n - i),
                        u = -(o + r) / (o - r),
                        p = -2 * o * r / (o - r);
                    return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makeOrthographic: function(t, e, n, i, r, o) {
                    var a = this.elements,
                        s = 1 / (e - t),
                        c = 1 / (n - i),
                        l = 1 / (o - r),
                        h = (e + t) * s,
                        u = (n + i) * c,
                        p = (o + r) * l;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                }
            }), Object.assign(Me, {
                slerp: function(t, e, n, i) {
                    return n.copy(t).slerp(e, i)
                },
                slerpFlat: function(t, e, n, i, r, o, a) {
                    var s = n[i + 0],
                        c = n[i + 1],
                        l = n[i + 2],
                        h = n[i + 3],
                        u = r[o + 0],
                        p = r[o + 1],
                        d = r[o + 2],
                        f = r[o + 3];
                    if (h !== f || s !== u || c !== p || l !== d) {
                        var m = 1 - a,
                            v = s * u + c * p + l * d + h * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var _ = Math.sqrt(y),
                                x = Math.atan2(_, v * g);
                            m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                        }
                        var b = a * g;
                        if (s = s * m + u * b, c = c * m + p * b, l = l * m + d * b, h = h * m + f * b, m === 1 - a) {
                            var w = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
                            s *= w, c *= w, l *= w, h *= w
                        }
                    }
                    t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h
                }
            }), Object.defineProperties(Me.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(t) {
                        this._w = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(Me.prototype, {
                isQuaternion: !0,
                set: function(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._w = i, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
                },
                setFromEuler: function(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = t._x,
                        i = t._y,
                        r = t._z,
                        o = t.order,
                        a = Math.cos,
                        s = Math.sin,
                        c = a(n / 2),
                        l = a(i / 2),
                        h = a(r / 2),
                        u = s(n / 2),
                        p = s(i / 2),
                        d = s(r / 2);
                    return "XYZ" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d) : "YXZ" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d) : "ZXY" === o ? (this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d) : "ZYX" === o ? (this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d) : "YZX" === o ? (this._x = u * l * h + c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h - u * p * d) : "XZY" === o && (this._x = u * l * h - c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h + u * p * d), !1 !== e && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(t, e) {
                    var n = e / 2,
                        i = Math.sin(n);
                    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t) {
                    var e, n = t.elements,
                        i = n[0],
                        r = n[4],
                        o = n[8],
                        a = n[1],
                        s = n[5],
                        c = n[9],
                        l = n[2],
                        h = n[6],
                        u = n[10],
                        p = i + s + u;
                    return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (h - c) * e, this._y = (o - l) * e, this._z = (a - r) * e) : i > s && i > u ? (e = 2 * Math.sqrt(1 + i - s - u), this._w = (h - c) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (o + l) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - i - u), this._w = (o - l) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (c + h) / e) : (e = 2 * Math.sqrt(1 + u - i - s), this._w = (a - r) / e, this._x = (o + l) / e, this._y = (c + h) / e, this._z = .25 * e), this.onChangeCallback(), this
                },
                setFromUnitVectors: function() {
                    var t, e = new Te;
                    return function(n, i) {
                        return void 0 === e && (e = new Te), (t = n.dot(i) + 1) < 1e-6 ? (t = 0, Math.abs(n.x) > Math.abs(n.z) ? e.set(-n.y, n.x, 0) : e.set(0, -n.z, n.y)) : e.crossVectors(n, i), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
                    }
                }(),
                angleTo: function(t) {
                    return 2 * Math.acos(Math.abs(xe.clamp(this.dot(t), -1, 1)))
                },
                rotateTowards: function(t, e) {
                    var n = this.angleTo(t);
                    if (0 === n) return this;
                    var i = Math.min(1, e / n);
                    return this.slerp(t, i), this
                },
                inverse: function() {
                    return this.conjugate()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyQuaternions(t, this)
                },
                multiplyQuaternions: function(t, e) {
                    var n = t._x,
                        i = t._y,
                        r = t._z,
                        o = t._w,
                        a = e._x,
                        s = e._y,
                        c = e._z,
                        l = e._w;
                    return this._x = n * l + o * a + i * c - r * s, this._y = i * l + o * s + r * a - n * c, this._z = r * l + o * c + n * s - i * a, this._w = o * l - n * a - i * s - r * c, this.onChangeCallback(), this
                },
                slerp: function(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    var n = this._x,
                        i = this._y,
                        r = this._z,
                        o = this._w,
                        a = o * t._w + n * t._x + i * t._y + r * t._z;
                    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
                    var s = 1 - a * a;
                    if (s <= Number.EPSILON) {
                        var c = 1 - e;
                        return this._w = c * o + e * this._w, this._x = c * n + e * this._x, this._y = c * i + e * this._y, this._z = c * r + e * this._z, this.normalize()
                    }
                    var l = Math.sqrt(s),
                        h = Math.atan2(l, a),
                        u = Math.sin((1 - e) * h) / l,
                        p = Math.sin(e * h) / l;
                    return this._w = o * u + this._w * p, this._x = n * u + this._x * p, this._y = i * u + this._y * p, this._z = r * u + this._z * p, this.onChangeCallback(), this
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(Te.prototype, {
                isVector3: !0,
                set: function(t, e, n) {
                    return this.x = t, this.y = e, this.z = n, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                },
                multiplyVectors: function(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                },
                applyEuler: function() {
                    var t = new Me;
                    return function(e) {
                        return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
                    }
                }(),
                applyAxisAngle: function() {
                    var t = new Me;
                    return function(e, n) {
                        return this.applyQuaternion(t.setFromAxisAngle(e, n))
                    }
                }(),
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements,
                        o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this
                },
                applyQuaternion: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.x,
                        o = t.y,
                        a = t.z,
                        s = t.w,
                        c = s * e + o * i - a * n,
                        l = s * n + a * e - r * i,
                        h = s * i + r * n - o * e,
                        u = -r * e - o * n - a * i;
                    return this.x = c * s + u * -r + l * -a - h * -o, this.y = l * s + u * -o + h * -r - c * -a, this.z = h * s + u * -a + c * -o - l * -r, this
                },
                project: function(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                },
                unproject: function() {
                    var t = new we;
                    return function(e) {
                        return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld)
                    }
                }(),
                transformDirection: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                },
                clampScalar: function() {
                    var t = new Te,
                        e = new Te;
                    return function(n, i) {
                        return t.set(n, n, n), e.set(i, i, i), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                cross: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                },
                crossVectors: function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        o = e.x,
                        a = e.y,
                        s = e.z;
                    return this.x = i * s - r * a, this.y = r * o - n * s, this.z = n * a - i * o, this
                },
                projectOnVector: function(t) {
                    var e = t.dot(this) / t.lengthSq();
                    return this.copy(t).multiplyScalar(e)
                },
                projectOnPlane: function() {
                    var t = new Te;
                    return function(e) {
                        return t.copy(this).projectOnVector(e), this.sub(t)
                    }
                }(),
                reflect: function() {
                    var t = new Te;
                    return function(e) {
                        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                }(),
                angleTo: function(t) {
                    var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                    return Math.acos(xe.clamp(e, -1, 1))
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y,
                        i = this.z - t.z;
                    return e * e + n * n + i * i
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                },
                setFromSpherical: function(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                },
                setFromSphericalCoords: function(t, e, n) {
                    var i = Math.sin(e) * t;
                    return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
                },
                setFromCylindrical: function(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                },
                setFromCylindricalCoords: function(t, e, n) {
                    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                },
                setFromMatrixPosition: function(t) {
                    var e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                },
                setFromMatrixScale: function(t) {
                    var e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        i = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = n, this.z = i, this
                },
                setFromMatrixColumn: function(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
            }), Object.assign(Ee.prototype, {
                isMatrix3: !0,
                set: function(t, e, n, i, r, o, a, s, c) {
                    var l = this.elements;
                    return l[0] = t, l[1] = i, l[2] = a, l[3] = e, l[4] = r, l[5] = s, l[6] = n, l[7] = o, l[8] = c, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                },
                setFromMatrix4: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                },
                applyToBufferAttribute: function() {
                    var t = new Te;
                    return function(e) {
                        for (var n = 0, i = e.count; n < i; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix3(this), e.setXYZ(n, t.x, t.y, t.z);
                        return e
                    }
                }(),
                multiply: function(t) {
                    return this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        o = n[0],
                        a = n[3],
                        s = n[6],
                        c = n[1],
                        l = n[4],
                        h = n[7],
                        u = n[2],
                        p = n[5],
                        d = n[8],
                        f = i[0],
                        m = i[3],
                        v = i[6],
                        g = i[1],
                        y = i[4],
                        _ = i[7],
                        x = i[2],
                        b = i[5],
                        w = i[8];
                    return r[0] = o * f + a * g + s * x, r[3] = o * m + a * y + s * b, r[6] = o * v + a * _ + s * w, r[1] = c * f + l * g + h * x, r[4] = c * m + l * y + h * b, r[7] = c * v + l * _ + h * w, r[2] = u * f + p * g + d * x, r[5] = u * m + p * y + d * b, r[8] = u * v + p * _ + d * w, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                },
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        o = t[4],
                        a = t[5],
                        s = t[6],
                        c = t[7],
                        l = t[8];
                    return e * o * l - e * a * c - n * r * l + n * a * s + i * r * c - i * o * s
                },
                getInverse: function(t, e) {
                    t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = t.elements,
                        i = this.elements,
                        r = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4],
                        l = n[5],
                        h = n[6],
                        u = n[7],
                        p = n[8],
                        d = p * c - l * u,
                        f = l * h - p * s,
                        m = u * s - c * h,
                        v = r * d + o * f + a * m;
                    if (0 === v) {
                        var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(g);
                        return console.warn(g), this.identity()
                    }
                    var y = 1 / v;
                    return i[0] = d * y, i[1] = (a * u - p * o) * y, i[2] = (l * o - a * c) * y, i[3] = f * y, i[4] = (p * r - a * h) * y, i[5] = (a * s - l * r) * y, i[6] = m * y, i[7] = (o * h - u * r) * y, i[8] = (c * r - o * s) * y, this
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                },
                getNormalMatrix: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                },
                transposeIntoArray: function(t) {
                    var e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                },
                setUvTransform: function(t, e, n, i, r, o, a) {
                    var s = Math.cos(r),
                        c = Math.sin(r);
                    this.set(n * s, n * c, -n * (s * o + c * a) + o + t, -i * c, i * s, -i * (-c * o + s * a) + a + e, 0, 0, 1)
                },
                scale: function(t, e) {
                    var n = this.elements;
                    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t),
                        i = this.elements,
                        r = i[0],
                        o = i[3],
                        a = i[6],
                        s = i[1],
                        c = i[4],
                        l = i[7];
                    return i[0] = e * r + n * s, i[3] = e * o + n * c, i[6] = e * a + n * l, i[1] = -n * r + e * s, i[4] = -n * o + e * c, i[7] = -n * a + e * l, this
                },
                translate: function(t, e) {
                    var n = this.elements;
                    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                }
            });
            var Se = {
                    getDataURL: function(t) {
                        var e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = t.width, e.height = t.height;
                            var n = e.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height)
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }
                },
                Ae = 0;

            function Pe(t, e, n, i, r, o, a, s, c, l) {
                Object.defineProperty(this, "id", {
                    value: Ae++
                }), this.uuid = xe.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Pe.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Pe.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : at, this.wrapT = void 0 !== i ? i : at, this.magFilter = void 0 !== r ? r : ut, this.minFilter = void 0 !== o ? o : dt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Pt, this.type = void 0 !== s ? s : ft, this.offset = new be(0, 0), this.repeat = new be(1, 1), this.center = new be(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ee, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : le, this.version = 0, this.onUpdate = null
            }

            function Le(t, e, n, i) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
            }

            function Re(t, e, n) {
                this.width = t, this.height = e, this.scissor = new Le(0, 0, t, e), this.scissorTest = !1, this.viewport = new Le(0, 0, t, e), void 0 === (n = n || {}).minFilter && (n.minFilter = ut), this.texture = new Pe(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.generateMipmaps = void 0 === n.generateMipmaps || n.generateMipmaps, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function Ce(t, e, n) {
                Re.call(this, t, e, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0
            }

            function Oe(t, e, n, i, r, o, a, s, c, l, h, u) {
                Pe.call(this, null, o, a, s, c, l, i, r, h, u), this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.magFilter = void 0 !== c ? c : ct, this.minFilter = void 0 !== l ? l : ct, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }

            function Ie(t, e) {
                this.min = void 0 !== t ? t : new Te(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Te(-1 / 0, -1 / 0, -1 / 0)
            }

            function De(t, e) {
                this.center = void 0 !== t ? t : new Te, this.radius = void 0 !== e ? e : 0
            }

            function Ne(t, e) {
                this.normal = void 0 !== t ? t : new Te(1, 0, 0), this.constant = void 0 !== e ? e : 0
            }

            function Be(t, e, n, i, r, o) {
                this.planes = [void 0 !== t ? t : new Ne, void 0 !== e ? e : new Ne, void 0 !== n ? n : new Ne, void 0 !== i ? i : new Ne, void 0 !== r ? r : new Ne, void 0 !== o ? o : new Ne]
            }
            Pe.DEFAULT_IMAGE = void 0, Pe.DEFAULT_MAPPING = 300, Pe.prototype = Object.assign(Object.create(e.prototype), {
                constructor: Pe,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (void 0 !== this.image) {
                        var i = this.image;
                        if (void 0 === i.uuid && (i.uuid = xe.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                            var r;
                            if (Array.isArray(i)) {
                                r = [];
                                for (var o = 0, a = i.length; o < a; o++) r.push(Se.getDataURL(i[o]))
                            } else r = Se.getDataURL(i);
                            t.images[i.uuid] = {
                                uuid: i.uuid,
                                url: r
                            }
                        }
                        n.image = i.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case ot:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case at:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case st:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case ot:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case at:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case st:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(Pe.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Le.prototype, {
                isVector4: !0,
                set: function(t, e, n, i) {
                    return this.x = t, this.y = e, this.z = n, this.w = i, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setW: function(t) {
                    return this.w = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        o = t.elements;
                    return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                setAxisAngleFromQuaternion: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                },
                setAxisAngleFromRotationMatrix: function(t) {
                    var e, n, i, r, o = t.elements,
                        a = o[0],
                        s = o[4],
                        c = o[8],
                        l = o[1],
                        h = o[5],
                        u = o[9],
                        p = o[2],
                        d = o[6],
                        f = o[10];
                    if (Math.abs(s - l) < .01 && Math.abs(c - p) < .01 && Math.abs(u - d) < .01) {
                        if (Math.abs(s + l) < .1 && Math.abs(c + p) < .1 && Math.abs(u + d) < .1 && Math.abs(a + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        var m = (a + 1) / 2,
                            v = (h + 1) / 2,
                            g = (f + 1) / 2,
                            y = (s + l) / 4,
                            _ = (c + p) / 4,
                            x = (u + d) / 4;
                        return m > v && m > g ? m < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(m), i = y / n, r = _ / n) : v > g ? v < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(v), n = y / i, r = x / i) : g < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(g), n = _ / r, i = x / r), this.set(n, i, r, e), this
                    }
                    var b = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (l - s) * (l - s));
                    return Math.abs(b) < .001 && (b = 1), this.x = (d - u) / b, this.y = (c - p) / b, this.z = (l - s) / b, this.w = Math.acos((a + h + f - 1) / 2), this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                },
                clampScalar: function() {
                    var t, e;
                    return function(n, i) {
                        return void 0 === t && (t = new Le, e = new Le), t.set(n, n, n, n), e.set(i, i, i, i), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
            }), Re.prototype = Object.assign(Object.create(e.prototype), {
                constructor: Re,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Ce.prototype = Object.create(Re.prototype), Ce.prototype.constructor = Ce, Ce.prototype.isWebGLRenderTargetCube = !0, Oe.prototype = Object.create(Pe.prototype), Oe.prototype.constructor = Oe, Oe.prototype.isDataTexture = !0, Object.assign(Ie.prototype, {
                isBox3: !0,
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromArray: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                        var l = t[s],
                            h = t[s + 1],
                            u = t[s + 2];
                        l < e && (e = l), h < n && (n = h), u < i && (i = u), l > r && (r = l), h > o && (o = h), u > a && (a = u)
                    }
                    return this.min.set(e, n, i), this.max.set(r, o, a), this
                },
                setFromBufferAttribute: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
                        var l = t.getX(s),
                            h = t.getY(s),
                            u = t.getZ(s);
                        l < e && (e = l), h < n && (n = h), u < i && (i = u), l > r && (r = l), h > o && (o = h), u > a && (a = u)
                    }
                    return this.min.set(e, n, i), this.max.set(r, o, a), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var t = new Te;
                    return function(e, n) {
                        var i = t.copy(n).multiplyScalar(.5);
                        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                    }
                }(),
                setFromObject: function(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Te), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Te), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                expandByObject: function() {
                    var t, e, n, i = new Te;

                    function r(r) {
                        var o = r.geometry;
                        if (void 0 !== o)
                            if (o.isGeometry) {
                                var a = o.vertices;
                                for (e = 0, n = a.length; e < n; e++) i.copy(a[e]), i.applyMatrix4(r.matrixWorld), t.expandByPoint(i)
                            } else if (o.isBufferGeometry) {
                            var s = o.attributes.position;
                            if (void 0 !== s)
                                for (e = 0, n = s.count; e < n; e++) i.fromBufferAttribute(s, e).applyMatrix4(r.matrixWorld), t.expandByPoint(i)
                        }
                    }
                    return function(e) {
                        return t = this, e.updateMatrixWorld(!0), e.traverse(r), this
                    }
                }(),
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                },
                getParameter: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Te), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                },
                intersectsSphere: function() {
                    var t = new Te;
                    return function(e) {
                        return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                }(),
                intersectsPlane: function(t) {
                    var e, n;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                },
                intersectsTriangle: function() {
                    var t = new Te,
                        e = new Te,
                        n = new Te,
                        i = new Te,
                        r = new Te,
                        o = new Te,
                        a = new Te,
                        s = new Te,
                        c = new Te,
                        l = new Te;

                    function h(i) {
                        var r, o;
                        for (r = 0, o = i.length - 3; r <= o; r += 3) {
                            a.fromArray(i, r);
                            var s = c.x * Math.abs(a.x) + c.y * Math.abs(a.y) + c.z * Math.abs(a.z),
                                l = t.dot(a),
                                h = e.dot(a),
                                u = n.dot(a);
                            if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > s) return !1
                        }
                        return !0
                    }
                    return function(a) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(s), c.subVectors(this.max, s), t.subVectors(a.a, s), e.subVectors(a.b, s), n.subVectors(a.c, s), i.subVectors(e, t), r.subVectors(n, e), o.subVectors(t, n);
                        var u = [0, -i.z, i.y, 0, -r.z, r.y, 0, -o.z, o.y, i.z, 0, -i.x, r.z, 0, -r.x, o.z, 0, -o.x, -i.y, i.x, 0, -r.y, r.x, 0, -o.y, o.x, 0];
                        return !!h(u) && !!h(u = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (l.crossVectors(i, r), h(u = [l.x, l.y, l.z]))
                    }
                }(),
                clampPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Te), e.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var t = new Te;
                    return function(e) {
                        var n = t.copy(e).clamp(this.min, this.max);
                        return n.sub(e).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var t = new Te;
                    return function(e) {
                        return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new De), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
                    }
                }(),
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                applyMatrix4: function() {
                    var t = [new Te, new Te, new Te, new Te, new Te, new Te, new Te, new Te];
                    return function(e) {
                        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                    }
                }(),
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }), Object.assign(De.prototype, {
                set: function(t, e) {
                    return this.center.copy(t), this.radius = e, this
                },
                setFromPoints: function() {
                    var t = new Ie;
                    return function(e, n) {
                        var i = this.center;
                        void 0 !== n ? i.copy(n) : t.setFromPoints(e).getCenter(i);
                        for (var r = 0, o = 0, a = e.length; o < a; o++) r = Math.max(r, i.distanceToSquared(e[o]));
                        return this.radius = Math.sqrt(r), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(t) {
                    return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(t) {
                    var e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function(t) {
                    return t.intersectsSphere(this)
                },
                intersectsPlane: function(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(t, e) {
                    var n = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Te), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                },
                getBoundingBox: function(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Ie), t.set(this.center, this.center), t.expandByScalar(this.radius), t
                },
                applyMatrix4: function(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                },
                translate: function(t) {
                    return this.center.add(t), this
                },
                equals: function(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            }), Object.assign(Ne.prototype, {
                set: function(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                },
                setComponents: function(t, e, n, i) {
                    return this.normal.set(t, e, n), this.constant = i, this
                },
                setFromNormalAndCoplanarPoint: function(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                },
                setFromCoplanarPoints: function() {
                    var t = new Te,
                        e = new Te;
                    return function(n, i, r) {
                        var o = t.subVectors(r, i).cross(e.subVectors(n, i)).normalize();
                        return this.setFromNormalAndCoplanarPoint(o, n), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                },
                normalize: function() {
                    var t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(t) {
                    return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function(t) {
                    return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Te), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                },
                intersectLine: function() {
                    var t = new Te;
                    return function(e, n) {
                        void 0 === n && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new Te);
                        var i = e.delta(t),
                            r = this.normal.dot(i);
                        if (0 === r) return 0 === this.distanceToPoint(e.start) ? n.copy(e.start) : void 0;
                        var o = -(e.start.dot(this.normal) + this.constant) / r;
                        return o < 0 || o > 1 ? void 0 : n.copy(i).multiplyScalar(o).add(e.start)
                    }
                }(),
                intersectsLine: function(t) {
                    var e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return e < 0 && n > 0 || n < 0 && e > 0
                },
                intersectsBox: function(t) {
                    return t.intersectsPlane(this)
                },
                intersectsSphere: function(t) {
                    return t.intersectsPlane(this)
                },
                coplanarPoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Te), t.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var t = new Te,
                        e = new Ee;
                    return function(n, i) {
                        var r = i || e.getNormalMatrix(n),
                            o = this.coplanarPoint(t).applyMatrix4(n),
                            a = this.normal.applyMatrix3(r).normalize();
                        return this.constant = -o.dot(a), this
                    }
                }(),
                translate: function(t) {
                    return this.constant -= t.dot(this.normal), this
                },
                equals: function(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            }), Object.assign(Be.prototype, {
                set: function(t, e, n, i, r, o) {
                    var a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this
                },
                setFromMatrix: function(t) {
                    var e = this.planes,
                        n = t.elements,
                        i = n[0],
                        r = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        c = n[5],
                        l = n[6],
                        h = n[7],
                        u = n[8],
                        p = n[9],
                        d = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return e[0].setComponents(a - i, h - s, f - u, y - m).normalize(), e[1].setComponents(a + i, h + s, f + u, y + m).normalize(), e[2].setComponents(a + r, h + c, f + p, y + v).normalize(), e[3].setComponents(a - r, h - c, f - p, y - v).normalize(), e[4].setComponents(a - o, h - l, f - d, y - g).normalize(), e[5].setComponents(a + o, h + l, f + d, y + g).normalize(), this
                },
                intersectsObject: function() {
                    var t = new De;
                    return function(e) {
                        var n = e.geometry;
                        return null === n.boundingSphere && n.computeBoundingSphere(), t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSprite: function() {
                    var t = new De;
                    return function(e) {
                        return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSphere: function(t) {
                    for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                        var o = e[r].distanceToPoint(n);
                        if (o < i) return !1
                    }
                    return !0
                },
                intersectsBox: function() {
                    var t = new Te;
                    return function(e) {
                        for (var n = this.planes, i = 0; i < 6; i++) {
                            var r = n[i];
                            if (t.x = r.normal.x > 0 ? e.max.x : e.min.x, t.y = r.normal.y > 0 ? e.max.y : e.min.y, t.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(t) < 0) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++)
                        if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            });
            var He = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "\nvec3 transformed = vec3( position );\n",
                    beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                    bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                    color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                    common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                    defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                    encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                    envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                    gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                    lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                    map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                    map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
                    normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                    project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
                    dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                    dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                    tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                    uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
                    uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n}\n",
                    background_vert: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4( position, 1.0 );\n\tgl_Position.z = 1.0;\n}\n",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                    cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                    equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\tvec4 matcapColor = texture2D( matcap, uv );\n\tmatcapColor = matcapTexelToLinear( matcapColor );\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}\n",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
                    shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n"
                },
                Fe = {
                    merge: function(t) {
                        for (var e = {}, n = 0; n < t.length; n++) {
                            var i = this.clone(t[n]);
                            for (var r in i) e[r] = i[r]
                        }
                        return e
                    },
                    clone: function(t) {
                        var e = {};
                        for (var n in t)
                            for (var i in e[n] = {}, t[n]) {
                                var r = t[n][i];
                                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                            }
                        return e
                    }
                },
                ke = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                };

            function Ue(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            Object.assign(Ue.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                },
                setScalar: function(t) {
                    return this.r = t, this.g = t, this.b = t, this
                },
                setHex: function(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                },
                setRGB: function(t, e, n) {
                    return this.r = t, this.g = e, this.b = n, this
                },
                setHSL: function() {
                    function t(t, e, n) {
                        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                    }
                    return function(e, n, i) {
                        if (e = xe.euclideanModulo(e, 1), n = xe.clamp(n, 0, 1), i = xe.clamp(i, 0, 1), 0 === n) this.r = this.g = this.b = i;
                        else {
                            var r = i <= .5 ? i * (1 + n) : i + n - i * n,
                                o = 2 * i - r;
                            this.r = t(o, r, e + 1 / 3), this.g = t(o, r, e), this.b = t(o, r, e - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var i, r = n[1],
                            o = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                                if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var a = parseFloat(i[1]) / 360,
                                        s = parseInt(i[2], 10) / 100,
                                        c = parseInt(i[3], 10) / 100;
                                    return e(i[5]), this.setHSL(a, s, c)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var l = n[1],
                            h = l.length;
                        if (3 === h) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                        if (6 === h) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
                    }
                    if (t && t.length > 0) {
                        var l = ke[t];
                        void 0 !== l ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t)
                    }
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                },
                copyGammaToLinear: function(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                },
                copyLinearToGamma: function(t, e) {
                    void 0 === e && (e = 2);
                    var n = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                },
                convertGammaToLinear: function(t) {
                    return this.copyGammaToLinear(this, t), this
                },
                convertLinearToGamma: function(t) {
                    return this.copyLinearToGamma(this, t), this
                },
                copySRGBToLinear: function() {
                    function t(t) {
                        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                    }
                    return function(e) {
                        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                    }
                }(),
                copyLinearToSRGB: function() {
                    function t(t) {
                        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                    }
                    return function(e) {
                        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                    }
                }(),
                convertSRGBToLinear: function() {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function() {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var e, n, i = this.r,
                        r = this.g,
                        o = this.b,
                        a = Math.max(i, r, o),
                        s = Math.min(i, r, o),
                        c = (s + a) / 2;
                    if (s === a) e = 0, n = 0;
                    else {
                        var l = a - s;
                        switch (n = c <= .5 ? l / (a + s) : l / (2 - a - s), a) {
                            case i:
                                e = (r - o) / l + (r < o ? 6 : 0);
                                break;
                            case r:
                                e = (o - i) / l + 2;
                                break;
                            case o:
                                e = (i - r) / l + 4
                        }
                        e /= 6
                    }
                    return t.h = e, t.s = n, t.l = c, t
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function() {
                    var t = {};
                    return function(e, n, i) {
                        return this.getHSL(t), t.h += e, t.s += n, t.l += i, this.setHSL(t.h, t.s, t.l), this
                    }
                }(),
                add: function(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                },
                addColors: function(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                },
                addScalar: function(t) {
                    return this.r += t, this.g += t, this.b += t, this
                },
                sub: function(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                },
                multiply: function(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                },
                multiplyScalar: function(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                },
                lerp: function(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                },
                lerpHSL: function() {
                    var t = {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        e = {
                            h: 0,
                            s: 0,
                            l: 0
                        };
                    return function(n, i) {
                        this.getHSL(t), n.getHSL(e);
                        var r = xe.lerp(t.h, e.h, i),
                            o = xe.lerp(t.s, e.s, i),
                            a = xe.lerp(t.l, e.l, i);
                        return this.setHSL(r, o, a), this
                    }
                }(),
                equals: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                },
                toJSON: function() {
                    return this.getHex()
                }
            });
            var ze = {
                    common: {
                        diffuse: {
                            value: new Ue(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Ee
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new be(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new Ue(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Ue(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Ee
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Ue(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new be(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Ee
                        }
                    }
                },
                Ge = {
                    basic: {
                        uniforms: Fe.merge([ze.common, ze.specularmap, ze.envmap, ze.aomap, ze.lightmap, ze.fog]),
                        vertexShader: He.meshbasic_vert,
                        fragmentShader: He.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Fe.merge([ze.common, ze.specularmap, ze.envmap, ze.aomap, ze.lightmap, ze.emissivemap, ze.fog, ze.lights, {
                            emissive: {
                                value: new Ue(0)
                            }
                        }]),
                        vertexShader: He.meshlambert_vert,
                        fragmentShader: He.meshlambert_frag
                    },
                    phong: {
                        uniforms: Fe.merge([ze.common, ze.specularmap, ze.envmap, ze.aomap, ze.lightmap, ze.emissivemap, ze.bumpmap, ze.normalmap, ze.displacementmap, ze.gradientmap, ze.fog, ze.lights, {
                            emissive: {
                                value: new Ue(0)
                            },
                            specular: {
                                value: new Ue(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: He.meshphong_vert,
                        fragmentShader: He.meshphong_frag
                    },
                    standard: {
                        uniforms: Fe.merge([ze.common, ze.envmap, ze.aomap, ze.lightmap, ze.emissivemap, ze.bumpmap, ze.normalmap, ze.displacementmap, ze.roughnessmap, ze.metalnessmap, ze.fog, ze.lights, {
                            emissive: {
                                value: new Ue(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: He.meshphysical_vert,
                        fragmentShader: He.meshphysical_frag
                    },
                    matcap: {
                        uniforms: Fe.merge([ze.common, ze.bumpmap, ze.normalmap, ze.displacementmap, ze.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: He.meshmatcap_vert,
                        fragmentShader: He.meshmatcap_frag
                    },
                    points: {
                        uniforms: Fe.merge([ze.points, ze.fog]),
                        vertexShader: He.points_vert,
                        fragmentShader: He.points_frag
                    },
                    dashed: {
                        uniforms: Fe.merge([ze.common, ze.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: He.linedashed_vert,
                        fragmentShader: He.linedashed_frag
                    },
                    depth: {
                        uniforms: Fe.merge([ze.common, ze.displacementmap]),
                        vertexShader: He.depth_vert,
                        fragmentShader: He.depth_frag
                    },
                    normal: {
                        uniforms: Fe.merge([ze.common, ze.bumpmap, ze.normalmap, ze.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: He.normal_vert,
                        fragmentShader: He.normal_frag
                    },
                    sprite: {
                        uniforms: Fe.merge([ze.sprite, ze.fog]),
                        vertexShader: He.sprite_vert,
                        fragmentShader: He.sprite_frag
                    },
                    background: {
                        uniforms: {
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: He.background_vert,
                        fragmentShader: He.background_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: He.cube_vert,
                        fragmentShader: He.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: He.equirect_vert,
                        fragmentShader: He.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Fe.merge([ze.common, ze.displacementmap, {
                            referencePosition: {
                                value: new Te
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: He.distanceRGBA_vert,
                        fragmentShader: He.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Fe.merge([ze.lights, ze.fog, {
                            color: {
                                value: new Ue(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: He.shadow_vert,
                        fragmentShader: He.shadow_frag
                    }
                };

            function je() {
                var t = null,
                    e = !1,
                    n = null;

                function i(r, o) {
                    !1 !== e && (n(r, o), t.requestAnimationFrame(i))
                }
                return {
                    start: function() {
                        !0 !== e && null !== n && (t.requestAnimationFrame(i), e = !0)
                    },
                    stop: function() {
                        e = !1
                    },
                    setAnimationLoop: function(t) {
                        n = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function Ve(t) {
                var e = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var i = e.get(n);
                        i && (t.deleteBuffer(i.buffer), e.delete(n))
                    },
                    update: function(n, i) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var r = e.get(n);
                        void 0 === r ? e.set(n, function(e, n) {
                            var i = e.array,
                                r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                                o = t.createBuffer();
                            t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback();
                            var a = t.FLOAT;
                            return i instanceof Float32Array ? a = t.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = t.UNSIGNED_SHORT : i instanceof Int16Array ? a = t.SHORT : i instanceof Uint32Array ? a = t.UNSIGNED_INT : i instanceof Int32Array ? a = t.INT : i instanceof Int8Array ? a = t.BYTE : i instanceof Uint8Array && (a = t.UNSIGNED_BYTE), {
                                buffer: o,
                                type: a,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(n, i)) : r.version < n.version && (function(e, n, i) {
                            var r = n.array,
                                o = n.updateRange;
                            t.bindBuffer(i, e), !1 === n.dynamic ? t.bufferData(i, r, t.STATIC_DRAW) : -1 === o.count ? t.bufferSubData(i, 0, r) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(i, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(r.buffer, n, i), r.version = n.version)
                    }
                }
            }

            function We(t, e, n, i, r, o) {
                this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new Te, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Ue, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
            }

            function Xe(t, e, n, i) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || Xe.DefaultOrder
            }

            function qe() {
                this.mask = 1
            }
            Ge.physical = {
                uniforms: Fe.merge([Ge.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: He.meshphysical_vert,
                fragmentShader: He.meshphysical_frag
            }, Object.assign(We.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (var e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            }), Xe.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Xe.DefaultOrder = "XYZ", Object.defineProperties(Xe.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(t) {
                        this._order = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(Xe.prototype, {
                isEuler: !0,
                set: function(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t, e, n) {
                    var i = xe.clamp,
                        r = t.elements,
                        o = r[0],
                        a = r[4],
                        s = r[8],
                        c = r[1],
                        l = r[5],
                        h = r[9],
                        u = r[2],
                        p = r[6],
                        d = r[10];
                    return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(h, -1, 1)), Math.abs(h) < .99999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === e ? (this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math.asin(-i(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-h, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== n && this.onChangeCallback(), this
                },
                setFromQuaternion: function() {
                    var t = new we;
                    return function(e, n, i) {
                        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, n, i)
                    }
                }(),
                setFromVector3: function(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                },
                reorder: function() {
                    var t = new Me;
                    return function(e) {
                        return t.setFromEuler(this), this.setFromQuaternion(t, e)
                    }
                }(),
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                },
                fromArray: function(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                },
                toVector3: function(t) {
                    return t ? t.set(this._x, this._y, this._z) : new Te(this._x, this._y, this._z)
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(qe.prototype, {
                set: function(t) {
                    this.mask = 1 << t | 0
                },
                enable: function(t) {
                    this.mask |= 1 << t | 0
                },
                toggle: function(t) {
                    this.mask ^= 1 << t | 0
                },
                disable: function(t) {
                    this.mask &= ~(1 << t | 0)
                },
                test: function(t) {
                    return 0 != (this.mask & t.mask)
                }
            });
            var Ye = 0;

            function Ze() {
                Object.defineProperty(this, "id", {
                    value: Ye++
                }), this.uuid = xe.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ze.DefaultUp.clone();
                var t = new Te,
                    e = new Xe,
                    n = new Me,
                    i = new Te(1, 1, 1);
                e.onChange(function() {
                    n.setFromEuler(e, !1)
                }), n.onChange(function() {
                    e.setFromQuaternion(n, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new we
                    },
                    normalMatrix: {
                        value: new Ee
                    }
                }), this.matrix = new we, this.matrixWorld = new we, this.matrixAutoUpdate = Ze.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new qe, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
            Ze.DefaultUp = new Te(0, 1, 0), Ze.DefaultMatrixAutoUpdate = !0, Ze.prototype = Object.assign(Object.create(e.prototype), {
                constructor: Ze,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(t) {
                    this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function() {
                    var t = new Me;
                    return function(e, n) {
                        return t.setFromAxisAngle(e, n), this.quaternion.multiply(t), this
                    }
                }(),
                rotateOnWorldAxis: function() {
                    var t = new Me;
                    return function(e, n) {
                        return t.setFromAxisAngle(e, n), this.quaternion.premultiply(t), this
                    }
                }(),
                rotateX: function() {
                    var t = new Te(1, 0, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateY: function() {
                    var t = new Te(0, 1, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateZ: function() {
                    var t = new Te(0, 0, 1);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                translateOnAxis: function() {
                    var t = new Te;
                    return function(e, n) {
                        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(n)), this
                    }
                }(),
                translateX: function() {
                    var t = new Te(1, 0, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateY: function() {
                    var t = new Te(0, 1, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateZ: function() {
                    var t = new Te(0, 0, 1);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var t = new we;
                    return function(e) {
                        return e.applyMatrix4(t.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var t = new Me,
                        e = new we,
                        n = new Te,
                        i = new Te;
                    return function(r, o, a) {
                        r.isVector3 ? n.copy(r) : n.set(r, o, a);
                        var s = this.parent;
                        this.updateWorldMatrix(!0, !1), i.setFromMatrixPosition(this.matrixWorld), this.isCamera ? e.lookAt(i, n, this.up) : e.lookAt(n, i, this.up), this.quaternion.setFromRotationMatrix(e), s && (e.extractRotation(s.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()))
                    }
                }(),
                add: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                        type: "added"
                    }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    var n = this.children.indexOf(t);
                    return -1 !== n && (t.parent = null, t.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(n, 1)), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (var n = 0, i = this.children.length; n < i; n++) {
                        var r = this.children[n],
                            o = r.getObjectByProperty(t, e);
                        if (void 0 !== o) return o
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Te), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var t = new Te,
                        e = new Te;
                    return function(n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), n = new Me), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, n, e), n
                    }
                }(),
                getWorldScale: function() {
                    var t = new Te,
                        e = new Me;
                    return function(n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new Te), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n
                    }
                }(),
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Te), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 !== this.visible) {
                        t(this);
                        for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    var n = this.parent;
                    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                        for (var i = this.children, r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0)
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t,
                        n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var i = {};

                    function r(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(t.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, c = a.length; s < c; s++) {
                                    var l = a[s];
                                    r(t.shapes, l)
                                } else r(t.shapes, a)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            for (var h = [], s = 0, c = this.material.length; s < c; s++) h.push(r(t.materials, this.material[s]));
                            i.material = h
                        } else i.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (var s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(t).object)
                    }
                    if (e) {
                        var u = m(t.geometries),
                            p = m(t.materials),
                            d = m(t.textures),
                            f = m(t.images),
                            a = m(t.shapes);
                        u.length > 0 && (n.geometries = u), p.length > 0 && (n.materials = p), d.length > 0 && (n.textures = d), f.length > 0 && (n.images = f), a.length > 0 && (n.shapes = a)
                    }
                    return n.object = i, n;

                    function m(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (var n = 0; n < t.children.length; n++) {
                            var i = t.children[n];
                            this.add(i.clone())
                        }
                    return this
                }
            });
            var Je = 0;

            function Ke() {
                Object.defineProperty(this, "id", {
                    value: Je += 2
                }), this.uuid = xe.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Qe(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function $e(t, e, n) {
                Qe.call(this, new Int8Array(t), e, n)
            }

            function tn(t, e, n) {
                Qe.call(this, new Uint8Array(t), e, n)
            }

            function en(t, e, n) {
                Qe.call(this, new Uint8ClampedArray(t), e, n)
            }

            function nn(t, e, n) {
                Qe.call(this, new Int16Array(t), e, n)
            }

            function rn(t, e, n) {
                Qe.call(this, new Uint16Array(t), e, n)
            }

            function on(t, e, n) {
                Qe.call(this, new Int32Array(t), e, n)
            }

            function an(t, e, n) {
                Qe.call(this, new Uint32Array(t), e, n)
            }

            function sn(t, e, n) {
                Qe.call(this, new Float32Array(t), e, n)
            }

            function cn(t, e, n) {
                Qe.call(this, new Float64Array(t), e, n)
            }

            function ln() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function hn(t) {
                if (0 === t.length) return -1 / 0;
                for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
                return e
            }
            Ke.prototype = Object.assign(Object.create(e.prototype), {
                constructor: Ke,
                isGeometry: !0,
                applyMatrix: function(t) {
                    for (var e = (new Ee).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                        var r = this.vertices[n];
                        r.applyMatrix4(t)
                    }
                    for (var n = 0, i = this.faces.length; n < i; n++) {
                        var o = this.faces[n];
                        o.normal.applyMatrix3(e).normalize();
                        for (var a = 0, s = o.vertexNormals.length; a < s; a++) o.vertexNormals[a].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function() {
                    var t = new we;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new we;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new we;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new we;
                    return function(e, n, i) {
                        return t.makeTranslation(e, n, i), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new we;
                    return function(e, n, i) {
                        return t.makeScale(e, n, i), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new Ze;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                fromBufferGeometry: function(t) {
                    var e = this,
                        n = null !== t.index ? t.index.array : void 0,
                        i = t.attributes,
                        r = i.position.array,
                        o = void 0 !== i.normal ? i.normal.array : void 0,
                        a = void 0 !== i.color ? i.color.array : void 0,
                        s = void 0 !== i.uv ? i.uv.array : void 0,
                        c = void 0 !== i.uv2 ? i.uv2.array : void 0;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (var l = [], h = [], u = [], p = 0, d = 0; p < r.length; p += 3, d += 2) e.vertices.push(new Te(r[p], r[p + 1], r[p + 2])), void 0 !== o && l.push(new Te(o[p], o[p + 1], o[p + 2])), void 0 !== a && e.colors.push(new Ue(a[p], a[p + 1], a[p + 2])), void 0 !== s && h.push(new be(s[d], s[d + 1])), void 0 !== c && u.push(new be(c[d], c[d + 1]));

                    function f(t, n, i, r) {
                        var p = void 0 !== o ? [l[t].clone(), l[n].clone(), l[i].clone()] : [],
                            d = void 0 !== a ? [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()] : [],
                            f = new We(t, n, i, p, d, r);
                        e.faces.push(f), void 0 !== s && e.faceVertexUvs[0].push([h[t].clone(), h[n].clone(), h[i].clone()]), void 0 !== c && e.faceVertexUvs[1].push([u[t].clone(), u[n].clone(), u[i].clone()])
                    }
                    var m = t.groups;
                    if (m.length > 0)
                        for (var p = 0; p < m.length; p++)
                            for (var v = m[p], g = v.start, y = v.count, d = g, _ = g + y; d < _; d += 3) void 0 !== n ? f(n[d], n[d + 1], n[d + 2], v.materialIndex) : f(d, d + 1, d + 2, v.materialIndex);
                    else if (void 0 !== n)
                        for (var p = 0; p < n.length; p += 3) f(n[p], n[p + 1], n[p + 2]);
                    else
                        for (var p = 0; p < r.length / 3; p += 3) f(p, p + 1, p + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    var t = new Te;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        n = 0 === e ? 1 : 1 / e,
                        i = new we;
                    return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
                },
                computeFaceNormals: function() {
                    for (var t = new Te, e = new Te, n = 0, i = this.faces.length; n < i; n++) {
                        var r = this.faces[n],
                            o = this.vertices[r.a],
                            a = this.vertices[r.b],
                            s = this.vertices[r.c];
                        t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), r.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    var e, n, i, r, o, a;
                    for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) a[e] = new Te;
                    if (t) {
                        var s, c, l, h = new Te,
                            u = new Te;
                        for (i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], s = this.vertices[o.a], c = this.vertices[o.b], l = this.vertices[o.c], h.subVectors(l, c), u.subVectors(s, c), h.cross(u), a[o.a].add(h), a[o.b].add(h), a[o.c].add(h)
                    } else
                        for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], a[o.a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                    for (e = 0, n = this.vertices.length; e < n; e++) a[e].normalize();
                    for (i = 0, r = this.faces.length; i < r; i++) {
                        var p = (o = this.faces[i]).vertexNormals;
                        3 === p.length ? (p[0].copy(a[o.a]), p[1].copy(a[o.b]), p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(), p[1] = a[o.b].clone(), p[2] = a[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var t, e, n;
                    for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                        var i = (n = this.faces[t]).vertexNormals;
                        3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var t, e, n, i, r;
                    for (n = 0, i = this.faces.length; n < i; n++)
                        for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                    var o = new Ke;
                    for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                            var a = this.morphNormals[t].faceNormals,
                                s = this.morphNormals[t].vertexNormals;
                            for (n = 0, i = this.faces.length; n < i; n++) c = new Te, l = {
                                a: new Te,
                                b: new Te,
                                c: new Te
                            }, a.push(c), s.push(l)
                        }
                        var c, l, h = this.morphNormals[t];
                        for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], c = h.faceNormals[n], l = h.vertexNormals[n], c.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2])
                    }
                    for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Ie), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new De), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, n) {
                    if (t && t.isGeometry) {
                        var i, r = this.vertices.length,
                            o = this.vertices,
                            a = t.vertices,
                            s = this.faces,
                            c = t.faces,
                            l = this.faceVertexUvs[0],
                            h = t.faceVertexUvs[0],
                            u = this.colors,
                            p = t.colors;
                        void 0 === n && (n = 0), void 0 !== e && (i = (new Ee).getNormalMatrix(e));
                        for (var d = 0, f = a.length; d < f; d++) {
                            var m = a[d],
                                v = m.clone();
                            void 0 !== e && v.applyMatrix4(e), o.push(v)
                        }
                        for (var d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
                        for (d = 0, f = c.length; d < f; d++) {
                            var g, y, _, x = c[d],
                                b = x.vertexNormals,
                                w = x.vertexColors;
                            (g = new We(x.a + r, x.b + r, x.c + r)).normal.copy(x.normal), void 0 !== i && g.normal.applyMatrix3(i).normalize();
                            for (var M = 0, T = b.length; M < T; M++) y = b[M].clone(), void 0 !== i && y.applyMatrix3(i).normalize(), g.vertexNormals.push(y);
                            g.color.copy(x.color);
                            for (var M = 0, T = w.length; M < T; M++) _ = w[M], g.vertexColors.push(_.clone());
                            g.materialIndex = x.materialIndex + n, s.push(g)
                        }
                        for (d = 0, f = h.length; d < f; d++) {
                            var E = h[d],
                                S = [];
                            if (void 0 !== E) {
                                for (var M = 0, T = E.length; M < T; M++) S.push(E[M].clone());
                                l.push(S)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    var t, e, n, i, r, o, a, s, c = {},
                        l = [],
                        h = [],
                        u = Math.pow(10, 4);
                    for (n = 0, i = this.vertices.length; n < i; n++) t = this.vertices[n], e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u), void 0 === c[e] ? (c[e] = n, l.push(this.vertices[n]), h[n] = l.length - 1) : h[n] = h[c[e]];
                    var p = [];
                    for (n = 0, i = this.faces.length; n < i; n++) {
                        (r = this.faces[n]).a = h[r.a], r.b = h[r.b], r.c = h[r.c], o = [r.a, r.b, r.c];
                        for (var d = 0; d < 3; d++)
                            if (o[d] === o[(d + 1) % 3]) {
                                p.push(n);
                                break
                            }
                    }
                    for (n = p.length - 1; n >= 0; n--) {
                        var f = p[n];
                        for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                    }
                    var m = this.vertices.length - l.length;
                    return this.vertices = l, m
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (var e = 0, n = t.length; e < n; e++) {
                        var i = t[e];
                        this.vertices.push(new Te(i.x, i.y, i.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
                    t.sort(function(t, e) {
                        return t.materialIndex - e.materialIndex
                    });
                    var i, r, o = this.faceVertexUvs[0],
                        a = this.faceVertexUvs[1];
                    o && o.length === e && (i = []), a && a.length === e && (r = []);
                    for (var n = 0; n < e; n++) {
                        var s = t[n]._id;
                        i && i.push(o[s]), r && r.push(a[s])
                    }
                    i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    for (var i = [], r = 0; r < this.vertices.length; r++) {
                        var o = this.vertices[r];
                        i.push(o.x, o.y, o.z)
                    }
                    for (var a = [], s = [], c = {}, l = [], h = {}, u = [], p = {}, r = 0; r < this.faces.length; r++) {
                        var d = this.faces[r],
                            f = void 0 !== this.faceVertexUvs[0][r],
                            m = d.normal.length() > 0,
                            v = d.vertexNormals.length > 0,
                            g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                            y = d.vertexColors.length > 0,
                            _ = 0;
                        if (_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, v), 6, g), 7, y), a.push(_), a.push(d.a, d.b, d.c), a.push(d.materialIndex), f) {
                            var x = this.faceVertexUvs[0][r];
                            a.push(S(x[0]), S(x[1]), S(x[2]))
                        }
                        if (m && a.push(T(d.normal)), v) {
                            var b = d.vertexNormals;
                            a.push(T(b[0]), T(b[1]), T(b[2]))
                        }
                        if (g && a.push(E(d.color)), y) {
                            var w = d.vertexColors;
                            a.push(E(w[0]), E(w[1]), E(w[2]))
                        }
                    }

                    function M(t, e, n) {
                        return n ? t | 1 << e : t & ~(1 << e)
                    }

                    function T(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e])
                    }

                    function E(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== h[e] ? h[e] : (h[e] = l.length, l.push(t.getHex()), h[e])
                    }

                    function S(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== p[e] ? p[e] : (p[e] = u.length / 2, u.push(t.x, t.y), p[e])
                    }
                    return t.data = {}, t.data.vertices = i, t.data.normals = s, l.length > 0 && (t.data.colors = l), u.length > 0 && (t.data.uvs = [u]), t.data.faces = a, t
                },
                clone: function() {
                    return (new Ke).copy(this)
                },
                copy: function(t) {
                    var e, n, i, r, o, a;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var s = t.vertices;
                    for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
                    var c = t.colors;
                    for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
                    var l = t.faces;
                    for (e = 0, n = l.length; e < n; e++) this.faces.push(l[e].clone());
                    for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                        var h = t.faceVertexUvs[e];
                        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = h.length; i < r; i++) {
                            var u = h[i],
                                p = [];
                            for (o = 0, a = u.length; o < a; o++) {
                                var d = u[o];
                                p.push(d.clone())
                            }
                            this.faceVertexUvs[e].push(p)
                        }
                    }
                    var f = t.morphTargets;
                    for (e = 0, n = f.length; e < n; e++) {
                        var m = {};
                        if (m.name = f[e].name, void 0 !== f[e].vertices)
                            for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++) m.vertices.push(f[e].vertices[i].clone());
                        if (void 0 !== f[e].normals)
                            for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++) m.normals.push(f[e].normals[i].clone());
                        this.morphTargets.push(m)
                    }
                    var v = t.morphNormals;
                    for (e = 0, n = v.length; e < n; e++) {
                        var g = {};
                        if (void 0 !== v[e].vertexNormals)
                            for (g.vertexNormals = [], i = 0, r = v[e].vertexNormals.length; i < r; i++) {
                                var y = v[e].vertexNormals[i],
                                    _ = {};
                                _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), g.vertexNormals.push(_)
                            }
                        if (void 0 !== v[e].faceNormals)
                            for (g.faceNormals = [], i = 0, r = v[e].faceNormals.length; i < r; i++) g.faceNormals.push(v[e].faceNormals[i].clone());
                        this.morphNormals.push(g)
                    }
                    var x = t.skinWeights;
                    for (e = 0, n = x.length; e < n; e++) this.skinWeights.push(x[e].clone());
                    var b = t.skinIndices;
                    for (e = 0, n = b.length; e < n; e++) this.skinIndices.push(b[e].clone());
                    var w = t.lineDistances;
                    for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
                    var M = t.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var T = t.boundingSphere;
                    return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(Qe.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Qe.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize, n *= e.itemSize;
                    for (var i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), o = new Ue), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), o = new be), e[n++] = o.x, e[n++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), o = new Te), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), o = new Le), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w
                    }
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), $e.prototype = Object.create(Qe.prototype), $e.prototype.constructor = $e, tn.prototype = Object.create(Qe.prototype), tn.prototype.constructor = tn, en.prototype = Object.create(Qe.prototype), en.prototype.constructor = en, nn.prototype = Object.create(Qe.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(Qe.prototype), rn.prototype.constructor = rn, on.prototype = Object.create(Qe.prototype), on.prototype.constructor = on, an.prototype = Object.create(Qe.prototype), an.prototype.constructor = an, sn.prototype = Object.create(Qe.prototype), sn.prototype.constructor = sn, cn.prototype = Object.create(Qe.prototype), cn.prototype.constructor = cn, Object.assign(ln.prototype, {
                computeGroups: function(t) {
                    for (var e, n = [], i = void 0, r = t.faces, o = 0; o < r.length; o++) {
                        var a = r[o];
                        a.materialIndex !== i && (i = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), e = {
                            start: 3 * o,
                            materialIndex: i
                        })
                    }
                    void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), this.groups = n
                },
                fromGeometry: function(t) {
                    var e, n = t.faces,
                        i = t.vertices,
                        r = t.faceVertexUvs,
                        o = r[0] && r[0].length > 0,
                        a = r[1] && r[1].length > 0,
                        s = t.morphTargets,
                        c = s.length;
                    if (c > 0) {
                        e = [];
                        for (var l = 0; l < c; l++) e[l] = {
                            name: s[l].name,
                            data: []
                        };
                        this.morphTargets.position = e
                    }
                    var h, u = t.morphNormals,
                        p = u.length;
                    if (p > 0) {
                        h = [];
                        for (var l = 0; l < p; l++) h[l] = {
                            name: u[l].name,
                            data: []
                        };
                        this.morphTargets.normal = h
                    }
                    var d = t.skinIndices,
                        f = t.skinWeights,
                        m = d.length === i.length,
                        v = f.length === i.length;
                    i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (var l = 0; l < n.length; l++) {
                        var g = n[l];
                        this.vertices.push(i[g.a], i[g.b], i[g.c]);
                        var y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var _ = g.normal;
                            this.normals.push(_, _, _)
                        }
                        var x = g.vertexColors;
                        if (3 === x.length) this.colors.push(x[0], x[1], x[2]);
                        else {
                            var b = g.color;
                            this.colors.push(b, b, b)
                        }
                        if (!0 === o) {
                            var w = r[0][l];
                            void 0 !== w ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new be, new be, new be))
                        }
                        if (!0 === a) {
                            var w = r[1][l];
                            void 0 !== w ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new be, new be, new be))
                        }
                        for (var M = 0; M < c; M++) {
                            var T = s[M].vertices;
                            e[M].data.push(T[g.a], T[g.b], T[g.c])
                        }
                        for (var M = 0; M < p; M++) {
                            var E = u[M].vertexNormals[l];
                            h[M].data.push(E.a, E.b, E.c)
                        }
                        m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                }
            });
            var un = 1;

            function pn() {
                Object.defineProperty(this, "id", {
                    value: un += 2
                }), this.uuid = xe.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            function dn(t, e, n, i, r, o) {
                Ke.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: o
                }, this.fromBufferGeometry(new fn(t, e, n, i, r, o)), this.mergeVertices()
            }

            function fn(t, e, n, i, r, o) {
                pn.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: o
                };
                var a = this;
                t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
                var s = [],
                    c = [],
                    l = [],
                    h = [],
                    u = 0,
                    p = 0;

                function d(t, e, n, i, r, o, d, f, m, v, g) {
                    var y, _, x = o / m,
                        b = d / v,
                        w = o / 2,
                        M = d / 2,
                        T = f / 2,
                        E = m + 1,
                        S = v + 1,
                        A = 0,
                        P = 0,
                        L = new Te;
                    for (_ = 0; _ < S; _++) {
                        var R = _ * b - M;
                        for (y = 0; y < E; y++) {
                            var C = y * x - w;
                            L[t] = C * i, L[e] = R * r, L[n] = T, c.push(L.x, L.y, L.z), L[t] = 0, L[e] = 0, L[n] = f > 0 ? 1 : -1, l.push(L.x, L.y, L.z), h.push(y / m), h.push(1 - _ / v), A += 1
                        }
                    }
                    for (_ = 0; _ < v; _++)
                        for (y = 0; y < m; y++) {
                            var O = u + y + E * _,
                                I = u + y + E * (_ + 1),
                                D = u + (y + 1) + E * (_ + 1),
                                N = u + (y + 1) + E * _;
                            s.push(O, I, N), s.push(I, D, N), P += 6
                        }
                    a.addGroup(p, P, g), p += P, u += A
                }
                d("z", "y", "x", -1, -1, n, e, t, o, r, 0), d("z", "y", "x", 1, -1, n, e, -t, o, r, 1), d("x", "z", "y", 1, 1, t, n, e, i, o, 2), d("x", "z", "y", 1, -1, t, n, -e, i, o, 3), d("x", "y", "z", 1, -1, t, e, n, i, r, 4), d("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(s), this.addAttribute("position", new sn(c, 3)), this.addAttribute("normal", new sn(l, 3)), this.addAttribute("uv", new sn(h, 2))
            }

            function mn(t, e, n, i) {
                Ke.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                }, this.fromBufferGeometry(new vn(t, e, n, i)), this.mergeVertices()
            }

            function vn(t, e, n, i) {
                pn.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                var r, o, a = (t = t || 1) / 2,
                    s = (e = e || 1) / 2,
                    c = Math.floor(n) || 1,
                    l = Math.floor(i) || 1,
                    h = c + 1,
                    u = l + 1,
                    p = t / c,
                    d = e / l,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (o = 0; o < u; o++) {
                    var y = o * d - s;
                    for (r = 0; r < h; r++) {
                        var _ = r * p - a;
                        m.push(_, -y, 0), v.push(0, 0, 1), g.push(r / c), g.push(1 - o / l)
                    }
                }
                for (o = 0; o < l; o++)
                    for (r = 0; r < c; r++) {
                        var x = r + h * o,
                            b = r + h * (o + 1),
                            w = r + 1 + h * (o + 1),
                            M = r + 1 + h * o;
                        f.push(x, b, M), f.push(b, w, M)
                    }
                this.setIndex(f), this.addAttribute("position", new sn(m, 3)), this.addAttribute("normal", new sn(v, 3)), this.addAttribute("uv", new sn(g, 2))
            }
            pn.prototype = Object.assign(Object.create(e.prototype), {
                constructor: pn,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    Array.isArray(t) ? this.index = new(hn(t) > 65535 ? an : rn)(t, 1) : this.index = t
                },
                addAttribute: function(t, e) {
                    return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new Qe(arguments[1], arguments[2])))
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                removeAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, n) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                    var n = this.attributes.normal;
                    if (void 0 !== n) {
                        var i = (new Ee).getNormalMatrix(t);
                        i.applyToBufferAttribute(n), n.needsUpdate = !0
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function() {
                    var t = new we;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new we;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new we;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new we;
                    return function(e, n, i) {
                        return t.makeTranslation(e, n, i), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new we;
                    return function(e, n, i) {
                        return t.makeScale(e, n, i), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new Ze;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                center: function() {
                    var t = new Te;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                setFromObject: function(t) {
                    var e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        var n = new sn(3 * e.vertices.length, 3),
                            i = new sn(3 * e.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            var r = new sn(e.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    for (var e = [], n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.addAttribute("position", new sn(e, 3)), this
                },
                updateFromObject: function(t) {
                    var e, n = t.geometry;
                    if (t.isMesh) {
                        var i = n.__directGeometry;
                        if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n);
                        i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i
                    }
                    return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new ln).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e = new Float32Array(3 * t.vertices.length);
                    if (this.addAttribute("position", new Qe(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        var n = new Float32Array(3 * t.normals.length);
                        this.addAttribute("normal", new Qe(n, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        var i = new Float32Array(3 * t.colors.length);
                        this.addAttribute("color", new Qe(i, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        var r = new Float32Array(2 * t.uvs.length);
                        this.addAttribute("uv", new Qe(r, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        var o = new Float32Array(2 * t.uvs2.length);
                        this.addAttribute("uv2", new Qe(o, 2).copyVector2sArray(t.uvs2))
                    }
                    for (var a in this.groups = t.groups, t.morphTargets) {
                        for (var s = [], c = t.morphTargets[a], l = 0, h = c.length; l < h; l++) {
                            var u = c[l],
                                p = new sn(3 * u.data.length, 3);
                            p.name = u.name, s.push(p.copyVector3sArray(u.data))
                        }
                        this.morphAttributes[a] = s
                    }
                    if (t.skinIndices.length > 0) {
                        var d = new sn(4 * t.skinIndices.length, 4);
                        this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        var f = new sn(4 * t.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Ie);
                    var t = this.attributes.position;
                    void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    var t = new Ie,
                        e = new Te;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new De);
                        var n = this.attributes.position;
                        if (n) {
                            var i = this.boundingSphere.center;
                            t.setFromBufferAttribute(n), t.getCenter(i);
                            for (var r = 0, o = 0, a = n.count; o < a; o++) e.x = n.getX(o), e.y = n.getY(o), e.z = n.getZ(o), r = Math.max(r, i.distanceToSquared(e));
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index,
                        e = this.attributes;
                    if (e.position) {
                        var n = e.position.array;
                        if (void 0 === e.normal) this.addAttribute("normal", new Qe(new Float32Array(n.length), 3));
                        else
                            for (var i = e.normal.array, r = 0, o = i.length; r < o; r++) i[r] = 0;
                        var a, s, c, l = e.normal.array,
                            h = new Te,
                            u = new Te,
                            p = new Te,
                            d = new Te,
                            f = new Te;
                        if (t)
                            for (var m = t.array, r = 0, o = t.count; r < o; r += 3) a = 3 * m[r + 0], s = 3 * m[r + 1], c = 3 * m[r + 2], h.fromArray(n, a), u.fromArray(n, s), p.fromArray(n, c), d.subVectors(p, u), f.subVectors(h, u), d.cross(f), l[a] += d.x, l[a + 1] += d.y, l[a + 2] += d.z, l[s] += d.x, l[s + 1] += d.y, l[s + 2] += d.z, l[c] += d.x, l[c + 1] += d.y, l[c + 2] += d.z;
                        else
                            for (var r = 0, o = n.length; r < o; r += 9) h.fromArray(n, r), u.fromArray(n, r + 3), p.fromArray(n, r + 6), d.subVectors(p, u), f.subVectors(h, u), d.cross(f), l[r] = d.x, l[r + 1] = d.y, l[r + 2] = d.z, l[r + 3] = d.x, l[r + 4] = d.y, l[r + 5] = d.z, l[r + 6] = d.x, l[r + 7] = d.y, l[r + 8] = d.z;
                        this.normalizeNormals(), e.normal.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (t && t.isBufferGeometry) {
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var n = this.attributes;
                        for (var i in n)
                            if (void 0 !== t.attributes[i])
                                for (var r = n[i], o = r.array, a = t.attributes[i], s = a.array, c = a.itemSize, l = 0, h = c * e; l < s.length; l++, h++) o[h] = s[l];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
                },
                normalizeNormals: function() {
                    var t = new Te;
                    return function() {
                        for (var e = this.attributes.normal, n = 0, i = e.count; n < i; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.normalize(), e.setXYZ(n, t.x, t.y, t.z)
                    }
                }(),
                toNonIndexed: function() {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var t = new pn,
                        e = this.index.array,
                        n = this.attributes;
                    for (var i in n) {
                        for (var r = n[i], o = r.array, a = r.itemSize, s = new o.constructor(e.length * a), c = 0, l = 0, h = 0, u = e.length; h < u; h++) {
                            c = e[h] * a;
                            for (var p = 0; p < a; p++) s[l++] = o[c++]
                        }
                        t.addAttribute(i, new Qe(s, a))
                    }
                    for (var d = this.groups, h = 0, u = d.length; h < u; h++) {
                        var f = d[h];
                        t.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return t
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var i = this.index;
                    if (null !== i) {
                        var r = Array.prototype.slice.call(i.array);
                        t.data.index = {
                            type: i.array.constructor.name,
                            array: r
                        }
                    }
                    var o = this.attributes;
                    for (var n in o) {
                        var a = o[n],
                            r = Array.prototype.slice.call(a.array);
                        t.data.attributes[n] = {
                            itemSize: a.itemSize,
                            type: a.array.constructor.name,
                            array: r,
                            normalized: a.normalized
                        }
                    }
                    var s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    var c = this.boundingSphere;
                    return null !== c && (t.data.boundingSphere = {
                        center: c.center.toArray(),
                        radius: c.radius
                    }), t
                },
                clone: function() {
                    return (new pn).copy(this)
                },
                copy: function(t) {
                    var e, n, i;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var r = t.index;
                    null !== r && this.setIndex(r.clone());
                    var o = t.attributes;
                    for (e in o) {
                        var a = o[e];
                        this.addAttribute(e, a.clone())
                    }
                    var s = t.morphAttributes;
                    for (e in s) {
                        var c = [],
                            l = s[e];
                        for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
                        this.morphAttributes[e] = c
                    }
                    var h = t.groups;
                    for (n = 0, i = h.length; n < i; n++) {
                        var u = h[n];
                        this.addGroup(u.start, u.count, u.materialIndex)
                    }
                    var p = t.boundingBox;
                    null !== p && (this.boundingBox = p.clone());
                    var d = t.boundingSphere;
                    return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), dn.prototype = Object.create(Ke.prototype), dn.prototype.constructor = dn, fn.prototype = Object.create(pn.prototype), fn.prototype.constructor = fn, mn.prototype = Object.create(Ke.prototype), mn.prototype.constructor = mn, vn.prototype = Object.create(pn.prototype), vn.prototype.constructor = vn;
            var gn = 0;

            function yn() {
                Object.defineProperty(this, "id", {
                    value: gn++
                }), this.uuid = xe.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = m, this.side = c, this.flatShading = !1, this.vertexColors = u, this.opacity = 1, this.transparent = !1, this.blendSrc = L, this.blendDst = R, this.blendEquation = x, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = k, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }

            function _n(t) {
                yn.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function xn(t, e) {
                this.origin = void 0 !== t ? t : new Te, this.direction = void 0 !== e ? e : new Te
            }

            function bn(t, e, n) {
                this.a = void 0 !== t ? t : new Te, this.b = void 0 !== e ? e : new Te, this.c = void 0 !== n ? n : new Te
            }

            function wn(t) {
                yn.call(this), this.type = "MeshBasicMaterial", this.color = new Ue(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function Mn(t, e) {
                Ze.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new pn, this.material = void 0 !== e ? e : new wn({
                    color: 16777215 * Math.random()
                }), this.drawMode = ae, this.updateMorphTargets()
            }

            function Tn(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function En(t, e, n, i, r, o, a, s, c, l) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : Q, Pe.call(this, t, e, n, i, r, o, a, s, c, l), this.flipY = !1
            }

            function Sn(t, e, n, i) {
                Pe.call(this, null), this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = ct, this.minFilter = ct, this.generateMipmaps = !1, this.flipY = !1
            }
            yn.prototype = Object.assign(Object.create(e.prototype), {
                constructor: yn,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var n = t[e];
                            if (void 0 !== n)
                                if ("shading" !== e) {
                                    var i = this[e];
                                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = "overdraw" === e ? Number(n) : n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                        }
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function i(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== m && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== c && (n.side = this.side), this.vertexColors !== u && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                        var r = i(t.textures),
                            o = i(t.images);
                        r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                    var e = t.clippingPlanes,
                        n = null;
                    if (null !== e) {
                        var i = e.length;
                        n = new Array(i);
                        for (var r = 0; r !== i; ++r) n[r] = e[r].clone()
                    }
                    return this.clippingPlanes = n, this.shadowSide = t.shadowSide, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), _n.prototype = Object.create(yn.prototype), _n.prototype.constructor = _n, _n.prototype.isShaderMaterial = !0, _n.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Fe.clone(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
            }, _n.prototype.toJSON = function(t) {
                var e = yn.prototype.toJSON.call(this, t);
                for (var n in e.uniforms = {}, this.uniforms) {
                    var i = this.uniforms[n],
                        r = i.value;
                    r.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(t).uuid
                    } : r.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : e.uniforms[n] = {
                        value: r
                    }
                }
                return Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
            }, Object.assign(xn.prototype, {
                set: function(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                },
                at: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Te), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                },
                recast: function() {
                    var t = new Te;
                    return function(e) {
                        return this.origin.copy(this.at(e, t)), this
                    }
                }(),
                closestPointToPoint: function(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Te), e.subVectors(t, this.origin);
                    var n = e.dot(this.direction);
                    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: function() {
                    var t = new Te;
                    return function(e) {
                        var n = t.subVectors(e, this.origin).dot(this.direction);
                        return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin), t.distanceToSquared(e))
                    }
                }(),
                distanceSqToSegment: function() {
                    var t = new Te,
                        e = new Te,
                        n = new Te;
                    return function(i, r, o, a) {
                        t.copy(i).add(r).multiplyScalar(.5), e.copy(r).sub(i).normalize(), n.copy(this.origin).sub(t);
                        var s, c, l, h, u = .5 * i.distanceTo(r),
                            p = -this.direction.dot(e),
                            d = n.dot(this.direction),
                            f = -n.dot(e),
                            m = n.lengthSq(),
                            v = Math.abs(1 - p * p);
                        if (v > 0)
                            if (c = p * d - f, h = u * v, (s = p * f - d) >= 0)
                                if (c >= -h)
                                    if (c <= h) {
                                        var g = 1 / v;
                                        l = (s *= g) * (s + p * (c *= g) + 2 * d) + c * (p * s + c + 2 * f) + m
                                    } else c = u, s = Math.max(0, -(p * c + d)), l = -s * s + c * (c + 2 * f) + m;
                        else c = -u, s = Math.max(0, -(p * c + d)), l = -s * s + c * (c + 2 * f) + m;
                        else c <= -h ? (s = Math.max(0, -(-p * u + d)), c = s > 0 ? -u : Math.min(Math.max(-u, -f), u), l = -s * s + c * (c + 2 * f) + m) : c <= h ? (s = 0, c = Math.min(Math.max(-u, -f), u), l = c * (c + 2 * f) + m) : (s = Math.max(0, -(p * u + d)), c = s > 0 ? u : Math.min(Math.max(-u, -f), u), l = -s * s + c * (c + 2 * f) + m);
                        else c = p > 0 ? -u : u, s = Math.max(0, -(p * c + d)), l = -s * s + c * (c + 2 * f) + m;
                        return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(e).multiplyScalar(c).add(t), l
                    }
                }(),
                intersectSphere: function() {
                    var t = new Te;
                    return function(e, n) {
                        t.subVectors(e.center, this.origin);
                        var i = t.dot(this.direction),
                            r = t.dot(t) - i * i,
                            o = e.radius * e.radius;
                        if (r > o) return null;
                        var a = Math.sqrt(o - r),
                            s = i - a,
                            c = i + a;
                        return s < 0 && c < 0 ? null : s < 0 ? this.at(c, n) : this.at(s, n)
                    }
                }(),
                intersectsSphere: function(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                },
                distanceToPlane: function(t) {
                    var e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null
                },
                intersectPlane: function(t, e) {
                    var n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e)
                },
                intersectsPlane: function(t) {
                    var e = t.distanceToPoint(this.origin);
                    if (0 === e) return !0;
                    var n = t.normal.dot(this.direction);
                    return n * e < 0
                },
                intersectBox: function(t, e) {
                    var n, i, r, o, a, s, c = 1 / this.direction.x,
                        l = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return c >= 0 ? (n = (t.min.x - u.x) * c, i = (t.max.x - u.x) * c) : (n = (t.max.x - u.x) * c, i = (t.min.x - u.x) * c), l >= 0 ? (r = (t.min.y - u.y) * l, o = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, o = (t.min.y - u.y) * l), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), h >= 0 ? (a = (t.min.z - u.z) * h, s = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, s = (t.min.z - u.z) * h), n > s || a > i ? null : ((a > n || n != n) && (n = a), (s < i || i != i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                },
                intersectsBox: function() {
                    var t = new Te;
                    return function(e) {
                        return null !== this.intersectBox(e, t)
                    }
                }(),
                intersectTriangle: function() {
                    var t = new Te,
                        e = new Te,
                        n = new Te,
                        i = new Te;
                    return function(r, o, a, s, c) {
                        e.subVectors(o, r), n.subVectors(a, r), i.crossVectors(e, n);
                        var l, h = this.direction.dot(i);
                        if (h > 0) {
                            if (s) return null;
                            l = 1
                        } else {
                            if (!(h < 0)) return null;
                            l = -1, h = -h
                        }
                        t.subVectors(this.origin, r);
                        var u = l * this.direction.dot(n.crossVectors(t, n));
                        if (u < 0) return null;
                        var p = l * this.direction.dot(e.cross(t));
                        if (p < 0) return null;
                        if (u + p > h) return null;
                        var d = -l * t.dot(i);
                        return d < 0 ? null : this.at(d / h, c)
                    }
                }(),
                applyMatrix4: function(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                },
                equals: function(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            }), Object.assign(bn, {
                getNormal: function() {
                    var t = new Te;
                    return function(e, n, i, r) {
                        void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new Te), r.subVectors(i, n), t.subVectors(e, n), r.cross(t);
                        var o = r.lengthSq();
                        return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0)
                    }
                }(),
                getBarycoord: function() {
                    var t = new Te,
                        e = new Te,
                        n = new Te;
                    return function(i, r, o, a, s) {
                        t.subVectors(a, r), e.subVectors(o, r), n.subVectors(i, r);
                        var c = t.dot(t),
                            l = t.dot(e),
                            h = t.dot(n),
                            u = e.dot(e),
                            p = e.dot(n),
                            d = c * u - l * l;
                        if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new Te), 0 === d) return s.set(-2, -1, -1);
                        var f = 1 / d,
                            m = (u * h - l * p) * f,
                            v = (c * p - l * h) * f;
                        return s.set(1 - m - v, v, m)
                    }
                }(),
                containsPoint: function() {
                    var t = new Te;
                    return function(e, n, i, r) {
                        return bn.getBarycoord(e, n, i, r, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
                    }
                }(),
                getUV: function() {
                    var t = new Te;
                    return function(e, n, i, r, o, a, s, c) {
                        return this.getBarycoord(e, n, i, r, t), c.set(0, 0), c.addScaledVector(o, t.x), c.addScaledVector(a, t.y), c.addScaledVector(s, t.z), c
                    }
                }()
            }), Object.assign(bn.prototype, {
                set: function(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                },
                setFromPointsAndIndices: function(t, e, n, i) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                },
                getArea: function() {
                    var t = new Te,
                        e = new Te;
                    return function() {
                        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                    }
                }(),
                getMidpoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Te), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function(t) {
                    return bn.getNormal(this.a, this.b, this.c, t)
                },
                getPlane: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Te), t.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function(t, e) {
                    return bn.getBarycoord(t, this.a, this.b, this.c, e)
                },
                containsPoint: function(t) {
                    return bn.containsPoint(t, this.a, this.b, this.c)
                },
                getUV: function(t, e, n, i, r) {
                    return bn.getUV(t, this.a, this.b, this.c, e, n, i, r)
                },
                intersectsBox: function(t) {
                    return t.intersectsTriangle(this)
                },
                closestPointToPoint: function() {
                    var t = new Te,
                        e = new Te,
                        n = new Te,
                        i = new Te,
                        r = new Te,
                        o = new Te;
                    return function(a, s) {
                        void 0 === s && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), s = new Te);
                        var c, l, h = this.a,
                            u = this.b,
                            p = this.c;
                        t.subVectors(u, h), e.subVectors(p, h), i.subVectors(a, h);
                        var d = t.dot(i),
                            f = e.dot(i);
                        if (d <= 0 && f <= 0) return s.copy(h);
                        r.subVectors(a, u);
                        var m = t.dot(r),
                            v = e.dot(r);
                        if (m >= 0 && v <= m) return s.copy(u);
                        var g = d * v - m * f;
                        if (g <= 0 && d >= 0 && m <= 0) return c = d / (d - m), s.copy(h).addScaledVector(t, c);
                        o.subVectors(a, p);
                        var y = t.dot(o),
                            _ = e.dot(o);
                        if (_ >= 0 && y <= _) return s.copy(p);
                        var x = y * f - d * _;
                        if (x <= 0 && f >= 0 && _ <= 0) return l = f / (f - _), s.copy(h).addScaledVector(e, l);
                        var b = m * _ - y * v;
                        if (b <= 0 && v - m >= 0 && y - _ >= 0) return n.subVectors(p, u), l = (v - m) / (v - m + (y - _)), s.copy(u).addScaledVector(n, l);
                        var w = 1 / (b + x + g);
                        return c = x * w, l = g * w, s.copy(h).addScaledVector(t, c).addScaledVector(e, l)
                    }
                }(),
                equals: function(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }), wn.prototype = Object.create(yn.prototype), wn.prototype.constructor = wn, wn.prototype.isMeshBasicMaterial = !0, wn.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            }, Mn.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: Mn,
                isMesh: !0,
                setDrawMode: function(t) {
                    this.drawMode = t
                },
                copy: function(t) {
                    return Ze.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
                },
                updateMorphTargets: function() {
                    var t, e, n, i = this.geometry;
                    if (i.isBufferGeometry) {
                        var r = i.morphAttributes,
                            o = Object.keys(r);
                        if (o.length > 0) {
                            var a = r[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) n = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    } else {
                        var s = i.morphTargets;
                        if (void 0 !== s && s.length > 0)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                    }
                },
                raycast: function() {
                    var t = new we,
                        e = new xn,
                        n = new De,
                        i = new Te,
                        r = new Te,
                        o = new Te,
                        a = new Te,
                        s = new Te,
                        c = new Te,
                        u = new be,
                        p = new be,
                        d = new be,
                        f = new Te,
                        m = new Te;

                    function v(t, e, n, i, r, o, a, s) {
                        if (null === (e.side === l ? i.intersectTriangle(a, o, r, !0, s) : i.intersectTriangle(r, o, a, e.side !== h, s))) return null;
                        m.copy(s), m.applyMatrix4(t.matrixWorld);
                        var c = n.ray.origin.distanceTo(m);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: m.clone(),
                            object: t
                        }
                    }

                    function g(t, e, n, a, s, c, l, h, m) {
                        i.fromBufferAttribute(s, l), r.fromBufferAttribute(s, h), o.fromBufferAttribute(s, m);
                        var g = v(t, e, n, a, i, r, o, f);
                        if (g) {
                            c && (u.fromBufferAttribute(c, l), p.fromBufferAttribute(c, h), d.fromBufferAttribute(c, m), g.uv = bn.getUV(f, i, r, o, u, p, d, new be));
                            var y = new We(l, h, m);
                            bn.getNormal(i, r, o, y.normal), g.face = y
                        }
                        return g
                    }
                    return function(l, h) {
                        var m, y = this.geometry,
                            _ = this.material,
                            x = this.matrixWorld;
                        if (void 0 !== _ && (null === y.boundingSphere && y.computeBoundingSphere(), n.copy(y.boundingSphere), n.applyMatrix4(x), !1 !== l.ray.intersectsSphere(n) && (t.getInverse(x), e.copy(l.ray).applyMatrix4(t), null === y.boundingBox || !1 !== e.intersectsBox(y.boundingBox))))
                            if (y.isBufferGeometry) {
                                var b, w, M, T, E, S, A, P, L, R, C, O = y.index,
                                    I = y.attributes.position,
                                    D = y.attributes.uv,
                                    N = y.groups,
                                    B = y.drawRange;
                                if (null !== O)
                                    if (Array.isArray(_))
                                        for (T = 0, S = N.length; T < S; T++)
                                            for (P = N[T], L = _[P.materialIndex], R = Math.max(P.start, B.start), C = Math.min(P.start + P.count, B.start + B.count), E = R, A = C; E < A; E += 3) b = O.getX(E), w = O.getX(E + 1), M = O.getX(E + 2), (m = g(this, L, l, e, I, D, b, w, M)) && (m.faceIndex = Math.floor(E / 3), h.push(m));
                                    else
                                        for (R = Math.max(0, B.start), C = Math.min(O.count, B.start + B.count), T = R, S = C; T < S; T += 3) b = O.getX(T), w = O.getX(T + 1), M = O.getX(T + 2), (m = g(this, _, l, e, I, D, b, w, M)) && (m.faceIndex = Math.floor(T / 3), h.push(m));
                                else if (void 0 !== I)
                                    if (Array.isArray(_))
                                        for (T = 0, S = N.length; T < S; T++)
                                            for (P = N[T], L = _[P.materialIndex], R = Math.max(P.start, B.start), C = Math.min(P.start + P.count, B.start + B.count), E = R, A = C; E < A; E += 3)(m = g(this, L, l, e, I, D, b = E, w = E + 1, M = E + 2)) && (m.faceIndex = Math.floor(E / 3), h.push(m));
                                    else
                                        for (R = Math.max(0, B.start), C = Math.min(I.count, B.start + B.count), T = R, S = C; T < S; T += 3)(m = g(this, _, l, e, I, D, b = T, w = T + 1, M = T + 2)) && (m.faceIndex = Math.floor(T / 3), h.push(m))
                            } else if (y.isGeometry) {
                            var H, F, k, U, z = Array.isArray(_),
                                G = y.vertices,
                                j = y.faces,
                                V = y.faceVertexUvs[0];
                            V.length > 0 && (U = V);
                            for (var W = 0, X = j.length; W < X; W++) {
                                var q = j[W],
                                    Y = z ? _[q.materialIndex] : _;
                                if (void 0 !== Y) {
                                    if (H = G[q.a], F = G[q.b], k = G[q.c], !0 === Y.morphTargets) {
                                        var Z = y.morphTargets,
                                            J = this.morphTargetInfluences;
                                        i.set(0, 0, 0), r.set(0, 0, 0), o.set(0, 0, 0);
                                        for (var K = 0, Q = Z.length; K < Q; K++) {
                                            var $ = J[K];
                                            if (0 !== $) {
                                                var tt = Z[K].vertices;
                                                i.addScaledVector(a.subVectors(tt[q.a], H), $), r.addScaledVector(s.subVectors(tt[q.b], F), $), o.addScaledVector(c.subVectors(tt[q.c], k), $)
                                            }
                                        }
                                        i.add(H), r.add(F), o.add(k), H = i, F = r, k = o
                                    }
                                    if (m = v(this, Y, l, e, H, F, k, f)) {
                                        if (U && U[W]) {
                                            var et = U[W];
                                            u.copy(et[0]), p.copy(et[1]), d.copy(et[2]), m.uv = bn.getUV(f, H, F, k, u, p, d, new be)
                                        }
                                        m.face = q, m.faceIndex = W, h.push(m)
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), En.prototype = Object.create(Pe.prototype), En.prototype.constructor = En, En.prototype.isCubeTexture = !0, Object.defineProperty(En.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), Sn.prototype = Object.create(Pe.prototype), Sn.prototype.constructor = Sn, Sn.prototype.isDataTexture3D = !0;
            var An = new Pe,
                Pn = new Sn,
                Ln = new En;

            function Rn() {
                this.seq = [], this.map = {}
            }
            var Cn = [],
                On = [],
                In = new Float32Array(16),
                Dn = new Float32Array(9),
                Nn = new Float32Array(4);

            function Bn(t, e, n) {
                var i = t[0];
                if (i <= 0 || i > 0) return t;
                var r = e * n,
                    o = Cn[r];
                if (void 0 === o && (o = new Float32Array(r), Cn[r] = o), 0 !== e) {
                    i.toArray(o, 0);
                    for (var a = 1, s = 0; a !== e; ++a) s += n, t[a].toArray(o, s)
                }
                return o
            }

            function Hn(t, e) {
                if (t.length !== e.length) return !1;
                for (var n = 0, i = t.length; n < i; n++)
                    if (t[n] !== e[n]) return !1;
                return !0
            }

            function Fn(t, e) {
                for (var n = 0, i = e.length; n < i; n++) t[n] = e[n]
            }

            function kn(t, e) {
                var n = On[e];
                void 0 === n && (n = new Int32Array(e), On[e] = n);
                for (var i = 0; i !== e; ++i) n[i] = t.allocTextureUnit();
                return n
            }

            function Un(t, e) {
                var n = this.cache;
                n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
            }

            function zn(t, e) {
                var n = this.cache;
                n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
            }

            function Gn(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                else {
                    if (Hn(n, e)) return;
                    t.uniform2fv(this.addr, e), Fn(n, e)
                }
            }

            function jn(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                else {
                    if (Hn(n, e)) return;
                    t.uniform3fv(this.addr, e), Fn(n, e)
                }
            }

            function Vn(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                else {
                    if (Hn(n, e)) return;
                    t.uniform4fv(this.addr, e), Fn(n, e)
                }
            }

            function Wn(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Hn(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), Fn(n, e)
                } else {
                    if (Hn(n, i)) return;
                    Nn.set(i), t.uniformMatrix2fv(this.addr, !1, Nn), Fn(n, i)
                }
            }

            function Xn(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Hn(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), Fn(n, e)
                } else {
                    if (Hn(n, i)) return;
                    Dn.set(i), t.uniformMatrix3fv(this.addr, !1, Dn), Fn(n, i)
                }
            }

            function qn(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Hn(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), Fn(n, e)
                } else {
                    if (Hn(n, i)) return;
                    In.set(i), t.uniformMatrix4fv(this.addr, !1, In), Fn(n, i)
                }
            }

            function Yn(t, e, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(e || An, r)
            }

            function Zn(t, e, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Pn, r)
            }

            function Jn(t, e, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || Ln, r)
            }

            function Kn(t, e) {
                var n = this.cache;
                Hn(n, e) || (t.uniform2iv(this.addr, e), Fn(n, e))
            }

            function Qn(t, e) {
                var n = this.cache;
                Hn(n, e) || (t.uniform3iv(this.addr, e), Fn(n, e))
            }

            function $n(t, e) {
                var n = this.cache;
                Hn(n, e) || (t.uniform4iv(this.addr, e), Fn(n, e))
            }

            function ti(t, e) {
                var n = this.cache;
                Hn(n, e) || (t.uniform1fv(this.addr, e), Fn(n, e))
            }

            function ei(t, e) {
                var n = this.cache;
                Hn(n, e) || (t.uniform1iv(this.addr, e), Fn(n, e))
            }

            function ni(t, e) {
                var n = this.cache,
                    i = Bn(e, this.size, 2);
                Hn(n, i) || (t.uniform2fv(this.addr, i), this.updateCache(i))
            }

            function ii(t, e) {
                var n = this.cache,
                    i = Bn(e, this.size, 3);
                Hn(n, i) || (t.uniform3fv(this.addr, i), this.updateCache(i))
            }

            function ri(t, e) {
                var n = this.cache,
                    i = Bn(e, this.size, 4);
                Hn(n, i) || (t.uniform4fv(this.addr, i), this.updateCache(i))
            }

            function oi(t, e) {
                var n = this.cache,
                    i = Bn(e, this.size, 4);
                Hn(n, i) || (t.uniformMatrix2fv(this.addr, !1, i), this.updateCache(i))
            }

            function ai(t, e) {
                var n = this.cache,
                    i = Bn(e, this.size, 9);
                Hn(n, i) || (t.uniformMatrix3fv(this.addr, !1, i), this.updateCache(i))
            }

            function si(t, e) {
                var n = this.cache,
                    i = Bn(e, this.size, 16);
                Hn(n, i) || (t.uniformMatrix4fv(this.addr, !1, i), this.updateCache(i))
            }

            function ci(t, e, n) {
                var i = this.cache,
                    r = e.length,
                    o = kn(n, r);
                !1 === Hn(i, o) && (t.uniform1iv(this.addr, o), Fn(i, o));
                for (var a = 0; a !== r; ++a) n.setTexture2D(e[a] || An, o[a])
            }

            function li(t, e, n) {
                var i = this.cache,
                    r = e.length,
                    o = kn(n, r);
                !1 === Hn(i, o) && (t.uniform1iv(this.addr, o), Fn(i, o));
                for (var a = 0; a !== r; ++a) n.setTextureCube(e[a] || Ln, o[a])
            }

            function hi(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Un;
                        case 35664:
                            return Gn;
                        case 35665:
                            return jn;
                        case 35666:
                            return Vn;
                        case 35674:
                            return Wn;
                        case 35675:
                            return Xn;
                        case 35676:
                            return qn;
                        case 35678:
                        case 36198:
                            return Yn;
                        case 35679:
                            return Zn;
                        case 35680:
                            return Jn;
                        case 5124:
                        case 35670:
                            return zn;
                        case 35667:
                        case 35671:
                            return Kn;
                        case 35668:
                        case 35672:
                            return Qn;
                        case 35669:
                        case 35673:
                            return $n
                    }
                }(e.type)
            }

            function ui(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return ti;
                        case 35664:
                            return ni;
                        case 35665:
                            return ii;
                        case 35666:
                            return ri;
                        case 35674:
                            return oi;
                        case 35675:
                            return ai;
                        case 35676:
                            return si;
                        case 35678:
                            return ci;
                        case 35680:
                            return li;
                        case 5124:
                        case 35670:
                            return ei;
                        case 35667:
                        case 35671:
                            return Kn;
                        case 35668:
                        case 35672:
                            return Qn;
                        case 35669:
                        case 35673:
                            return $n
                    }
                }(e.type)
            }

            function pi(t) {
                this.id = t, Rn.call(this)
            }
            ui.prototype.updateCache = function(t) {
                var e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Fn(e, t)
            }, pi.prototype.setValue = function(t, e, n) {
                for (var i = this.seq, r = 0, o = i.length; r !== o; ++r) {
                    var a = i[r];
                    a.setValue(t, e[a.id], n)
                }
            };
            var di = /([\w\d_]+)(\])?(\[|\.)?/g;

            function fi(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function mi(t, e, n) {
                var i = t.name,
                    r = i.length;
                for (di.lastIndex = 0;;) {
                    var o = di.exec(i),
                        a = di.lastIndex,
                        s = o[1],
                        c = "]" === o[2],
                        l = o[3];
                    if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === r) {
                        fi(n, void 0 === l ? new hi(s, t, e) : new ui(s, t, e));
                        break
                    }
                    var h = n.map,
                        u = h[s];
                    void 0 === u && (u = new pi(s), fi(n, u)), n = u
                }
            }

            function vi(t, e, n) {
                Rn.call(this), this.renderer = n;
                for (var i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r < i; ++r) {
                    var o = t.getActiveUniform(e, r),
                        a = t.getUniformLocation(e, o.name);
                    mi(o, a, this)
                }
            }

            function gi(t, e, n) {
                var i = t.createShader(e);
                return t.shaderSource(i, n), t.compileShader(i), !1 === t.getShaderParameter(i, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(i), function(t) {
                    for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                    return e.join("\n")
                }(n)), i
            }
            vi.prototype.setValue = function(t, e, n) {
                var i = this.map[e];
                void 0 !== i && i.setValue(t, n, this.renderer)
            }, vi.prototype.setOptional = function(t, e, n) {
                var i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }, vi.upload = function(t, e, n, i) {
                for (var r = 0, o = e.length; r !== o; ++r) {
                    var a = e[r],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(t, s.value, i)
                }
            }, vi.seqWithValue = function(t, e) {
                for (var n = [], i = 0, r = t.length; i !== r; ++i) {
                    var o = t[i];
                    o.id in e && n.push(o)
                }
                return n
            };
            var yi = 0;

            function _i(t) {
                switch (t) {
                    case le:
                        return ["Linear", "( value )"];
                    case he:
                        return ["sRGB", "( value )"];
                    case pe:
                        return ["RGBE", "( value )"];
                    case de:
                        return ["RGBM", "( value, 7.0 )"];
                    case fe:
                        return ["RGBM", "( value, 16.0 )"];
                    case me:
                        return ["RGBD", "( value, 256.0 )"];
                    case ue:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + t)
                }
            }

            function xi(t, e) {
                var n = _i(e);
                return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function bi(t) {
                return "" !== t
            }

            function wi(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            }

            function Mi(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }

            function Ti(t) {
                return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(t, e) {
                    var n = He[e];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                    return Ti(n)
                })
            }

            function Ei(t) {
                return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, n, i) {
                    for (var r = "", o = parseInt(e); o < parseInt(n); o++) r += i.replace(/\[ i \]/g, "[ " + o + " ]");
                    return r
                })
            }

            function Si(t, e, n, i, r, o, c) {
                var l = t.context,
                    h = i.defines,
                    u = r.vertexShader,
                    p = r.fragmentShader,
                    d = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === a ? d = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === s && (d = "SHADOWMAP_TYPE_PCF_SOFT");
                var f = "ENVMAP_TYPE_CUBE",
                    m = "ENVMAP_MODE_REFLECTION",
                    v = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                    switch (i.envMap.mapping) {
                        case Q:
                        case $:
                            f = "ENVMAP_TYPE_CUBE";
                            break;
                        case it:
                        case rt:
                            f = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case tt:
                        case et:
                            f = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case nt:
                            f = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (i.envMap.mapping) {
                        case $:
                        case et:
                            m = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (i.combine) {
                        case V:
                            v = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case W:
                            v = "ENVMAP_BLENDING_MIX";
                            break;
                        case X:
                            v = "ENVMAP_BLENDING_ADD"
                    }
                }
                var g, y, _ = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    x = c.isWebGL2 ? "" : function(t, e, n) {
                        return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(bi).join("\n")
                    }(i.extensions, o, e),
                    b = function(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            !1 !== i && e.push("#define " + n + " " + i)
                        }
                        return e.join("\n")
                    }(h),
                    w = l.createProgram();
                if (i.isRawShaderMaterial ? ((g = [b].filter(bi).join("\n")).length > 0 && (g += "\n"), (y = [x, b].filter(bi).join("\n")).length > 0 && (y += "\n")) : (g = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (c.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(bi).join("\n"), y = [x, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + _, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.envMap ? "#define " + v : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (c.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (c.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== q ? "#define TONE_MAPPING" : "", o.toneMapping !== q ? He.tonemapping_pars_fragment : "", o.toneMapping !== q ? function(t, e) {
                        var n;
                        switch (e) {
                            case Y:
                                n = "Linear";
                                break;
                            case Z:
                                n = "Reinhard";
                                break;
                            case J:
                                n = "Uncharted2";
                                break;
                            case K:
                                n = "OptimizedCineon";
                                break;
                            default:
                                throw new Error("unsupported toneMapping: " + e)
                        }
                        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                    }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? He.encodings_pars_fragment : "", o.mapEncoding ? xi("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? xi("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? xi("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? xi("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? function(t, e) {
                        var n = _i(e);
                        return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                    }("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(bi).join("\n")), u = Mi(u = wi(u = Ti(u), o), o), p = Mi(p = wi(p = Ti(p), o), o), u = Ei(u), p = Ei(p), c.isWebGL2 && !i.isRawShaderMaterial) {
                    var M = !1,
                        T = /^\s*#version\s+300\s+es\s*\n/;
                    i.isShaderMaterial && null !== u.match(T) && null !== p.match(T) && (M = !0, u = u.replace(T, ""), p = p.replace(T, "")), g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, y = ["#version 300 es\n", "#define varying in", M ? "" : "out highp vec4 pc_fragColor;", M ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y
                }
                var E = g + u,
                    S = y + p,
                    A = gi(l, l.VERTEX_SHADER, E),
                    P = gi(l, l.FRAGMENT_SHADER, S);
                l.attachShader(w, A), l.attachShader(w, P), void 0 !== i.index0AttributeName ? l.bindAttribLocation(w, 0, i.index0AttributeName) : !0 === o.morphTargets && l.bindAttribLocation(w, 0, "position"), l.linkProgram(w);
                var L, R, C = l.getProgramInfoLog(w).trim(),
                    O = l.getShaderInfoLog(A).trim(),
                    I = l.getShaderInfoLog(P).trim(),
                    D = !0,
                    N = !0;
                return !1 === l.getProgramParameter(w, l.LINK_STATUS) ? (D = !1, console.error("THREE.WebGLProgram: shader error: ", l.getError(), "gl.VALIDATE_STATUS", l.getProgramParameter(w, l.VALIDATE_STATUS), "gl.getProgramInfoLog", C, O, I)) : "" !== C ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C) : "" !== O && "" !== I || (N = !1), N && (this.diagnostics = {
                    runnable: D,
                    material: i,
                    programLog: C,
                    vertexShader: {
                        log: O,
                        prefix: g
                    },
                    fragmentShader: {
                        log: I,
                        prefix: y
                    }
                }), l.deleteShader(A), l.deleteShader(P), this.getUniforms = function() {
                    return void 0 === L && (L = new vi(l, w, t)), L
                }, this.getAttributes = function() {
                    return void 0 === R && (R = function(t, e) {
                        for (var n = {}, i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0; r < i; r++) {
                            var o = t.getActiveAttrib(e, r),
                                a = o.name;
                            n[a] = t.getAttribLocation(e, a)
                        }
                        return n
                    }(l, w)), R
                }, this.destroy = function() {
                    l.deleteProgram(w), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.name = r.name, this.id = yi++, this.code = n, this.usedTimes = 1, this.program = w, this.vertexShader = A, this.fragmentShader = P, this
            }

            function Ai(t, e, n) {
                var i = [],
                    r = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function a(t, e) {
                    var n;
                    return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = le, n === le && e && (n = ue), n
                }
                this.getParameters = function(e, i, o, s, c, u, p) {
                    var d = r[e.type],
                        f = p.isSkinnedMesh ? function(t) {
                            var e = t.skeleton.bones;
                            if (n.floatVertexTextures) return 1024;
                            var i = n.maxVertexUniforms,
                                r = Math.floor((i - 20) / 4),
                                o = Math.min(r, e.length);
                            return o < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + o + "."), 0) : o
                        }(p) : 0,
                        m = n.precision;
                    null !== e.precision && (m = n.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", m, "instead.");
                    var v = t.getRenderTarget(),
                        g = {
                            shaderID: d,
                            precision: m,
                            supportsVertexTextures: n.vertexTextures,
                            outputEncoding: a(v ? v.texture : null, t.gammaOutput),
                            map: !!e.map,
                            mapEncoding: a(e.map, t.gammaInput),
                            matcap: !!e.matcap,
                            matcapEncoding: a(e.matcap, t.gammaInput),
                            envMap: !!e.envMap,
                            envMapMode: e.envMap && e.envMap.mapping,
                            envMapEncoding: a(e.envMap, t.gammaInput),
                            envMapCubeUV: !!e.envMap && (e.envMap.mapping === it || e.envMap.mapping === rt),
                            lightMap: !!e.lightMap,
                            aoMap: !!e.aoMap,
                            emissiveMap: !!e.emissiveMap,
                            emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
                            bumpMap: !!e.bumpMap,
                            normalMap: !!e.normalMap,
                            objectSpaceNormalMap: e.normalMapType === _e,
                            displacementMap: !!e.displacementMap,
                            roughnessMap: !!e.roughnessMap,
                            metalnessMap: !!e.metalnessMap,
                            specularMap: !!e.specularMap,
                            alphaMap: !!e.alphaMap,
                            gradientMap: !!e.gradientMap,
                            combine: e.combine,
                            vertexColors: e.vertexColors,
                            fog: !!s,
                            useFog: e.fog,
                            fogExp: s && s.isFogExp2,
                            flatShading: e.flatShading,
                            sizeAttenuation: e.sizeAttenuation,
                            logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                            skinning: e.skinning && f > 0,
                            maxBones: f,
                            useVertexTexture: n.floatVertexTextures,
                            morphTargets: e.morphTargets,
                            morphNormals: e.morphNormals,
                            maxMorphTargets: t.maxMorphTargets,
                            maxMorphNormals: t.maxMorphNormals,
                            numDirLights: i.directional.length,
                            numPointLights: i.point.length,
                            numSpotLights: i.spot.length,
                            numRectAreaLights: i.rectArea.length,
                            numHemiLights: i.hemi.length,
                            numClippingPlanes: c,
                            numClipIntersection: u,
                            dithering: e.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && p.receiveShadow && o.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: t.toneMapping,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: e.premultipliedAlpha,
                            alphaTest: e.alphaTest,
                            doubleSided: e.side === h,
                            flipSided: e.side === l,
                            depthPacking: void 0 !== e.depthPacking && e.depthPacking
                        };
                    return g
                }, this.getProgramCode = function(e, n) {
                    var i = [];
                    if (n.shaderID ? i.push(n.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) i.push(r), i.push(e.defines[r]);
                    for (var a = 0; a < o.length; a++) i.push(n[o[a]]);
                    return i.push(e.onBeforeCompile.toString()), i.push(t.gammaOutput), i.join()
                }, this.acquireProgram = function(r, o, a, s) {
                    for (var c, l = 0, h = i.length; l < h; l++) {
                        var u = i[l];
                        if (u.code === s) {
                            ++(c = u).usedTimes;
                            break
                        }
                    }
                    return void 0 === c && (c = new Si(t, e, s, r, o, a, n), i.push(c)), c
                }, this.releaseProgram = function(t) {
                    if (0 == --t.usedTimes) {
                        var e = i.indexOf(t);
                        i[e] = i[i.length - 1], i.pop(), t.destroy()
                    }
                }, this.programs = i
            }

            function Pi(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function Li(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Ri() {
                var t = {};
                return {
                    get: function(e, n) {
                        var i = e.id + "," + n.id,
                            r = t[i];
                        return void 0 === r && (r = new function() {
                            var t = [],
                                e = 0,
                                n = [],
                                i = [];
                            return {
                                opaque: n,
                                transparent: i,
                                init: function() {
                                    e = 0, n.length = 0, i.length = 0
                                },
                                push: function(r, o, a, s, c) {
                                    var l = t[e];
                                    void 0 === l ? (l = {
                                        id: r.id,
                                        object: r,
                                        geometry: o,
                                        material: a,
                                        program: a.program,
                                        renderOrder: r.renderOrder,
                                        z: s,
                                        group: c
                                    }, t[e] = l) : (l.id = r.id, l.object = r, l.geometry = o, l.material = a, l.program = a.program, l.renderOrder = r.renderOrder, l.z = s, l.group = c), (!0 === a.transparent ? i : n).push(l), e++
                                },
                                sort: function() {
                                    n.length > 1 && n.sort(Pi), i.length > 1 && i.sort(Li)
                                }
                            }
                        }, t[i] = r), r
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }
            var Ci, Oi = 0;

            function Ii() {
                var t = new function() {
                        var t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                var n;
                                switch (e.type) {
                                    case "DirectionalLight":
                                        n = {
                                            direction: new Te,
                                            color: new Ue,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new be
                                        };
                                        break;
                                    case "SpotLight":
                                        n = {
                                            position: new Te,
                                            direction: new Te,
                                            color: new Ue,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new be
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            position: new Te,
                                            color: new Ue,
                                            distance: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new be,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        };
                                        break;
                                    case "HemisphereLight":
                                        n = {
                                            direction: new Te,
                                            skyColor: new Ue,
                                            groundColor: new Ue
                                        };
                                        break;
                                    case "RectAreaLight":
                                        n = {
                                            color: new Ue,
                                            position: new Te,
                                            halfWidth: new Te,
                                            halfHeight: new Te
                                        }
                                }
                                return t[e.id] = n, n
                            }
                        }
                    },
                    e = {
                        id: Oi++,
                        hash: {
                            stateID: -1,
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            shadowsLength: -1
                        },
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    },
                    n = new Te,
                    i = new we,
                    r = new we;
                return {
                    setup: function(o, a, s) {
                        for (var c = 0, l = 0, h = 0, u = 0, p = 0, d = 0, f = 0, m = 0, v = s.matrixWorldInverse, g = 0, y = o.length; g < y; g++) {
                            var _ = o[g],
                                x = _.color,
                                b = _.intensity,
                                w = _.distance,
                                M = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
                            if (_.isAmbientLight) c += x.r * b, l += x.g * b, h += x.b * b;
                            else if (_.isDirectionalLight) {
                                var T = t.get(_);
                                if (T.color.copy(_.color).multiplyScalar(_.intensity), T.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), T.direction.sub(n), T.direction.transformDirection(v), T.shadow = _.castShadow, _.castShadow) {
                                    var E = _.shadow;
                                    T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize
                                }
                                e.directionalShadowMap[u] = M, e.directionalShadowMatrix[u] = _.shadow.matrix, e.directional[u] = T, u++
                            } else if (_.isSpotLight) {
                                var T = t.get(_);
                                if (T.position.setFromMatrixPosition(_.matrixWorld), T.position.applyMatrix4(v), T.color.copy(x).multiplyScalar(b), T.distance = w, T.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), T.direction.sub(n), T.direction.transformDirection(v), T.coneCos = Math.cos(_.angle), T.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), T.decay = _.decay, T.shadow = _.castShadow, _.castShadow) {
                                    var E = _.shadow;
                                    T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize
                                }
                                e.spotShadowMap[d] = M, e.spotShadowMatrix[d] = _.shadow.matrix, e.spot[d] = T, d++
                            } else if (_.isRectAreaLight) {
                                var T = t.get(_);
                                T.color.copy(x).multiplyScalar(b), T.position.setFromMatrixPosition(_.matrixWorld), T.position.applyMatrix4(v), r.identity(), i.copy(_.matrixWorld), i.premultiply(v), r.extractRotation(i), T.halfWidth.set(.5 * _.width, 0, 0), T.halfHeight.set(0, .5 * _.height, 0), T.halfWidth.applyMatrix4(r), T.halfHeight.applyMatrix4(r), e.rectArea[f] = T, f++
                            } else if (_.isPointLight) {
                                var T = t.get(_);
                                if (T.position.setFromMatrixPosition(_.matrixWorld), T.position.applyMatrix4(v), T.color.copy(_.color).multiplyScalar(_.intensity), T.distance = _.distance, T.decay = _.decay, T.shadow = _.castShadow, _.castShadow) {
                                    var E = _.shadow;
                                    T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize, T.shadowCameraNear = E.camera.near, T.shadowCameraFar = E.camera.far
                                }
                                e.pointShadowMap[p] = M, e.pointShadowMatrix[p] = _.shadow.matrix, e.point[p] = T, p++
                            } else if (_.isHemisphereLight) {
                                var T = t.get(_);
                                T.direction.setFromMatrixPosition(_.matrixWorld), T.direction.transformDirection(v), T.direction.normalize(), T.skyColor.copy(_.color).multiplyScalar(b), T.groundColor.copy(_.groundColor).multiplyScalar(b), e.hemi[m] = T, m++
                            }
                        }
                        e.ambient[0] = c, e.ambient[1] = l, e.ambient[2] = h, e.directional.length = u, e.spot.length = d, e.rectArea.length = f, e.point.length = p, e.hemi.length = m, e.hash.stateID = e.id, e.hash.directionalLength = u, e.hash.pointLength = p, e.hash.spotLength = d, e.hash.rectAreaLength = f, e.hash.hemiLength = m, e.hash.shadowsLength = a.length
                    },
                    state: e
                }
            }

            function Di() {
                var t = new Ii,
                    e = [],
                    n = [],
                    i = {
                        lightsArray: e,
                        shadowsArray: n,
                        lights: t
                    };
                return {
                    init: function() {
                        e.length = 0, n.length = 0
                    },
                    state: i,
                    setupLights: function(i) {
                        t.setup(e, n, i)
                    },
                    pushLight: function(t) {
                        e.push(t)
                    },
                    pushShadow: function(t) {
                        n.push(t)
                    }
                }
            }

            function Ni(t) {
                yn.call(this), this.type = "MeshDepthMaterial", this.depthPacking = ve, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function Bi(t) {
                yn.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Te, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function Hi(t, e, n) {
                for (var i = new Be, r = new we, o = new be, s = new be(n, n), u = new Te, p = new Te, d = 1, f = 2, m = 1 + (d | f), v = new Array(m), g = new Array(m), y = {}, _ = {
                        0: l,
                        1: c,
                        2: h
                    }, x = [new Te(1, 0, 0), new Te(-1, 0, 0), new Te(0, 0, 1), new Te(0, 0, -1), new Te(0, 1, 0), new Te(0, -1, 0)], b = [new Te(0, 1, 0), new Te(0, 1, 0), new Te(0, 1, 0), new Te(0, 1, 0), new Te(0, 0, 1), new Te(0, 0, -1)], w = [new Le, new Le, new Le, new Le, new Le, new Le], M = 0; M !== m; ++M) {
                    var T = 0 != (M & d),
                        E = 0 != (M & f),
                        S = new Ni({
                            depthPacking: ge,
                            morphTargets: T,
                            skinning: E
                        });
                    v[M] = S;
                    var A = new Bi({
                        morphTargets: T,
                        skinning: E
                    });
                    g[M] = A
                }
                var P = this;

                function L(e, n, i, r, o, a) {
                    var s = e.geometry,
                        c = null,
                        l = v,
                        h = e.customDepthMaterial;
                    if (i && (l = g, h = e.customDistanceMaterial), h) c = h;
                    else {
                        var u = !1;
                        n.morphTargets && (s && s.isBufferGeometry ? u = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (u = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                        var p = e.isSkinnedMesh && n.skinning,
                            m = 0;
                        u && (m |= d), p && (m |= f), c = l[m]
                    }
                    if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                        var x = c.uuid,
                            b = n.uuid,
                            w = y[x];
                        void 0 === w && (w = {}, y[x] = w);
                        var M = w[b];
                        void 0 === M && (M = c.clone(), w[b] = M), c = M
                    }
                    return c.visible = n.visible, c.wireframe = n.wireframe, c.side = null != n.shadowSide ? n.shadowSide : _[n.side], c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, i && c.isMeshDistanceMaterial && (c.referencePosition.copy(r), c.nearDistance = o, c.farDistance = a), c
                }

                function R(n, r, o, a) {
                    if (!1 !== n.visible) {
                        var s = n.layers.test(r.layers);
                        if (s && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                            var c = e.update(n),
                                l = n.material;
                            if (Array.isArray(l))
                                for (var h = c.groups, u = 0, d = h.length; u < d; u++) {
                                    var f = h[u],
                                        m = l[f.materialIndex];
                                    if (m && m.visible) {
                                        var v = L(n, m, a, p, o.near, o.far);
                                        t.renderBufferDirect(o, null, c, v, n, f)
                                    }
                                } else if (l.visible) {
                                    var v = L(n, l, a, p, o.near, o.far);
                                    t.renderBufferDirect(o, null, c, v, n, null)
                                }
                        }
                        for (var g = n.children, y = 0, _ = g.length; y < _; y++) R(g[y], r, o, a)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = a, this.render = function(e, n, a) {
                    if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== e.length) {
                        var c, l = t.context,
                            h = t.state;
                        h.disable(l.BLEND), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
                        for (var d = 0, f = e.length; d < f; d++) {
                            var m = e[d],
                                v = m.shadow,
                                g = m && m.isPointLight;
                            if (void 0 !== v) {
                                var y = v.camera;
                                if (o.copy(v.mapSize), o.min(s), g) {
                                    var _ = o.x,
                                        M = o.y;
                                    w[0].set(2 * _, M, _, M), w[1].set(0, M, _, M), w[2].set(3 * _, M, _, M), w[3].set(_, M, _, M), w[4].set(3 * _, 0, _, M), w[5].set(_, 0, _, M), o.x *= 4, o.y *= 2
                                }
                                if (null === v.map) {
                                    var T = {
                                        minFilter: ct,
                                        magFilter: ct,
                                        format: Pt
                                    };
                                    v.map = new Re(o.x, o.y, T), v.map.texture.name = m.name + ".shadowMap", y.updateProjectionMatrix()
                                }
                                v.isSpotLightShadow && v.update(m);
                                var E = v.map,
                                    S = v.matrix;
                                p.setFromMatrixPosition(m.matrixWorld), y.position.copy(p), g ? (c = 6, S.makeTranslation(-p.x, -p.y, -p.z)) : (c = 1, u.setFromMatrixPosition(m.target.matrixWorld), y.lookAt(u), y.updateMatrixWorld(), S.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), S.multiply(y.projectionMatrix), S.multiply(y.matrixWorldInverse)), t.setRenderTarget(E), t.clear();
                                for (var A = 0; A < c; A++) {
                                    if (g) {
                                        u.copy(y.position), u.add(x[A]), y.up.copy(b[A]), y.lookAt(u), y.updateMatrixWorld();
                                        var L = w[A];
                                        h.viewport(L)
                                    }
                                    r.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse), i.setFromMatrix(r), R(n, a, y, g)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", m, "has no shadow.")
                        }
                        P.needsUpdate = !1
                    }
                }
            }

            function Fi(t, e, n, i, r, o, a) {
                var s, c = {};

                function l(t, e) {
                    if (t.width > e || t.height > e) {
                        if ("data" in t) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + t.width + "x" + t.height + ").");
                        var n = e / Math.max(t.width, t.height),
                            i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        i.width = Math.floor(t.width * n), i.height = Math.floor(t.height * n);
                        var r = i.getContext("2d");
                        return r.drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height), i
                    }
                    return t
                }

                function h(t) {
                    return xe.isPowerOfTwo(t.width) && xe.isPowerOfTwo(t.height)
                }

                function u(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== ct && t.minFilter !== ut
                }

                function p(e, n, r, o) {
                    t.generateMipmap(e);
                    var a = i.get(n);
                    a.__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
                }

                function d(e, n) {
                    if (!r.isWebGL2) return e;
                    if (e === t.RED) {
                        if (n === t.FLOAT) return t.R32F;
                        if (n === t.HALF_FLOAT) return t.R16F;
                        if (n === t.UNSIGNED_BYTE) return t.R8
                    }
                    if (e === t.RGB) {
                        if (n === t.FLOAT) return t.RGB32F;
                        if (n === t.HALF_FLOAT) return t.RGB16F;
                        if (n === t.UNSIGNED_BYTE) return t.RGB8
                    }
                    if (e === t.RGBA) {
                        if (n === t.FLOAT) return t.RGBA32F;
                        if (n === t.HALF_FLOAT) return t.RGBA16F;
                        if (n === t.UNSIGNED_BYTE) return t.RGBA8
                    }
                    return e
                }

                function f(e) {
                    return e === ct || e === lt || e === ht ? t.NEAREST : t.LINEAR
                }

                function m(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", m),
                        function(e) {
                            var n = i.get(e);
                            if (e.image && n.__image__webglTextureCube) t.deleteTexture(n.__image__webglTextureCube);
                            else {
                                if (void 0 === n.__webglInit) return;
                                t.deleteTexture(n.__webglTexture)
                            }
                            i.remove(e)
                        }(n), n.isVideoTexture && delete c[n.id], a.memory.textures--
                }

                function v(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", v),
                        function(e) {
                            var n = i.get(e),
                                r = i.get(e.texture);
                            if (e) {
                                if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
                                    for (var o = 0; o < 6; o++) t.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                                else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                                i.remove(e.texture), i.remove(e)
                            }
                        }(n), a.memory.textures--
                }

                function g(e, r) {
                    var o = i.get(e);
                    if (e.isVideoTexture && function(t) {
                            var e = t.id,
                                n = a.render.frame;
                            c[e] !== n && (c[e] = n, t.update())
                        }(e), e.version > 0 && o.__version !== e.version) {
                        var s = e.image;
                        if (void 0 === s) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== s.complete) return void _(o, e, r);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D, o.__webglTexture)
                }

                function y(n, a, s) {
                    var c;
                    if (s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, o.convert(a.wrapS)), t.texParameteri(n, t.TEXTURE_WRAP_T, o.convert(a.wrapT)), t.texParameteri(n, t.TEXTURE_MAG_FILTER, o.convert(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, o.convert(a.minFilter))) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), a.wrapS === at && a.wrapT === at || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, f(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, f(a.minFilter)), a.minFilter !== ct && a.minFilter !== ut && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c = e.get("EXT_texture_filter_anisotropic")) {
                        if (a.type === xt && null === e.get("OES_texture_float_linear")) return;
                        if (a.type === bt && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear"))) return;
                        (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function _(e, i, c) {
                    var f;
                    f = i.isDataTexture3D ? t.TEXTURE_3D : t.TEXTURE_2D, void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", m), e.__webglTexture = t.createTexture(), a.memory.textures++), n.activeTexture(t.TEXTURE0 + c), n.bindTexture(f, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
                    var v = l(i.image, r.maxTextureSize);
                    (function(t) {
                        return !r.isWebGL2 && (t.wrapS !== at || t.wrapT !== at || t.minFilter !== ct && t.minFilter !== ut)
                    })(i) && !1 === h(v) && (v = function(t) {
                        if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap) {
                            void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), s.width = xe.floorPowerOfTwo(t.width), s.height = xe.floorPowerOfTwo(t.height);
                            var e = s.getContext("2d");
                            return e.drawImage(t, 0, 0, s.width, s.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + s.width + "x" + s.height), s
                        }
                        return t
                    }(v));
                    var g = h(v),
                        _ = o.convert(i.format),
                        x = o.convert(i.type),
                        b = d(_, x);
                    y(f, i, g);
                    var w, M = i.mipmaps;
                    if (i.isDepthTexture) {
                        if (b = t.DEPTH_COMPONENT, i.type === xt) {
                            if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            b = t.DEPTH_COMPONENT32F
                        } else r.isWebGL2 && (b = t.DEPTH_COMPONENT16);
                        i.format === Ot && b === t.DEPTH_COMPONENT && i.type !== gt && i.type !== _t && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = gt, x = o.convert(i.type)), i.format === It && (b = t.DEPTH_STENCIL, i.type !== Et && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Et, x = o.convert(i.type))), n.texImage2D(t.TEXTURE_2D, 0, b, v.width, v.height, 0, _, x, null)
                    } else if (i.isDataTexture)
                        if (M.length > 0 && g) {
                            for (var T = 0, E = M.length; T < E; T++) w = M[T], n.texImage2D(t.TEXTURE_2D, T, b, w.width, w.height, 0, _, x, w.data);
                            i.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                        } else n.texImage2D(t.TEXTURE_2D, 0, b, v.width, v.height, 0, _, x, v.data), e.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) {
                        for (var T = 0, E = M.length; T < E; T++) w = M[T], i.format !== Pt && i.format !== At ? n.getCompressedTextureFormats().indexOf(_) > -1 ? n.compressedTexImage2D(t.TEXTURE_2D, T, b, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, T, b, w.width, w.height, 0, _, x, w.data);
                        e.__maxMipLevel = M.length - 1
                    } else if (i.isDataTexture3D) n.texImage3D(t.TEXTURE_3D, 0, b, v.width, v.height, v.depth, 0, _, x, v.data), e.__maxMipLevel = 0;
                    else if (M.length > 0 && g) {
                        for (var T = 0, E = M.length; T < E; T++) w = M[T], n.texImage2D(t.TEXTURE_2D, T, b, _, x, w);
                        i.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                    } else n.texImage2D(t.TEXTURE_2D, 0, b, _, x, v), e.__maxMipLevel = 0;
                    u(i, g) && p(t.TEXTURE_2D, i, v.width, v.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                }

                function x(e, r, a, s) {
                    var c = o.convert(r.texture.format),
                        l = o.convert(r.texture.type),
                        h = d(c, l);
                    n.texImage2D(s, 0, h, r.width, r.height, 0, c, l, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, a, s, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
                }

                function b(e, n) {
                    t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : n.depthBuffer && n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height), t.bindRenderbuffer(t.RENDERBUFFER, null)
                }

                function w(e) {
                    var n = i.get(e),
                        r = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, n) {
                            if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(t.FRAMEBUFFER, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), g(n.depthTexture, 0);
                            var r = i.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === Ot) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                            else {
                                if (n.depthTexture.format !== It) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
                            }
                        }(n.__webglFramebuffer, e)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (var o = 0; o < 6; o++) t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = t.createRenderbuffer(), b(n.__webglDepthbuffer[o], e)
                    } else t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), b(n.__webglDepthbuffer, e);
                    t.bindFramebuffer(t.FRAMEBUFFER, null)
                }
                this.setTexture2D = g, this.setTexture3D = function(e, r) {
                    var o = i.get(e);
                    e.version > 0 && o.__version !== e.version ? _(o, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_3D, o.__webglTexture))
                }, this.setTextureCube = function(e, s) {
                    var c = i.get(e);
                    if (6 === e.image.length)
                        if (e.version > 0 && c.__version !== e.version) {
                            c.__image__webglTextureCube || (e.addEventListener("dispose", m), c.__image__webglTextureCube = t.createTexture(), a.memory.textures++), n.activeTexture(t.TEXTURE0 + s), n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                            for (var f = e && e.isCompressedTexture, v = e.image[0] && e.image[0].isDataTexture, g = [], _ = 0; _ < 6; _++) g[_] = f || v ? v ? e.image[_].image : e.image[_] : l(e.image[_], r.maxCubemapSize);
                            var x = g[0],
                                b = h(x),
                                w = o.convert(e.format),
                                M = o.convert(e.type),
                                T = d(w, M);
                            y(t.TEXTURE_CUBE_MAP, e, b);
                            for (var _ = 0; _ < 6; _++)
                                if (f)
                                    for (var E, S = g[_].mipmaps, A = 0, P = S.length; A < P; A++) E = S[A], e.format !== Pt && e.format !== At ? n.getCompressedTextureFormats().indexOf(w) > -1 ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _, A, T, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _, A, T, E.width, E.height, 0, w, M, E.data);
                                else v ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _, 0, T, g[_].width, g[_].height, 0, w, M, g[_].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _, 0, T, w, M, g[_]);
                            c.__maxMipLevel = f ? S.length - 1 : 0, u(e, b) && p(t.TEXTURE_CUBE_MAP, e, x.width, x.height), c.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else n.activeTexture(t.TEXTURE0 + s), n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
                }, this.setTextureCubeDynamic = function(e, r) {
                    n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture)
                }, this.setupRenderTarget = function(e) {
                    var r = i.get(e),
                        o = i.get(e.texture);
                    e.addEventListener("dispose", v), o.__webglTexture = t.createTexture(), a.memory.textures++;
                    var s = !0 === e.isWebGLRenderTargetCube,
                        c = h(e);
                    if (s) {
                        r.__webglFramebuffer = [];
                        for (var l = 0; l < 6; l++) r.__webglFramebuffer[l] = t.createFramebuffer()
                    } else r.__webglFramebuffer = t.createFramebuffer();
                    if (s) {
                        n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture), y(t.TEXTURE_CUBE_MAP, e.texture, c);
                        for (var l = 0; l < 6; l++) x(r.__webglFramebuffer[l], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + l);
                        u(e.texture, c) && p(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_CUBE_MAP, null)
                    } else n.bindTexture(t.TEXTURE_2D, o.__webglTexture), y(t.TEXTURE_2D, e.texture, c), x(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), u(e.texture, c) && p(t.TEXTURE_2D, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_2D, null);
                    e.depthBuffer && w(e)
                }, this.updateRenderTargetMipmap = function(e) {
                    var r = e.texture,
                        o = h(e);
                    if (u(r, o)) {
                        var a = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                            s = i.get(r).__webglTexture;
                        n.bindTexture(a, s), p(a, r, e.width, e.height), n.bindTexture(a, null)
                    }
                }
            }

            function ki(t, e, n) {
                return {
                    convert: function(i) {
                        var r;
                        if (i === ot) return t.REPEAT;
                        if (i === at) return t.CLAMP_TO_EDGE;
                        if (i === st) return t.MIRRORED_REPEAT;
                        if (i === ct) return t.NEAREST;
                        if (i === lt) return t.NEAREST_MIPMAP_NEAREST;
                        if (i === ht) return t.NEAREST_MIPMAP_LINEAR;
                        if (i === ut) return t.LINEAR;
                        if (i === pt) return t.LINEAR_MIPMAP_NEAREST;
                        if (i === dt) return t.LINEAR_MIPMAP_LINEAR;
                        if (i === ft) return t.UNSIGNED_BYTE;
                        if (i === wt) return t.UNSIGNED_SHORT_4_4_4_4;
                        if (i === Mt) return t.UNSIGNED_SHORT_5_5_5_1;
                        if (i === Tt) return t.UNSIGNED_SHORT_5_6_5;
                        if (i === mt) return t.BYTE;
                        if (i === vt) return t.SHORT;
                        if (i === gt) return t.UNSIGNED_SHORT;
                        if (i === yt) return t.INT;
                        if (i === _t) return t.UNSIGNED_INT;
                        if (i === xt) return t.FLOAT;
                        if (i === bt) {
                            if (n.isWebGL2) return t.HALF_FLOAT;
                            if (null !== (r = e.get("OES_texture_half_float"))) return r.HALF_FLOAT_OES
                        }
                        if (i === St) return t.ALPHA;
                        if (i === At) return t.RGB;
                        if (i === Pt) return t.RGBA;
                        if (i === Lt) return t.LUMINANCE;
                        if (i === Rt) return t.LUMINANCE_ALPHA;
                        if (i === Ot) return t.DEPTH_COMPONENT;
                        if (i === It) return t.DEPTH_STENCIL;
                        if (i === Dt) return t.RED;
                        if (i === x) return t.FUNC_ADD;
                        if (i === b) return t.FUNC_SUBTRACT;
                        if (i === w) return t.FUNC_REVERSE_SUBTRACT;
                        if (i === E) return t.ZERO;
                        if (i === S) return t.ONE;
                        if (i === A) return t.SRC_COLOR;
                        if (i === P) return t.ONE_MINUS_SRC_COLOR;
                        if (i === L) return t.SRC_ALPHA;
                        if (i === R) return t.ONE_MINUS_SRC_ALPHA;
                        if (i === C) return t.DST_ALPHA;
                        if (i === O) return t.ONE_MINUS_DST_ALPHA;
                        if (i === I) return t.DST_COLOR;
                        if (i === D) return t.ONE_MINUS_DST_COLOR;
                        if (i === N) return t.SRC_ALPHA_SATURATE;
                        if ((i === Nt || i === Bt || i === Ht || i === Ft) && null !== (r = e.get("WEBGL_compressed_texture_s3tc"))) {
                            if (i === Nt) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (i === Bt) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (i === Ht) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (i === Ft) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if ((i === kt || i === Ut || i === zt || i === Gt) && null !== (r = e.get("WEBGL_compressed_texture_pvrtc"))) {
                            if (i === kt) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (i === Ut) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (i === zt) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (i === Gt) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (i === jt && null !== (r = e.get("WEBGL_compressed_texture_etc1"))) return r.COMPRESSED_RGB_ETC1_WEBGL;
                        if ((i === Vt || i === Wt || i === Xt || i === qt || i === Yt || i === Zt || i === Jt || i === Kt || i === Qt || i === $t || i === te || i === ee || i === ne || i === ie) && null !== (r = e.get("WEBGL_compressed_texture_astc"))) return i;
                        if (i === M || i === T) {
                            if (n.isWebGL2) {
                                if (i === M) return t.MIN;
                                if (i === T) return t.MAX
                            }
                            if (null !== (r = e.get("EXT_blend_minmax"))) {
                                if (i === M) return r.MIN_EXT;
                                if (i === T) return r.MAX_EXT
                            }
                        }
                        if (i === Et) {
                            if (n.isWebGL2) return t.UNSIGNED_INT_24_8;
                            if (null !== (r = e.get("WEBGL_depth_texture"))) return r.UNSIGNED_INT_24_8_WEBGL
                        }
                        return 0
                    }
                }
            }

            function Ui() {
                Ze.call(this), this.type = "Group"
            }

            function zi() {
                Ze.call(this), this.type = "Camera", this.matrixWorldInverse = new we, this.projectionMatrix = new we, this.projectionMatrixInverse = new we
            }

            function Gi(t, e, n, i) {
                zi.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function ji(t) {
                Gi.call(this), this.cameras = t || []
            }

            function Vi(t) {
                var e = this,
                    n = null,
                    i = null,
                    r = null,
                    o = [],
                    a = new we,
                    s = new we,
                    c = "stage";
                "undefined" != typeof window && "VRFrameData" in window && (i = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", y, !1));
                var l = new we,
                    h = new Me,
                    u = new Te,
                    p = new Gi;
                p.bounds = new Le(0, 0, .5, 1), p.layers.enable(1);
                var d = new Gi;
                d.bounds = new Le(.5, 0, .5, 1), d.layers.enable(2);
                var f, m, v = new ji([p, d]);

                function g() {
                    return null !== n && !0 === n.isPresenting
                }

                function y() {
                    if (g()) {
                        var i = n.getEyeParameters("left"),
                            r = i.renderWidth,
                            o = i.renderHeight;
                        m = t.getPixelRatio(), f = t.getSize(), t.setDrawingBufferSize(2 * r, o, 1), b.start()
                    } else e.enabled && t.setDrawingBufferSize(f.width, f.height, m), b.stop()
                }
                v.layers.enable(1), v.layers.enable(2);
                var _ = [];

                function x(t) {
                    for (var e = navigator.getGamepads && navigator.getGamepads(), n = 0, i = 0, r = e.length; n < r; n++) {
                        var o = e[n];
                        if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("Spatial Controller"))) {
                            if (i === t) return o;
                            i++
                        }
                    }
                }
                this.enabled = !1, this.getController = function(t) {
                    var e = o[t];
                    return void 0 === e && ((e = new Ui).matrixAutoUpdate = !1, e.visible = !1, o[t] = e), e
                }, this.getDevice = function() {
                    return n
                }, this.setDevice = function(t) {
                    void 0 !== t && (n = t), b.setContext(t)
                }, this.setFrameOfReferenceType = function(t) {
                    c = t
                }, this.setPoseTarget = function(t) {
                    void 0 !== t && (r = t)
                }, this.getCamera = function(t) {
                    var e = "stage" === c ? 1.6 : 0;
                    if (null === n) return t.position.set(0, e, 0), t;
                    if (n.depthNear = t.near, n.depthFar = t.far, n.getFrameData(i), "stage" === c) {
                        var f = n.stageParameters;
                        f ? a.fromArray(f.sittingToStandingTransform) : a.makeTranslation(0, e, 0)
                    }
                    var m = i.pose,
                        g = null !== r ? r : t;
                    if (g.matrix.copy(a), g.matrix.decompose(g.position, g.quaternion, g.scale), null !== m.orientation && (h.fromArray(m.orientation), g.quaternion.multiply(h)), null !== m.position && (h.setFromRotationMatrix(a), u.fromArray(m.position), u.applyQuaternion(h), g.position.add(u)), g.updateMatrixWorld(), !1 === n.isPresenting) return t;
                    p.near = t.near, d.near = t.near, p.far = t.far, d.far = t.far, v.matrixWorld.copy(t.matrixWorld), v.matrixWorldInverse.copy(t.matrixWorldInverse), p.matrixWorldInverse.fromArray(i.leftViewMatrix), d.matrixWorldInverse.fromArray(i.rightViewMatrix), s.getInverse(a), "stage" === c && (p.matrixWorldInverse.multiply(s), d.matrixWorldInverse.multiply(s));
                    var y = g.parent;
                    null !== y && (l.getInverse(y.matrixWorld), p.matrixWorldInverse.multiply(l), d.matrixWorldInverse.multiply(l)), p.matrixWorld.getInverse(p.matrixWorldInverse), d.matrixWorld.getInverse(d.matrixWorldInverse), p.projectionMatrix.fromArray(i.leftProjectionMatrix), d.projectionMatrix.fromArray(i.rightProjectionMatrix), v.projectionMatrix.copy(p.projectionMatrix);
                    var b = n.getLayers();
                    if (b.length) {
                        var w = b[0];
                        null !== w.leftBounds && 4 === w.leftBounds.length && p.bounds.fromArray(w.leftBounds), null !== w.rightBounds && 4 === w.rightBounds.length && d.bounds.fromArray(w.rightBounds)
                    }
                    return function() {
                        for (var t = 0; t < o.length; t++) {
                            var e = o[t],
                                n = x(t);
                            if (void 0 !== n && void 0 !== n.pose) {
                                if (null === n.pose) return;
                                var i = n.pose;
                                !1 === i.hasPosition && e.position.set(.2, -.6, -.05), null !== i.position && e.position.fromArray(i.position), null !== i.orientation && e.quaternion.fromArray(i.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(a), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
                                var r = "Daydream Controller" === n.id ? 0 : 1;
                                _[t] !== n.buttons[r].pressed && (_[t] = n.buttons[r].pressed, !0 === _[t] ? e.dispatchEvent({
                                    type: "selectstart"
                                }) : (e.dispatchEvent({
                                    type: "selectend"
                                }), e.dispatchEvent({
                                    type: "select"
                                })))
                            } else e.visible = !1
                        }
                    }(), v
                }, this.getStandingMatrix = function() {
                    return a
                }, this.isPresenting = g;
                var b = new je;
                this.setAnimationLoop = function(t) {
                    b.setAnimationLoop(t)
                }, this.submitFrame = function() {
                    g() && n.submitFrame()
                }, this.dispose = function() {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", y)
                }
            }

            function Wi(t) {
                console.log("THREE.WebGLRenderer", n);
                var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    a = void 0 !== t.context ? t.context : null,
                    s = void 0 !== t.alpha && t.alpha,
                    u = void 0 === t.depth || t.depth,
                    p = void 0 === t.stencil || t.stencil,
                    d = void 0 !== t.antialias && t.antialias,
                    b = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    w = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    M = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    T = null,
                    E = null;
                this.domElement = e, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Y, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var S, A, P, L, R, C, O, I, D, N, V, W, X, q, Z, J, K, Q, $ = this,
                    tt = !1,
                    et = null,
                    nt = null,
                    it = null,
                    rt = -1,
                    ot = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    at = null,
                    st = null,
                    ct = new Le,
                    lt = new Le,
                    ht = null,
                    ut = 0,
                    pt = e.width,
                    dt = e.height,
                    mt = 1,
                    vt = new Le(0, 0, pt, dt),
                    gt = new Le(0, 0, pt, dt),
                    yt = !1,
                    _t = new Be,
                    wt = new function() {
                        var t = this,
                            e = null,
                            n = 0,
                            i = !1,
                            r = !1,
                            o = new Ne,
                            a = new Ee,
                            s = {
                                value: null,
                                needsUpdate: !1
                            };

                        function c() {
                            s.value !== e && (s.value = e, s.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
                        }

                        function l(e, n, i, r) {
                            var c = null !== e ? e.length : 0,
                                l = null;
                            if (0 !== c) {
                                if (l = s.value, !0 !== r || null === l) {
                                    var h = i + 4 * c,
                                        u = n.matrixWorldInverse;
                                    a.getNormalMatrix(u), (null === l || l.length < h) && (l = new Float32Array(h));
                                    for (var p = 0, d = i; p !== c; ++p, d += 4) o.copy(e[p]).applyMatrix4(u, a), o.normal.toArray(l, d), l[d + 3] = o.constant
                                }
                                s.value = l, s.needsUpdate = !0
                            }
                            return t.numPlanes = c, l
                        }
                        this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, o) {
                            var a = 0 !== t.length || r || 0 !== n || i;
                            return i = r, e = l(t, o, 0), n = t.length, a
                        }, this.beginShadows = function() {
                            r = !0, l(null)
                        }, this.endShadows = function() {
                            r = !1, c()
                        }, this.setState = function(t, o, a, h, u, p) {
                            if (!i || null === t || 0 === t.length || r && !a) r ? l(null) : c();
                            else {
                                var d = r ? 0 : n,
                                    f = 4 * d,
                                    m = u.clippingState || null;
                                s.value = m, m = l(t, h, f, p);
                                for (var v = 0; v !== f; ++v) m[v] = e[v];
                                u.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += d
                            }
                        }
                    },
                    Mt = !1,
                    Tt = !1,
                    Et = new we,
                    St = new Te;

                function At() {
                    return null === nt ? mt : 1
                }
                try {
                    var Lt = {
                        alpha: s,
                        depth: u,
                        stencil: p,
                        antialias: d,
                        premultipliedAlpha: b,
                        preserveDrawingBuffer: w,
                        powerPreference: M
                    };
                    if (e.addEventListener("webglcontextlost", It, !1), e.addEventListener("webglcontextrestored", Dt, !1), null === (S = a || e.getContext("webgl", Lt) || e.getContext("experimental-webgl", Lt))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === S.getShaderPrecisionFormat && (S.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    console.error("THREE.WebGLRenderer: " + t.message)
                }

                function Rt() {
                    A = new function(t) {
                        var e = {};
                        return {
                            get: function(n) {
                                if (void 0 !== e[n]) return e[n];
                                var i;
                                switch (n) {
                                    case "WEBGL_depth_texture":
                                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                        break;
                                    case "EXT_texture_filter_anisotropic":
                                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                        break;
                                    case "WEBGL_compressed_texture_s3tc":
                                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                        break;
                                    case "WEBGL_compressed_texture_pvrtc":
                                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                        break;
                                    default:
                                        i = t.getExtension(n)
                                }
                                return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
                            }
                        }
                    }(S), (P = new function(t, e, n) {
                        var i;

                        function r(e) {
                            if ("highp" === e) {
                                if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                                e = "mediump"
                            }
                            return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                        }
                        var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                            a = void 0 !== n.precision ? n.precision : "highp",
                            s = r(a);
                        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
                        var c = !0 === n.logarithmicDepthBuffer,
                            l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                            h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                            u = t.getParameter(t.MAX_TEXTURE_SIZE),
                            p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                            d = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                            f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                            m = t.getParameter(t.MAX_VARYING_VECTORS),
                            v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                            g = h > 0,
                            y = o || !!e.get("OES_texture_float");
                        return {
                            isWebGL2: o,
                            getMaxAnisotropy: function() {
                                if (void 0 !== i) return i;
                                var n = e.get("EXT_texture_filter_anisotropic");
                                return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                            },
                            getMaxPrecision: r,
                            precision: a,
                            logarithmicDepthBuffer: c,
                            maxTextures: l,
                            maxVertexTextures: h,
                            maxTextureSize: u,
                            maxCubemapSize: p,
                            maxAttributes: d,
                            maxVertexUniforms: f,
                            maxVaryings: m,
                            maxFragmentUniforms: v,
                            vertexTextures: g,
                            floatFragmentTextures: y,
                            floatVertexTextures: g && y
                        }
                    }(S, A, t)).isWebGL2 || (A.get("WEBGL_depth_texture"), A.get("OES_texture_float"), A.get("OES_texture_half_float"), A.get("OES_texture_half_float_linear"), A.get("OES_standard_derivatives"), A.get("OES_element_index_uint"), A.get("ANGLE_instanced_arrays")), A.get("OES_texture_float_linear"), Q = new ki(S, A, P), (L = new function(t, e, n, a) {
                        var s = new function() {
                                var e = !1,
                                    n = new Le,
                                    i = null,
                                    r = new Le(0, 0, 0, 0);
                                return {
                                    setMask: function(n) {
                                        i === n || e || (t.colorMask(n, n, n, n), i = n)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e, i, o, a, s) {
                                        !0 === s && (e *= a, i *= a, o *= a), n.set(e, i, o, a), !1 === r.equals(n) && (t.clearColor(e, i, o, a), r.copy(n))
                                    },
                                    reset: function() {
                                        e = !1, i = null, r.set(-1, 0, 0, 0)
                                    }
                                }
                            },
                            c = new function() {
                                var e = !1,
                                    n = null,
                                    i = null,
                                    r = null;
                                return {
                                    setTest: function(e) {
                                        e ? ot(t.DEPTH_TEST) : at(t.DEPTH_TEST)
                                    },
                                    setMask: function(i) {
                                        n === i || e || (t.depthMask(i), n = i)
                                    },
                                    setFunc: function(e) {
                                        if (i !== e) {
                                            if (e) switch (e) {
                                                case B:
                                                    t.depthFunc(t.NEVER);
                                                    break;
                                                case H:
                                                    t.depthFunc(t.ALWAYS);
                                                    break;
                                                case F:
                                                    t.depthFunc(t.LESS);
                                                    break;
                                                case k:
                                                    t.depthFunc(t.LEQUAL);
                                                    break;
                                                case U:
                                                    t.depthFunc(t.EQUAL);
                                                    break;
                                                case z:
                                                    t.depthFunc(t.GEQUAL);
                                                    break;
                                                case G:
                                                    t.depthFunc(t.GREATER);
                                                    break;
                                                case j:
                                                    t.depthFunc(t.NOTEQUAL);
                                                    break;
                                                default:
                                                    t.depthFunc(t.LEQUAL)
                                            } else t.depthFunc(t.LEQUAL);
                                            i = e
                                        }
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        r !== e && (t.clearDepth(e), r = e)
                                    },
                                    reset: function() {
                                        e = !1, n = null, i = null, r = null
                                    }
                                }
                            },
                            u = new function() {
                                var e = !1,
                                    n = null,
                                    i = null,
                                    r = null,
                                    o = null,
                                    a = null,
                                    s = null,
                                    c = null,
                                    l = null;
                                return {
                                    setTest: function(e) {
                                        e ? ot(t.STENCIL_TEST) : at(t.STENCIL_TEST)
                                    },
                                    setMask: function(i) {
                                        n === i || e || (t.stencilMask(i), n = i)
                                    },
                                    setFunc: function(e, n, a) {
                                        i === e && r === n && o === a || (t.stencilFunc(e, n, a), i = e, r = n, o = a)
                                    },
                                    setOp: function(e, n, i) {
                                        a === e && s === n && c === i || (t.stencilOp(e, n, i), a = e, s = n, c = i)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        l !== e && (t.clearStencil(e), l = e)
                                    },
                                    reset: function() {
                                        e = !1, n = null, i = null, r = null, o = null, a = null, s = null, c = null, l = null
                                    }
                                }
                            },
                            p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                            d = new Uint8Array(p),
                            b = new Uint8Array(p),
                            w = new Uint8Array(p),
                            M = {},
                            T = null,
                            E = null,
                            S = null,
                            A = null,
                            P = null,
                            L = null,
                            R = null,
                            C = null,
                            O = null,
                            I = null,
                            D = !1,
                            N = null,
                            V = null,
                            W = null,
                            X = null,
                            q = null,
                            Y = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                            Z = !1,
                            J = 0,
                            K = t.getParameter(t.VERSION); - 1 !== K.indexOf("WebGL") ? (J = parseFloat(/^WebGL\ ([0-9])/.exec(K)[1]), Z = J >= 1) : -1 !== K.indexOf("OpenGL ES") && (J = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(K)[1]), Z = J >= 2);
                        var Q = null,
                            $ = {},
                            tt = new Le,
                            et = new Le;

                        function nt(e, n, i) {
                            var r = new Uint8Array(4),
                                o = t.createTexture();
                            t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                            for (var a = 0; a < i; a++) t.texImage2D(n + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                            return o
                        }
                        var it = {};

                        function rt(n, i) {
                            if (d[n] = 1, 0 === b[n] && (t.enableVertexAttribArray(n), b[n] = 1), w[n] !== i) {
                                var r = a.isWebGL2 ? t : e.get("ANGLE_instanced_arrays");
                                r[a.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), w[n] = i
                            }
                        }

                        function ot(e) {
                            !0 !== M[e] && (t.enable(e), M[e] = !0)
                        }

                        function at(e) {
                            !1 !== M[e] && (t.disable(e), M[e] = !1)
                        }

                        function st(e, i, r, o, a, s, c, l) {
                            if (e !== f) {
                                if (S || (ot(t.BLEND), S = !0), e === _) a = a || i, s = s || r, c = c || o, i === P && a === C || (t.blendEquationSeparate(n.convert(i), n.convert(a)), P = i, C = a), r === L && o === R && s === O && c === I || (t.blendFuncSeparate(n.convert(r), n.convert(o), n.convert(s), n.convert(c)), L = r, R = o, O = s, I = c), A = e, D = null;
                                else if (e !== A || l !== D) {
                                    if (P === x && C === x || (t.blendEquation(t.FUNC_ADD), P = x, C = x), l) switch (e) {
                                        case m:
                                            t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case v:
                                            t.blendFunc(t.ONE, t.ONE);
                                            break;
                                        case g:
                                            t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case y:
                                            t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    } else switch (e) {
                                        case m:
                                            t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case v:
                                            t.blendFunc(t.SRC_ALPHA, t.ONE);
                                            break;
                                        case g:
                                            t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR);
                                            break;
                                        case y:
                                            t.blendFunc(t.ZERO, t.SRC_COLOR);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    }
                                    L = null, R = null, O = null, I = null, A = e, D = l
                                }
                            } else S && (at(t.BLEND), S = !1)
                        }

                        function ct(e) {
                            N !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), N = e)
                        }

                        function lt(e) {
                            e !== i ? (ot(t.CULL_FACE), e !== V && (e === r ? t.cullFace(t.BACK) : e === o ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : at(t.CULL_FACE), V = e
                        }

                        function ht(e, n, i) {
                            e ? (ot(t.POLYGON_OFFSET_FILL), X === n && q === i || (t.polygonOffset(n, i), X = n, q = i)) : at(t.POLYGON_OFFSET_FILL)
                        }

                        function ut(e) {
                            void 0 === e && (e = t.TEXTURE0 + Y - 1), Q !== e && (t.activeTexture(e), Q = e)
                        }
                        return it[t.TEXTURE_2D] = nt(t.TEXTURE_2D, t.TEXTURE_2D, 1), it[t.TEXTURE_CUBE_MAP] = nt(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), s.setClear(0, 0, 0, 1), c.setClear(1), u.setClear(0), ot(t.DEPTH_TEST), c.setFunc(k), ct(!1), lt(r), ot(t.CULL_FACE), st(f), {
                            buffers: {
                                color: s,
                                depth: c,
                                stencil: u
                            },
                            initAttributes: function() {
                                for (var t = 0, e = d.length; t < e; t++) d[t] = 0
                            },
                            enableAttribute: function(t) {
                                rt(t, 0)
                            },
                            enableAttributeAndDivisor: rt,
                            disableUnusedAttributes: function() {
                                for (var e = 0, n = b.length; e !== n; ++e) b[e] !== d[e] && (t.disableVertexAttribArray(e), b[e] = 0)
                            },
                            enable: ot,
                            disable: at,
                            getCompressedTextureFormats: function() {
                                if (null === T && (T = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                                    for (var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0; i < n.length; i++) T.push(n[i]);
                                return T
                            },
                            useProgram: function(e) {
                                return E !== e && (t.useProgram(e), E = e, !0)
                            },
                            setBlending: st,
                            setMaterial: function(e, n) {
                                e.side === h ? at(t.CULL_FACE) : ot(t.CULL_FACE);
                                var i = e.side === l;
                                n && (i = !i), ct(i), e.blending === m && !1 === e.transparent ? st(f) : st(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), c.setFunc(e.depthFunc), c.setTest(e.depthTest), c.setMask(e.depthWrite), s.setMask(e.colorWrite), ht(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                            },
                            setFlipSided: ct,
                            setCullFace: lt,
                            setLineWidth: function(e) {
                                e !== W && (Z && t.lineWidth(e), W = e)
                            },
                            setPolygonOffset: ht,
                            setScissorTest: function(e) {
                                e ? ot(t.SCISSOR_TEST) : at(t.SCISSOR_TEST)
                            },
                            activeTexture: ut,
                            bindTexture: function(e, n) {
                                null === Q && ut();
                                var i = $[Q];
                                void 0 === i && (i = {
                                    type: void 0,
                                    texture: void 0
                                }, $[Q] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || it[e]), i.type = e, i.texture = n)
                            },
                            compressedTexImage2D: function() {
                                try {
                                    t.compressedTexImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage2D: function() {
                                try {
                                    t.texImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage3D: function() {
                                try {
                                    t.texImage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            scissor: function(e) {
                                !1 === tt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), tt.copy(e))
                            },
                            viewport: function(e) {
                                !1 === et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), et.copy(e))
                            },
                            reset: function() {
                                for (var e = 0; e < b.length; e++) 1 === b[e] && (t.disableVertexAttribArray(e), b[e] = 0);
                                M = {}, T = null, Q = null, $ = {}, E = null, A = null, N = null, V = null, s.reset(), c.reset(), u.reset()
                            }
                        }
                    }(S, A, Q, P)).scissor(lt.copy(gt).multiplyScalar(mt)), L.viewport(ct.copy(vt).multiplyScalar(mt)), R = new function(t) {
                        var e = {
                            frame: 0,
                            calls: 0,
                            triangles: 0,
                            points: 0,
                            lines: 0
                        };
                        return {
                            memory: {
                                geometries: 0,
                                textures: 0
                            },
                            render: e,
                            programs: null,
                            autoReset: !0,
                            reset: function() {
                                e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                            },
                            update: function(n, i, r) {
                                switch (r = r || 1, e.calls++, i) {
                                    case t.TRIANGLES:
                                        e.triangles += r * (n / 3);
                                        break;
                                    case t.TRIANGLE_STRIP:
                                    case t.TRIANGLE_FAN:
                                        e.triangles += r * (n - 2);
                                        break;
                                    case t.LINES:
                                        e.lines += r * (n / 2);
                                        break;
                                    case t.LINE_STRIP:
                                        e.lines += r * (n - 1);
                                        break;
                                    case t.LINE_LOOP:
                                        e.lines += r * n;
                                        break;
                                    case t.POINTS:
                                        e.points += r * n;
                                        break;
                                    default:
                                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                                }
                            }
                        }
                    }(S), C = new function() {
                        var t = new WeakMap;
                        return {
                            get: function(e) {
                                var n = t.get(e);
                                return void 0 === n && (n = {}, t.set(e, n)), n
                            },
                            remove: function(e) {
                                t.delete(e)
                            },
                            update: function(e, n, i) {
                                t.get(e)[n] = i
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }, O = new Fi(S, A, L, C, P, Q, R), I = new Ve(S), D = new function(t, e, n) {
                        var i = {},
                            r = {};

                        function o(t) {
                            var a = t.target,
                                s = i[a.id];
                            for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]);
                            a.removeEventListener("dispose", o), delete i[a.id];
                            var l = r[s.id];
                            l && (e.remove(l), delete r[s.id]), n.memory.geometries--
                        }
                        return {
                            get: function(t, e) {
                                var r = i[e.id];
                                return r || (e.addEventListener("dispose", o), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new pn).setFromObject(t)), r = e._bufferGeometry), i[e.id] = r, n.memory.geometries++, r)
                            },
                            update: function(n) {
                                var i = n.index,
                                    r = n.attributes;
                                for (var o in null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER), r) e.update(r[o], t.ARRAY_BUFFER);
                                var a = n.morphAttributes;
                                for (var o in a)
                                    for (var s = a[o], c = 0, l = s.length; c < l; c++) e.update(s[c], t.ARRAY_BUFFER)
                            },
                            getWireframeAttribute: function(n) {
                                var i = r[n.id];
                                if (i) return i;
                                var o = [],
                                    a = n.index,
                                    s = n.attributes;
                                if (null !== a)
                                    for (var c = a.array, l = 0, h = c.length; l < h; l += 3) {
                                        var u = c[l + 0],
                                            p = c[l + 1],
                                            d = c[l + 2];
                                        o.push(u, p, p, d, d, u)
                                    } else
                                        for (var c = s.position.array, l = 0, h = c.length / 3 - 1; l < h; l += 3) {
                                            var u = l + 0,
                                                p = l + 1,
                                                d = l + 2;
                                            o.push(u, p, p, d, d, u)
                                        }
                                return i = new(hn(o) > 65535 ? an : rn)(o, 1), e.update(i, t.ELEMENT_ARRAY_BUFFER), r[n.id] = i, i
                            }
                        }
                    }(S, I, R), N = new function(t, e) {
                        var n = {};
                        return {
                            update: function(i) {
                                var r = e.render.frame,
                                    o = i.geometry,
                                    a = t.get(i, o);
                                return n[a.id] !== r && (o.isGeometry && a.updateFromObject(i), t.update(a), n[a.id] = r), a
                            },
                            dispose: function() {
                                n = {}
                            }
                        }
                    }(D, R), Z = new function(t) {
                        var e = {},
                            n = new Float32Array(8);
                        return {
                            update: function(i, r, o, a) {
                                var s = i.morphTargetInfluences,
                                    c = s.length,
                                    l = e[r.id];
                                if (void 0 === l) {
                                    l = [];
                                    for (var h = 0; h < c; h++) l[h] = [h, 0];
                                    e[r.id] = l
                                }
                                for (var u = o.morphTargets && r.morphAttributes.position, p = o.morphNormals && r.morphAttributes.normal, h = 0; h < c; h++) {
                                    var d = l[h];
                                    0 !== d[1] && (u && r.removeAttribute("morphTarget" + h), p && r.removeAttribute("morphNormal" + h))
                                }
                                for (var h = 0; h < c; h++) {
                                    var d = l[h];
                                    d[0] = h, d[1] = s[h]
                                }
                                l.sort(Tn);
                                for (var h = 0; h < 8; h++) {
                                    var d = l[h];
                                    if (d) {
                                        var f = d[0],
                                            m = d[1];
                                        if (m) {
                                            u && r.addAttribute("morphTarget" + h, u[f]), p && r.addAttribute("morphNormal" + h, p[f]), n[h] = m;
                                            continue
                                        }
                                    }
                                    n[h] = 0
                                }
                                a.getUniforms().setValue(t, "morphTargetInfluences", n)
                            }
                        }
                    }(S), V = new Ai($, A, P), W = new Ri, X = new function() {
                        var t = {};
                        return {
                            get: function(e, n) {
                                var i;
                                return void 0 === t[e.id] ? (i = new Di, t[e.id] = {}, t[e.id][n.id] = i) : void 0 === t[e.id][n.id] ? (i = new Di, t[e.id][n.id] = i) : i = t[e.id][n.id], i
                            },
                            dispose: function() {
                                t = {}
                            }
                        }
                    }, q = new function(t, e, n, i) {
                        var r, o, a = new Ue(0),
                            s = 0;

                        function h(t, n) {
                            e.buffers.color.setClear(t.r, t.g, t.b, n, i)
                        }
                        return {
                            getClearColor: function() {
                                return a
                            },
                            setClearColor: function(t, e) {
                                a.set(t), h(a, s = void 0 !== e ? e : 1)
                            },
                            getClearAlpha: function() {
                                return s
                            },
                            setClearAlpha: function(t) {
                                h(a, s = t)
                            },
                            render: function(e, i, u, p) {
                                var d = i.background;
                                null === d ? h(a, s) : d && d.isColor && (h(d, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && d.isCubeTexture ? (void 0 === o && ((o = new Mn(new fn(1, 1, 1), new _n({
                                    uniforms: Fe.clone(Ge.cube.uniforms),
                                    vertexShader: Ge.cube.vertexShader,
                                    fragmentShader: Ge.cube.fragmentShader,
                                    side: l,
                                    depthTest: !0,
                                    depthWrite: !1,
                                    fog: !1
                                }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(t, e, n) {
                                    this.matrixWorld.copyPosition(n.matrixWorld)
                                }, n.update(o)), o.material.uniforms.tCube.value = d, e.push(o, o.geometry, o.material, 0, null)) : d && d.isTexture && (void 0 === r && ((r = new Mn(new vn(2, 2), new _n({
                                    uniforms: Fe.clone(Ge.background.uniforms),
                                    vertexShader: Ge.background.vertexShader,
                                    fragmentShader: Ge.background.fragmentShader,
                                    side: c,
                                    depthTest: !0,
                                    depthWrite: !1,
                                    fog: !1
                                }))).geometry.removeAttribute("normal"), n.update(r)), r.material.uniforms.t2D.value = d, e.push(r, r.geometry, r.material, 0, null))
                            }
                        }
                    }($, L, N, b), J = new function(t, e, n, i) {
                        var r;
                        this.setMode = function(t) {
                            r = t
                        }, this.render = function(e, i) {
                            t.drawArrays(r, e, i), n.update(i, r)
                        }, this.renderInstances = function(o, a, s) {
                            var c;
                            if (i.isWebGL2) c = t;
                            else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            c[i.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, a, s, o.maxInstancedCount), n.update(s, r, o.maxInstancedCount)
                        }
                    }(S, A, R, P), K = new function(t, e, n, i) {
                        var r, o, a;
                        this.setMode = function(t) {
                            r = t
                        }, this.setIndex = function(t) {
                            o = t.type, a = t.bytesPerElement
                        }, this.render = function(e, i) {
                            t.drawElements(r, i, o, e * a), n.update(i, r)
                        }, this.renderInstances = function(s, c, l) {
                            if (i.isWebGL2) h = t;
                            else {
                                var h = e.get("ANGLE_instanced_arrays");
                                if (null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                            }
                            h[i.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, l, o, c * a, s.maxInstancedCount), n.update(l, r, s.maxInstancedCount)
                        }
                    }(S, A, R, P), R.programs = V.programs, $.context = S, $.capabilities = P, $.extensions = A, $.properties = C, $.renderLists = W, $.state = L, $.info = R
                }
                Rt();
                var Ct = null;
                "undefined" != typeof navigator && (Ct = "xr" in navigator ? new function(t) {
                    var e = t.context,
                        n = null,
                        i = null,
                        r = null,
                        o = "stage",
                        a = null,
                        s = [],
                        c = [];

                    function l() {
                        return null !== i && null !== r
                    }
                    var h = new Gi;
                    h.layers.enable(1), h.viewport = new Le;
                    var u = new Gi;
                    u.layers.enable(2), u.viewport = new Le;
                    var p = new ji([h, u]);

                    function d(t) {
                        var e = s[c.indexOf(t.inputSource)];
                        e && e.dispatchEvent({
                            type: t.type
                        })
                    }

                    function f() {
                        t.setFramebuffer(null), g.stop()
                    }

                    function m(t, e) {
                        null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                    }
                    p.layers.enable(1), p.layers.enable(2), this.enabled = !1, this.getController = function(t) {
                        var e = s[t];
                        return void 0 === e && ((e = new Ui).matrixAutoUpdate = !1, e.visible = !1, s[t] = e), e
                    }, this.getDevice = function() {
                        return n
                    }, this.setDevice = function(t) {
                        void 0 !== t && (n = t), t instanceof XRDevice && e.setCompatibleXRDevice(t)
                    }, this.setFrameOfReferenceType = function(t) {
                        o = t
                    }, this.setSession = function(n) {
                        null !== (i = n) && (i.addEventListener("select", d), i.addEventListener("selectstart", d), i.addEventListener("selectend", d), i.addEventListener("end", f), i.baseLayer = new XRWebGLLayer(i, e), i.requestFrameOfReference(o).then(function(e) {
                            r = e, t.setFramebuffer(i.baseLayer.framebuffer), g.setContext(i), g.start()
                        }), c = i.getInputSources(), i.addEventListener("inputsourceschange", function() {
                            c = i.getInputSources(), console.log(c)
                        }))
                    }, this.getCamera = function(t) {
                        if (l()) {
                            var e = t.parent,
                                n = p.cameras;
                            m(p, e);
                            for (var i = 0; i < n.length; i++) m(n[i], e);
                            t.matrixWorld.copy(p.matrixWorld);
                            for (var r = t.children, i = 0, o = r.length; i < o; i++) r[i].updateMatrixWorld(!0);
                            return p
                        }
                        return t
                    }, this.isPresenting = l;
                    var v = null,
                        g = new je;
                    g.setAnimationLoop(function(t, e) {
                        if (null !== (a = e.getDevicePose(r)))
                            for (var n = i.baseLayer, o = e.views, l = 0; l < o.length; l++) {
                                var h = o[l],
                                    u = n.getViewport(h),
                                    d = a.getViewMatrix(h),
                                    f = p.cameras[l];
                                f.matrix.fromArray(d).getInverse(f.matrix), f.projectionMatrix.fromArray(h.projectionMatrix), f.viewport.set(u.x, u.y, u.width, u.height), 0 === l && (p.matrix.copy(f.matrix), p.projectionMatrix.copy(f.projectionMatrix))
                            }
                        for (var l = 0; l < s.length; l++) {
                            var m = s[l],
                                g = c[l];
                            if (g) {
                                var y = e.getInputPose(g, r);
                                if (null !== y) {
                                    "targetRay" in y ? m.matrix.elements = y.targetRay.transformMatrix : "pointerMatrix" in y && (m.matrix.elements = y.pointerMatrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.visible = !0;
                                    continue
                                }
                            }
                            m.visible = !1
                        }
                        v && v(t)
                    }), this.setAnimationLoop = function(t) {
                        v = t
                    }, this.dispose = function() {}, this.getStandingMatrix = function() {
                        return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4
                    }, this.submitFrame = function() {}
                }($) : new Vi($)), this.vr = Ct;
                var Ot = new Hi($, N, P.maxTextureSize);

                function It(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), tt = !0
                }

                function Dt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), tt = !1, Rt()
                }

                function Nt(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", Nt),
                        function(t) {
                            Bt(t), C.remove(t)
                        }(e)
                }

                function Bt(t) {
                    var e = C.get(t).program;
                    t.program = void 0, void 0 !== e && V.releaseProgram(e)
                }
                this.shadowMap = Ot, this.getContext = function() {
                    return S
                }, this.getContextAttributes = function() {
                    return S.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var t = A.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    var t = A.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return mt
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (mt = t, this.setSize(pt, dt, !1))
                }, this.getSize = function() {
                    return {
                        width: pt,
                        height: dt
                    }
                }, this.setSize = function(t, n, i) {
                    Ct.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (pt = t, dt = n, e.width = t * mt, e.height = n * mt, !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function() {
                    return {
                        width: pt * mt,
                        height: dt * mt
                    }
                }, this.setDrawingBufferSize = function(t, n, i) {
                    pt = t, dt = n, mt = i, e.width = t * i, e.height = n * i, this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function() {
                    return ct
                }, this.setViewport = function(t, e, n, i) {
                    vt.set(t, dt - e - i, n, i), L.viewport(ct.copy(vt).multiplyScalar(mt))
                }, this.setScissor = function(t, e, n, i) {
                    gt.set(t, dt - e - i, n, i), L.scissor(lt.copy(gt).multiplyScalar(mt))
                }, this.setScissorTest = function(t) {
                    L.setScissorTest(yt = t)
                }, this.getClearColor = function() {
                    return q.getClearColor()
                }, this.setClearColor = function() {
                    q.setClearColor.apply(q, arguments)
                }, this.getClearAlpha = function() {
                    return q.getClearAlpha()
                }, this.setClearAlpha = function() {
                    q.setClearAlpha.apply(q, arguments)
                }, this.clear = function(t, e, n) {
                    var i = 0;
                    (void 0 === t || t) && (i |= S.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= S.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= S.STENCIL_BUFFER_BIT), S.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", It, !1), e.removeEventListener("webglcontextrestored", Dt, !1), W.dispose(), X.dispose(), C.dispose(), N.dispose(), Ct.dispose(), Ft.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    L.initAttributes();
                    var n = C.get(t);
                    t.hasPositions && !n.position && (n.position = S.createBuffer()), t.hasNormals && !n.normal && (n.normal = S.createBuffer()), t.hasUvs && !n.uv && (n.uv = S.createBuffer()), t.hasColors && !n.color && (n.color = S.createBuffer());
                    var i = e.getAttributes();
                    t.hasPositions && (S.bindBuffer(S.ARRAY_BUFFER, n.position), S.bufferData(S.ARRAY_BUFFER, t.positionArray, S.DYNAMIC_DRAW), L.enableAttribute(i.position), S.vertexAttribPointer(i.position, 3, S.FLOAT, !1, 0, 0)), t.hasNormals && (S.bindBuffer(S.ARRAY_BUFFER, n.normal), S.bufferData(S.ARRAY_BUFFER, t.normalArray, S.DYNAMIC_DRAW), L.enableAttribute(i.normal), S.vertexAttribPointer(i.normal, 3, S.FLOAT, !1, 0, 0)), t.hasUvs && (S.bindBuffer(S.ARRAY_BUFFER, n.uv), S.bufferData(S.ARRAY_BUFFER, t.uvArray, S.DYNAMIC_DRAW), L.enableAttribute(i.uv), S.vertexAttribPointer(i.uv, 2, S.FLOAT, !1, 0, 0)), t.hasColors && (S.bindBuffer(S.ARRAY_BUFFER, n.color), S.bufferData(S.ARRAY_BUFFER, t.colorArray, S.DYNAMIC_DRAW), L.enableAttribute(i.color), S.vertexAttribPointer(i.color, 3, S.FLOAT, !1, 0, 0)), L.disableUnusedAttributes(), S.drawArrays(S.TRIANGLES, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, n, i, r, o) {
                    var a = r.isMesh && r.normalMatrix.determinant() < 0;
                    L.setMaterial(i, a);
                    var s = Gt(t, e, i, r),
                        c = !1;
                    ot.geometry === n.id && ot.program === s.id && ot.wireframe === (!0 === i.wireframe) || (ot.geometry = n.id, ot.program = s.id, ot.wireframe = !0 === i.wireframe, c = !0), r.morphTargetInfluences && (Z.update(r, n, i, s), c = !0);
                    var l, h = n.index,
                        u = n.attributes.position,
                        p = 1;
                    !0 === i.wireframe && (h = D.getWireframeAttribute(n), p = 2);
                    var d = J;
                    null !== h && (l = I.get(h), (d = K).setIndex(l)), c && (function(t, e, n) {
                        if (n && n.isInstancedBufferGeometry & !P.isWebGL2 && null === A.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        else {
                            L.initAttributes();
                            var i = n.attributes,
                                r = e.getAttributes(),
                                o = t.defaultAttributeValues;
                            for (var a in r) {
                                var s = r[a];
                                if (s >= 0) {
                                    var c = i[a];
                                    if (void 0 !== c) {
                                        var l = c.normalized,
                                            h = c.itemSize,
                                            u = I.get(c);
                                        if (void 0 === u) continue;
                                        var p = u.buffer,
                                            d = u.type,
                                            f = u.bytesPerElement;
                                        if (c.isInterleavedBufferAttribute) {
                                            var m = c.data,
                                                v = m.stride,
                                                g = c.offset;
                                            m && m.isInstancedInterleavedBuffer ? (L.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : L.enableAttribute(s), S.bindBuffer(S.ARRAY_BUFFER, p), S.vertexAttribPointer(s, h, d, l, v * f, g * f)
                                        } else c.isInstancedBufferAttribute ? (L.enableAttributeAndDivisor(s, c.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = c.meshPerAttribute * c.count)) : L.enableAttribute(s), S.bindBuffer(S.ARRAY_BUFFER, p), S.vertexAttribPointer(s, h, d, l, 0, 0)
                                    } else if (void 0 !== o) {
                                        var y = o[a];
                                        if (void 0 !== y) switch (y.length) {
                                            case 2:
                                                S.vertexAttrib2fv(s, y);
                                                break;
                                            case 3:
                                                S.vertexAttrib3fv(s, y);
                                                break;
                                            case 4:
                                                S.vertexAttrib4fv(s, y);
                                                break;
                                            default:
                                                S.vertexAttrib1fv(s, y)
                                        }
                                    }
                                }
                            }
                            L.disableUnusedAttributes()
                        }
                    }(i, s, n), null !== h && S.bindBuffer(S.ELEMENT_ARRAY_BUFFER, l.buffer));
                    var f = 1 / 0;
                    null !== h ? f = h.count : void 0 !== u && (f = u.count);
                    var m = n.drawRange.start * p,
                        v = n.drawRange.count * p,
                        g = null !== o ? o.start * p : 0,
                        y = null !== o ? o.count * p : 1 / 0,
                        _ = Math.max(m, g),
                        x = Math.min(f, m + v, g + y) - 1,
                        b = Math.max(0, x - _ + 1);
                    if (0 !== b) {
                        if (r.isMesh)
                            if (!0 === i.wireframe) L.setLineWidth(i.wireframeLinewidth * At()), d.setMode(S.LINES);
                            else switch (r.drawMode) {
                                case ae:
                                    d.setMode(S.TRIANGLES);
                                    break;
                                case se:
                                    d.setMode(S.TRIANGLE_STRIP);
                                    break;
                                case ce:
                                    d.setMode(S.TRIANGLE_FAN)
                            } else if (r.isLine) {
                                var w = i.linewidth;
                                void 0 === w && (w = 1), L.setLineWidth(w * At()), r.isLineSegments ? d.setMode(S.LINES) : r.isLineLoop ? d.setMode(S.LINE_LOOP) : d.setMode(S.LINE_STRIP)
                            } else r.isPoints ? d.setMode(S.POINTS) : r.isSprite && d.setMode(S.TRIANGLES);
                        n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && d.renderInstances(n, _, b) : d.render(_, b)
                    }
                }, this.compile = function(t, e) {
                    (E = X.get(t, e)).init(), t.traverse(function(t) {
                        t.isLight && (E.pushLight(t), t.castShadow && E.pushShadow(t))
                    }), E.setupLights(e), t.traverse(function(e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var n = 0; n < e.material.length; n++) zt(e.material[n], t.fog, e);
                            else zt(e.material, t.fog, e)
                    })
                };
                var Ht = null,
                    Ft = new je;

                function kt(t, e, n, i) {
                    for (var r = 0, o = t.length; r < o; r++) {
                        var a = t[r],
                            s = a.object,
                            c = a.geometry,
                            l = void 0 === i ? a.material : i,
                            h = a.group;
                        if (n.isArrayCamera) {
                            st = n;
                            for (var u = n.cameras, p = 0, d = u.length; p < d; p++) {
                                var f = u[p];
                                if (s.layers.test(f.layers)) {
                                    if ("viewport" in f) L.viewport(ct.copy(f.viewport));
                                    else {
                                        var m = f.bounds,
                                            v = m.x * pt,
                                            g = m.y * dt,
                                            y = m.z * pt,
                                            _ = m.w * dt;
                                        L.viewport(ct.set(v, g, y, _).multiplyScalar(mt))
                                    }
                                    E.setupLights(f), Ut(s, e, f, c, l, h)
                                }
                            }
                        } else st = null, Ut(s, e, n, c, l, h)
                    }
                }

                function Ut(t, e, n, i, r, o) {
                    if (t.onBeforeRender($, e, n, i, r, o), E = X.get(e, st || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        L.setMaterial(r);
                        var a = Gt(n, e.fog, r, t);
                        ot.geometry = null, ot.program = null, ot.wireframe = !1,
                            function(t, e) {
                                t.render(function(t) {
                                    $.renderBufferImmediate(t, e)
                                })
                            }(t, a)
                    } else $.renderBufferDirect(n, e.fog, i, r, t, o);
                    t.onAfterRender($, e, n, i, r, o), E = X.get(e, st || n)
                }

                function zt(t, e, n) {
                    var i = C.get(t),
                        r = E.state.lights,
                        o = E.state.shadowsArray,
                        a = i.lightsHash,
                        s = r.state.hash,
                        c = V.getParameters(t, r.state, o, e, wt.numPlanes, wt.numIntersection, n),
                        l = V.getProgramCode(t, c),
                        h = i.program,
                        u = !0;
                    if (void 0 === h) t.addEventListener("dispose", Nt);
                    else if (h.code !== l) Bt(t);
                    else if (a.stateID !== s.stateID || a.directionalLength !== s.directionalLength || a.pointLength !== s.pointLength || a.spotLength !== s.spotLength || a.rectAreaLength !== s.rectAreaLength || a.hemiLength !== s.hemiLength || a.shadowsLength !== s.shadowsLength) a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, u = !1;
                    else {
                        if (void 0 !== c.shaderID) return;
                        u = !1
                    }
                    if (u) {
                        if (c.shaderID) {
                            var p = Ge[c.shaderID];
                            i.shader = {
                                name: t.type,
                                uniforms: Fe.clone(p.uniforms),
                                vertexShader: p.vertexShader,
                                fragmentShader: p.fragmentShader
                            }
                        } else i.shader = {
                            name: t.type,
                            uniforms: t.uniforms,
                            vertexShader: t.vertexShader,
                            fragmentShader: t.fragmentShader
                        };
                        t.onBeforeCompile(i.shader, $), l = V.getProgramCode(t, c), h = V.acquireProgram(t, i.shader, c, l), i.program = h, t.program = h
                    }
                    var d = h.getAttributes();
                    if (t.morphTargets) {
                        t.numSupportedMorphTargets = 0;
                        for (var f = 0; f < $.maxMorphTargets; f++) d["morphTarget" + f] >= 0 && t.numSupportedMorphTargets++
                    }
                    if (t.morphNormals) {
                        t.numSupportedMorphNormals = 0;
                        for (var f = 0; f < $.maxMorphNormals; f++) d["morphNormal" + f] >= 0 && t.numSupportedMorphNormals++
                    }
                    var m = i.shader.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = wt.numPlanes, i.numIntersection = wt.numIntersection, m.clippingPlanes = wt.uniform), i.fog = e, void 0 === a && (i.lightsHash = a = {}), a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, t.lights && (m.ambientLightColor.value = r.state.ambient, m.directionalLights.value = r.state.directional, m.spotLights.value = r.state.spot, m.rectAreaLights.value = r.state.rectArea, m.pointLights.value = r.state.point, m.hemisphereLights.value = r.state.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    var v = i.program.getUniforms(),
                        g = vi.seqWithValue(v.seq, m);
                    i.uniformsList = g
                }

                function Gt(t, e, n, i) {
                    ut = 0;
                    var r = C.get(n),
                        o = E.state.lights,
                        a = r.lightsHash,
                        s = o.state.hash;
                    if (Mt && (Tt || t !== at)) {
                        var c = t === at && n.id === rt;
                        wt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, c)
                    }!1 === n.needsUpdate && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== e ? n.needsUpdate = !0 : (!n.lights || a.stateID === s.stateID && a.directionalLength === s.directionalLength && a.pointLength === s.pointLength && a.spotLength === s.spotLength && a.rectAreaLength === s.rectAreaLength && a.hemiLength === s.hemiLength && a.shadowsLength === s.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === wt.numPlanes && r.numIntersection === wt.numIntersection) || (n.needsUpdate = !0)), n.needsUpdate && (zt(n, e, i), n.needsUpdate = !1);
                    var h = !1,
                        u = !1,
                        p = !1,
                        d = r.program,
                        f = d.getUniforms(),
                        m = r.shader.uniforms;
                    if (L.useProgram(d.program) && (h = !0, u = !0, p = !0), n.id !== rt && (rt = n.id, u = !0), h || at !== t) {
                        if (f.setValue(S, "projectionMatrix", t.projectionMatrix), P.logarithmicDepthBuffer && f.setValue(S, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), at !== t && (at = t, u = !0, p = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var v = f.map.cameraPosition;
                            void 0 !== v && v.setValue(S, St.setFromMatrixPosition(t.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && f.setValue(S, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        f.setOptional(S, i, "bindMatrix"), f.setOptional(S, i, "bindMatrixInverse");
                        var g = i.skeleton;
                        if (g) {
                            var y = g.bones;
                            if (P.floatVertexTextures) {
                                if (void 0 === g.boneTexture) {
                                    var _ = Math.sqrt(4 * y.length);
                                    _ = xe.ceilPowerOfTwo(_), _ = Math.max(_, 4);
                                    var x = new Float32Array(_ * _ * 4);
                                    x.set(g.boneMatrices);
                                    var b = new Oe(x, _, _, Pt, xt);
                                    b.needsUpdate = !0, g.boneMatrices = x, g.boneTexture = b, g.boneTextureSize = _
                                }
                                f.setValue(S, "boneTexture", g.boneTexture), f.setValue(S, "boneTextureSize", g.boneTextureSize)
                            } else f.setOptional(S, g, "boneMatrices")
                        }
                    }
                    return u && (f.setValue(S, "toneMappingExposure", $.toneMappingExposure), f.setValue(S, "toneMappingWhitePoint", $.toneMappingWhitePoint), n.lights && function(t, e) {
                        t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                    }(m, p), e && n.fog && function(t, e) {
                        t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    }(m, e), n.isMeshBasicMaterial ? jt(m, n) : n.isMeshLambertMaterial ? (jt(m, n), function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(m, n)) : n.isMeshPhongMaterial ? (jt(m, n), n.isMeshToonMaterial ? function(t, e) {
                        Vt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(m, n) : Vt(m, n)) : n.isMeshStandardMaterial ? (jt(m, n), n.isMeshPhysicalMaterial ? function(t, e) {
                        Wt(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness
                    }(m, n) : Wt(m, n)) : n.isMeshMatcapMaterial ? (jt(m, n), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === l && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === l && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(m, n)) : n.isMeshDepthMaterial ? (jt(m, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(m, n)) : n.isMeshDistanceMaterial ? (jt(m, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(m, n)) : n.isMeshNormalMaterial ? (jt(m, n), function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === l && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === l && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(m, n)) : n.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity
                    }(m, n), n.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(m, n)) : n.isPointsMaterial ? function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * mt, t.scale.value = .5 * dt, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(m, n) : n.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity, t.rotation.value = e.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(m, n) : n.isShadowMaterial && (m.color.value = n.color, m.opacity.value = n.opacity), void 0 !== m.ltc_1 && (m.ltc_1.value = ze.LTC_1), void 0 !== m.ltc_2 && (m.ltc_2.value = ze.LTC_2), vi.upload(S, r.uniformsList, m, $)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (vi.upload(S, r.uniformsList, m, $), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && f.setValue(S, "center", i.center), f.setValue(S, "modelViewMatrix", i.modelViewMatrix), f.setValue(S, "normalMatrix", i.normalMatrix), f.setValue(S, "modelMatrix", i.matrixWorld), d
                }

                function jt(t, e) {
                    var n;
                    t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = C.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }

                function Vt(t, e) {
                    t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === l && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === l && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function Wt(t, e) {
                    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === l && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === l && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }
                Ft.setAnimationLoop(function(t) {
                    Ct.isPresenting() || Ht && Ht(t)
                }), "undefined" != typeof window && Ft.setContext(window), this.setAnimationLoop = function(t) {
                    Ht = t, Ct.setAnimationLoop(t), Ft.start()
                }, this.render = function(t, e, n, i) {
                    if (e && e.isCamera) {
                        if (!tt) {
                            ot.geometry = null, ot.program = null, ot.wireframe = !1, rt = -1, at = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Ct.enabled && (e = Ct.getCamera(e)), (E = X.get(t, e)).init(), t.onBeforeRender($, t, e, n), Et.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), _t.setFromMatrix(Et), Tt = this.localClippingEnabled, Mt = wt.init(this.clippingPlanes, Tt, e), (T = W.get(t, e)).init(),
                                function t(e, n, i) {
                                    if (!1 !== e.visible) {
                                        var r = e.layers.test(n.layers);
                                        if (r)
                                            if (e.isLight) E.pushLight(e), e.castShadow && E.pushShadow(e);
                                            else if (e.isSprite) {
                                            if (!e.frustumCulled || _t.intersectsSprite(e)) {
                                                i && St.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Et);
                                                var o = N.update(e),
                                                    a = e.material;
                                                T.push(e, o, a, St.z, null)
                                            }
                                        } else if (e.isImmediateRenderObject) i && St.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Et), T.push(e, null, e.material, St.z, null);
                                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || _t.intersectsObject(e))) {
                                            i && St.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Et);
                                            var o = N.update(e),
                                                a = e.material;
                                            if (Array.isArray(a))
                                                for (var s = o.groups, c = 0, l = s.length; c < l; c++) {
                                                    var h = s[c],
                                                        u = a[h.materialIndex];
                                                    u && u.visible && T.push(e, o, u, St.z, h)
                                                } else a.visible && T.push(e, o, a, St.z, null)
                                        }
                                        for (var p = e.children, c = 0, l = p.length; c < l; c++) t(p[c], n, i)
                                    }
                                }(t, e, $.sortObjects), !0 === $.sortObjects && T.sort(), Mt && wt.beginShadows();
                            var r = E.state.shadowsArray;
                            Ot.render(r, t, e), E.setupLights(e), Mt && wt.endShadows(), this.info.autoReset && this.info.reset(), void 0 === n && (n = null), this.setRenderTarget(n), q.render(T, t, e, i);
                            var o = T.opaque,
                                a = T.transparent;
                            if (t.overrideMaterial) {
                                var s = t.overrideMaterial;
                                o.length && kt(o, t, e, s), a.length && kt(a, t, e, s)
                            } else o.length && kt(o, t, e), a.length && kt(a, t, e);
                            n && O.updateRenderTargetMipmap(n), L.buffers.depth.setTest(!0), L.buffers.depth.setMask(!0), L.buffers.color.setMask(!0), L.setPolygonOffset(!1), t.onAfterRender($, t, e), Ct.enabled && Ct.submitFrame(), T = null, E = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.allocTextureUnit = function() {
                    var t = ut;
                    return t >= P.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + P.maxTextures), ut += 1, t
                }, this.setTexture2D = function() {
                    var t = !1;
                    return function(e, n) {
                        e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), O.setTexture2D(e, n)
                    }
                }(), this.setTexture3D = function(t, e) {
                    O.setTexture3D(t, e)
                }, this.setTexture = function() {
                    var t = !1;
                    return function(e, n) {
                        t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), O.setTexture2D(e, n)
                    }
                }(), this.setTextureCube = function() {
                    var t = !1;
                    return function(e, n) {
                        e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? O.setTextureCube(e, n) : O.setTextureCubeDynamic(e, n)
                    }
                }(), this.setFramebuffer = function(t) {
                    et = t
                }, this.getRenderTarget = function() {
                    return nt
                }, this.setRenderTarget = function(t) {
                    nt = t, t && void 0 === C.get(t).__webglFramebuffer && O.setupRenderTarget(t);
                    var e = et,
                        n = !1;
                    if (t) {
                        var i = C.get(t).__webglFramebuffer;
                        t.isWebGLRenderTargetCube ? (e = i[t.activeCubeFace], n = !0) : e = i, ct.copy(t.viewport), lt.copy(t.scissor), ht = t.scissorTest
                    } else ct.copy(vt).multiplyScalar(mt), lt.copy(gt).multiplyScalar(mt), ht = yt;
                    if (it !== e && (S.bindFramebuffer(S.FRAMEBUFFER, e), it = e), L.viewport(ct), L.scissor(lt), L.setScissorTest(ht), n) {
                        var r = C.get(t.texture);
                        S.framebufferTexture2D(S.FRAMEBUFFER, S.COLOR_ATTACHMENT0, S.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function(t, e, n, i, r, o) {
                    if (t && t.isWebGLRenderTarget) {
                        var a = C.get(t).__webglFramebuffer;
                        if (a) {
                            var s = !1;
                            a !== it && (S.bindFramebuffer(S.FRAMEBUFFER, a), s = !0);
                            try {
                                var c = t.texture,
                                    l = c.format,
                                    h = c.type;
                                if (l !== Pt && Q.convert(l) !== S.getParameter(S.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(h === ft || Q.convert(h) === S.getParameter(S.IMPLEMENTATION_COLOR_READ_TYPE) || h === xt && (P.isWebGL2 || A.get("OES_texture_float") || A.get("WEBGL_color_buffer_float")) || h === bt && (P.isWebGL2 ? A.get("EXT_color_buffer_float") : A.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                S.checkFramebufferStatus(S.FRAMEBUFFER) === S.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && S.readPixels(e, n, i, r, Q.convert(l), Q.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                s && S.bindFramebuffer(S.FRAMEBUFFER, it)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function(t, e, n) {
                    var i = e.image.width,
                        r = e.image.height,
                        o = Q.convert(e.format);
                    this.setTexture2D(e, 0), S.copyTexImage2D(S.TEXTURE_2D, n || 0, o, t.x, t.y, i, r, 0)
                }, this.copyTextureToTexture = function(t, e, n, i) {
                    var r = e.image.width,
                        o = e.image.height,
                        a = Q.convert(n.format),
                        s = Q.convert(n.type);
                    this.setTexture2D(n, 0), e.isDataTexture ? S.texSubImage2D(S.TEXTURE_2D, i || 0, t.x, t.y, r, o, a, s, e.image.data) : S.texSubImage2D(S.TEXTURE_2D, i || 0, t.x, t.y, a, s, e.image)
                }
            }

            function Xi(t, e) {
                this.name = "", this.color = new Ue(t), this.density = void 0 !== e ? e : 25e-5
            }

            function qi(t, e, n) {
                this.name = "", this.color = new Ue(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
            }

            function Yi() {
                Ze.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }

            function Zi(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function Ji(t, e, n, i) {
                this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
            }

            function Ki(t) {
                yn.call(this), this.type = "SpriteMaterial", this.color = new Ue(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
            }

            function Qi(t) {
                if (Ze.call(this), this.type = "Sprite", void 0 === Ci) {
                    Ci = new pn;
                    var e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        n = new Zi(e, 5);
                    Ci.setIndex([0, 1, 2, 0, 2, 3]), Ci.addAttribute("position", new Ji(n, 3, 0, !1)), Ci.addAttribute("uv", new Ji(n, 2, 3, !1))
                }
                this.geometry = Ci, this.material = void 0 !== t ? t : new Ki, this.center = new be(.5, .5)
            }

            function $i() {
                Ze.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }

            function tr(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new we)
                }
            }

            function er() {
                Ze.call(this), this.type = "Bone"
            }

            function nr(t, e) {
                Mn.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new we, this.bindMatrixInverse = new we;
                var n = this.initBones(),
                    i = new tr(n);
                this.bind(i, this.matrixWorld), this.normalizeSkinWeights()
            }

            function ir(t) {
                yn.call(this), this.type = "LineBasicMaterial", this.color = new Ue(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
            }

            function rr(t, e, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Ze.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new pn, this.material = void 0 !== e ? e : new ir({
                    color: 16777215 * Math.random()
                })
            }

            function or(t, e) {
                rr.call(this, t, e), this.type = "LineSegments"
            }

            function ar(t, e) {
                rr.call(this, t, e), this.type = "LineLoop"
            }

            function sr(t) {
                yn.call(this), this.type = "PointsMaterial", this.color = new Ue(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function cr(t, e) {
                Ze.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new pn, this.material = void 0 !== e ? e : new sr({
                    color: 16777215 * Math.random()
                })
            }

            function lr(t, e, n, i, r, o, a, s, c) {
                Pe.call(this, t, e, n, i, r, o, a, s, c), this.generateMipmaps = !1
            }

            function hr(t, e, n, i, r, o, a, s, c, l, h, u) {
                Pe.call(this, null, o, a, s, c, l, i, r, h, u), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function ur(t, e, n, i, r, o, a, s, c) {
                Pe.call(this, t, e, n, i, r, o, a, s, c), this.needsUpdate = !0
            }

            function pr(t, e, n, i, r, o, a, s, c, l) {
                if ((l = void 0 !== l ? l : Ot) !== Ot && l !== It) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && l === Ot && (n = gt), void 0 === n && l === It && (n = Et), Pe.call(this, null, i, r, o, a, s, l, n, c), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== a ? a : ct, this.minFilter = void 0 !== s ? s : ct, this.flipY = !1, this.generateMipmaps = !1
            }

            function dr(t) {
                pn.call(this), this.type = "WireframeGeometry";
                var e, n, i, r, o, a, s, c, l, h, u = [],
                    p = [0, 0],
                    d = {},
                    f = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    var m = t.faces;
                    for (e = 0, i = m.length; e < i; e++) {
                        var v = m[e];
                        for (n = 0; n < 3; n++) s = v[f[n]], c = v[f[(n + 1) % 3]], p[0] = Math.min(s, c), p[1] = Math.max(s, c), l = p[0] + "," + p[1], void 0 === d[l] && (d[l] = {
                            index1: p[0],
                            index2: p[1]
                        })
                    }
                    for (l in d) a = d[l], h = t.vertices[a.index1], u.push(h.x, h.y, h.z), h = t.vertices[a.index2], u.push(h.x, h.y, h.z)
                } else if (t && t.isBufferGeometry) {
                    var g, y, _, x, b, w, M, T;
                    if (h = new Te, null !== t.index) {
                        for (g = t.attributes.position, y = t.index, 0 === (_ = t.groups).length && (_ = [{
                                start: 0,
                                count: y.count,
                                materialIndex: 0
                            }]), r = 0, o = _.length; r < o; ++r)
                            for (x = _[r], b = x.start, w = x.count, e = b, i = b + w; e < i; e += 3)
                                for (n = 0; n < 3; n++) s = y.getX(e + n), c = y.getX(e + (n + 1) % 3), p[0] = Math.min(s, c), p[1] = Math.max(s, c), l = p[0] + "," + p[1], void 0 === d[l] && (d[l] = {
                                    index1: p[0],
                                    index2: p[1]
                                });
                        for (l in d) a = d[l], h.fromBufferAttribute(g, a.index1), u.push(h.x, h.y, h.z), h.fromBufferAttribute(g, a.index2), u.push(h.x, h.y, h.z)
                    } else
                        for (g = t.attributes.position, e = 0, i = g.count / 3; e < i; e++)
                            for (n = 0; n < 3; n++) M = 3 * e + n, h.fromBufferAttribute(g, M), u.push(h.x, h.y, h.z), T = 3 * e + (n + 1) % 3, h.fromBufferAttribute(g, T), u.push(h.x, h.y, h.z)
                }
                this.addAttribute("position", new sn(u, 3))
            }

            function fr(t, e, n) {
                Ke.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                }, this.fromBufferGeometry(new mr(t, e, n)), this.mergeVertices()
            }

            function mr(t, e, n) {
                pn.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
                var i, r, o = [],
                    a = [],
                    s = [],
                    c = [],
                    l = new Te,
                    h = new Te,
                    u = new Te,
                    p = new Te,
                    d = new Te;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var f = e + 1;
                for (i = 0; i <= n; i++) {
                    var m = i / n;
                    for (r = 0; r <= e; r++) {
                        var v = r / e;
                        t(v, m, h), a.push(h.x, h.y, h.z), v - 1e-5 >= 0 ? (t(v - 1e-5, m, u), p.subVectors(h, u)) : (t(v + 1e-5, m, u), p.subVectors(u, h)), m - 1e-5 >= 0 ? (t(v, m - 1e-5, u), d.subVectors(h, u)) : (t(v, m + 1e-5, u), d.subVectors(u, h)), l.crossVectors(p, d).normalize(), s.push(l.x, l.y, l.z), c.push(v, m)
                    }
                }
                for (i = 0; i < n; i++)
                    for (r = 0; r < e; r++) {
                        var g = i * f + r,
                            y = i * f + r + 1,
                            _ = (i + 1) * f + r + 1,
                            x = (i + 1) * f + r;
                        o.push(g, y, x), o.push(y, _, x)
                    }
                this.setIndex(o), this.addAttribute("position", new sn(a, 3)), this.addAttribute("normal", new sn(s, 3)), this.addAttribute("uv", new sn(c, 2))
            }

            function vr(t, e, n, i) {
                Ke.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: i
                }, this.fromBufferGeometry(new gr(t, e, n, i)), this.mergeVertices()
            }

            function gr(t, e, n, i) {
                pn.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: i
                }, n = n || 1;
                var r = [],
                    o = [];

                function a(t, e, n, i) {
                    var r, o, a = Math.pow(2, i),
                        c = [];
                    for (r = 0; r <= a; r++) {
                        c[r] = [];
                        var l = t.clone().lerp(n, r / a),
                            h = e.clone().lerp(n, r / a),
                            u = a - r;
                        for (o = 0; o <= u; o++) c[r][o] = 0 === o && r === a ? l : l.clone().lerp(h, o / u)
                    }
                    for (r = 0; r < a; r++)
                        for (o = 0; o < 2 * (a - r) - 1; o++) {
                            var p = Math.floor(o / 2);
                            o % 2 == 0 ? (s(c[r][p + 1]), s(c[r + 1][p]), s(c[r][p])) : (s(c[r][p + 1]), s(c[r + 1][p + 1]), s(c[r + 1][p]))
                        }
                }

                function s(t) {
                    r.push(t.x, t.y, t.z)
                }

                function c(e, n) {
                    var i = 3 * e;
                    n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
                }

                function l(t, e, n, i) {
                    i < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5)
                }

                function h(t) {
                    return Math.atan2(t.z, -t.x)
                }

                function u(t) {
                    return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                }! function(t) {
                    for (var n = new Te, i = new Te, r = new Te, o = 0; o < e.length; o += 3) c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), a(n, i, r, t)
                }(i = i || 0),
                function(t) {
                    for (var e = new Te, n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
                }(n),
                function() {
                    for (var t = new Te, e = 0; e < r.length; e += 3) {
                        t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                        var n = h(t) / 2 / Math.PI + .5,
                            i = u(t) / Math.PI + .5;
                        o.push(n, 1 - i)
                    }(function() {
                        for (var t = new Te, e = new Te, n = new Te, i = new Te, a = new be, s = new be, c = new be, u = 0, p = 0; u < r.length; u += 9, p += 6) {
                            t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), a.set(o[p + 0], o[p + 1]), s.set(o[p + 2], o[p + 3]), c.set(o[p + 4], o[p + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                            var d = h(i);
                            l(a, p + 0, t, d), l(s, p + 2, e, d), l(c, p + 4, n, d)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < o.length; t += 6) {
                            var e = o[t + 0],
                                n = o[t + 2],
                                i = o[t + 4],
                                r = Math.max(e, n, i),
                                a = Math.min(e, n, i);
                            r > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), i < .2 && (o[t + 4] += 1))
                        }
                    }()
                }(), this.addAttribute("position", new sn(r, 3)), this.addAttribute("normal", new sn(r.slice(), 3)), this.addAttribute("uv", new sn(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function yr(t, e) {
                Ke.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new _r(t, e)), this.mergeVertices()
            }

            function _r(t, e) {
                gr.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function xr(t, e) {
                Ke.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new br(t, e)), this.mergeVertices()
            }

            function br(t, e) {
                gr.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function wr(t, e) {
                Ke.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Mr(t, e)), this.mergeVertices()
            }

            function Mr(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                gr.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Tr(t, e) {
                Ke.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Er(t, e)), this.mergeVertices()
            }

            function Er(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = 1 / n,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
                gr.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Sr(t, e, n, i, r, o) {
                Ke.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                var a = new Ar(t, e, n, i, r);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Ar(t, e, n, i, r) {
                pn.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, e = e || 64, n = n || 1, i = i || 8, r = r || !1;
                var o = t.computeFrenetFrames(e, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                var a, s, c = new Te,
                    l = new Te,
                    h = new be,
                    u = new Te,
                    p = [],
                    d = [],
                    f = [],
                    m = [];

                function v(r) {
                    u = t.getPointAt(r / e, u);
                    var a = o.normals[r],
                        h = o.binormals[r];
                    for (s = 0; s <= i; s++) {
                        var f = s / i * Math.PI * 2,
                            m = Math.sin(f),
                            v = -Math.cos(f);
                        l.x = v * a.x + m * h.x, l.y = v * a.y + m * h.y, l.z = v * a.z + m * h.z, l.normalize(), d.push(l.x, l.y, l.z), c.x = u.x + n * l.x, c.y = u.y + n * l.y, c.z = u.z + n * l.z, p.push(c.x, c.y, c.z)
                    }
                }! function() {
                    for (a = 0; a < e; a++) v(a);
                    v(!1 === r ? e : 0),
                        function() {
                            for (a = 0; a <= e; a++)
                                for (s = 0; s <= i; s++) h.x = a / e, h.y = s / i, f.push(h.x, h.y)
                        }(),
                        function() {
                            for (s = 1; s <= e; s++)
                                for (a = 1; a <= i; a++) {
                                    var t = (i + 1) * (s - 1) + (a - 1),
                                        n = (i + 1) * s + (a - 1),
                                        r = (i + 1) * s + a,
                                        o = (i + 1) * (s - 1) + a;
                                    m.push(t, n, o), m.push(n, r, o)
                                }
                        }()
                }(), this.setIndex(m), this.addAttribute("position", new sn(p, 3)), this.addAttribute("normal", new sn(d, 3)), this.addAttribute("uv", new sn(f, 2))
            }

            function Pr(t, e, n, i, r, o, a) {
                Ke.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: o
                }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Lr(t, e, n, i, r, o)), this.mergeVertices()
            }

            function Lr(t, e, n, i, r, o) {
                pn.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: o
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3;
                var a, s, c = [],
                    l = [],
                    h = [],
                    u = [],
                    p = new Te,
                    d = new Te,
                    f = new Te,
                    m = new Te,
                    v = new Te,
                    g = new Te,
                    y = new Te;
                for (a = 0; a <= n; ++a) {
                    var _ = a / n * r * Math.PI * 2;
                    for (A(_, r, o, t, f), A(_ + .01, r, o, t, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= i; ++s) {
                        var x = s / i * Math.PI * 2,
                            b = -e * Math.cos(x),
                            w = e * Math.sin(x);
                        p.x = f.x + (b * y.x + w * v.x), p.y = f.y + (b * y.y + w * v.y), p.z = f.z + (b * y.z + w * v.z), l.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), h.push(d.x, d.y, d.z), u.push(a / n), u.push(s / i)
                    }
                }
                for (s = 1; s <= n; s++)
                    for (a = 1; a <= i; a++) {
                        var M = (i + 1) * (s - 1) + (a - 1),
                            T = (i + 1) * s + (a - 1),
                            E = (i + 1) * s + a,
                            S = (i + 1) * (s - 1) + a;
                        c.push(M, T, S), c.push(T, E, S)
                    }

                function A(t, e, n, i, r) {
                    var o = Math.cos(t),
                        a = Math.sin(t),
                        s = n / e * t,
                        c = Math.cos(s);
                    r.x = i * (2 + c) * .5 * o, r.y = i * (2 + c) * a * .5, r.z = i * Math.sin(s) * .5
                }
                this.setIndex(c), this.addAttribute("position", new sn(l, 3)), this.addAttribute("normal", new sn(h, 3)), this.addAttribute("uv", new sn(u, 2))
            }

            function Rr(t, e, n, i, r) {
                Ke.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, this.fromBufferGeometry(new Cr(t, e, n, i, r)), this.mergeVertices()
            }

            function Cr(t, e, n, i, r) {
                pn.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
                var o, a, s = [],
                    c = [],
                    l = [],
                    h = [],
                    u = new Te,
                    p = new Te,
                    d = new Te;
                for (o = 0; o <= n; o++)
                    for (a = 0; a <= i; a++) {
                        var f = a / i * r,
                            m = o / n * Math.PI * 2;
                        p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f), p.z = e * Math.sin(m), c.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), d.subVectors(p, u).normalize(), l.push(d.x, d.y, d.z), h.push(a / i), h.push(o / n)
                    }
                for (o = 1; o <= n; o++)
                    for (a = 1; a <= i; a++) {
                        var v = (i + 1) * o + a - 1,
                            g = (i + 1) * (o - 1) + a - 1,
                            y = (i + 1) * (o - 1) + a,
                            _ = (i + 1) * o + a;
                        s.push(v, g, _), s.push(g, y, _)
                    }
                this.setIndex(s), this.addAttribute("position", new sn(c, 3)), this.addAttribute("normal", new sn(l, 3)), this.addAttribute("uv", new sn(h, 2))
            }
            Ni.prototype = Object.create(yn.prototype), Ni.prototype.constructor = Ni, Ni.prototype.isMeshDepthMaterial = !0, Ni.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, Bi.prototype = Object.create(yn.prototype), Bi.prototype.constructor = Bi, Bi.prototype.isMeshDistanceMaterial = !0, Bi.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }, Ui.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: Ui,
                isGroup: !0
            }), zi.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: zi,
                isCamera: !0,
                copy: function(t, e) {
                    return Ze.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Te), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    Ze.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), Gi.prototype = Object.assign(Object.create(zi.prototype), {
                constructor: Gi,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return zi.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    var e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * xe.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var t = Math.tan(.5 * xe.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * xe.RAD2DEG * Math.atan(Math.tan(.5 * xe.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, i, r, o) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = this.near,
                        e = t * Math.tan(.5 * xe.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * e,
                        i = this.aspect * n,
                        r = -.5 * i,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        r += o.offsetX * i / a, e -= o.offsetY * n / s, i *= o.width / a, n *= o.height / s
                    }
                    var c = this.filmOffset;
                    0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = Ze.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            }), ji.prototype = Object.assign(Object.create(Gi.prototype), {
                constructor: ji,
                isArrayCamera: !0
            }), Xi.prototype.isFogExp2 = !0, Xi.prototype.clone = function() {
                return new Xi(this.color, this.density)
            }, Xi.prototype.toJSON = function() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }, qi.prototype.isFog = !0, qi.prototype.clone = function() {
                return new qi(this.color, this.near, this.far)
            }, qi.prototype.toJSON = function() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }, Yi.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: Yi,
                copy: function(t, e) {
                    return Ze.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                },
                toJSON: function(t) {
                    var e = Ze.prototype.toJSON.call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }), Object.defineProperty(Zi.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Zi.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride, n *= e.stride;
                    for (var i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                }
            }), Object.defineProperties(Ji.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(Ji.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
                }
            }), Ki.prototype = Object.create(yn.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isSpriteMaterial = !0, Ki.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            }, Qi.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: Qi,
                isSprite: !0,
                raycast: function() {
                    var t = new Te,
                        e = new Te,
                        n = new Te,
                        i = new be,
                        r = new be,
                        o = new we,
                        a = new Te,
                        s = new Te,
                        c = new Te,
                        l = new be,
                        h = new be,
                        u = new be;

                    function p(t, e, n, a, s, c) {
                        i.subVectors(t, n).addScalar(.5).multiply(a), void 0 !== s ? (r.x = c * i.x - s * i.y, r.y = s * i.x + c * i.y) : r.copy(i), t.copy(e), t.x += r.x, t.y += r.y, t.applyMatrix4(o)
                    }
                    return function(i, r) {
                        e.setFromMatrixScale(this.matrixWorld), o.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix);
                        var d, f, m = this.material.rotation;
                        0 !== m && (f = Math.cos(m), d = Math.sin(m));
                        var v = this.center;
                        p(a.set(-.5, -.5, 0), n, v, e, d, f), p(s.set(.5, -.5, 0), n, v, e, d, f), p(c.set(.5, .5, 0), n, v, e, d, f), l.set(0, 0), h.set(1, 0), u.set(1, 1);
                        var g = i.ray.intersectTriangle(a, s, c, !1, t);
                        if (null !== g || (p(s.set(-.5, .5, 0), n, v, e, d, f), h.set(0, 1), null !== (g = i.ray.intersectTriangle(a, c, s, !1, t)))) {
                            var y = i.ray.origin.distanceTo(t);
                            y < i.near || y > i.far || r.push({
                                distance: y,
                                point: t.clone(),
                                uv: bn.getUV(t, a, s, c, l, h, u, new be),
                                face: null,
                                object: this
                            })
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function(t) {
                    return Ze.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
                }
            }), $i.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: $i,
                copy: function(t) {
                    Ze.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++);
                    n.splice(i, 0, {
                        distance: e,
                        object: t
                    }), this.add(t)
                },
                getObjectForDistance: function(t) {
                    for (var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                    return e[n - 1].object
                },
                raycast: function() {
                    var t = new Te;
                    return function(e, n) {
                        t.setFromMatrixPosition(this.matrixWorld);
                        var i = e.ray.origin.distanceTo(t);
                        this.getObjectForDistance(i).raycast(e, n)
                    }
                }(),
                update: function() {
                    var t = new Te,
                        e = new Te;
                    return function(n) {
                        var i = this.levels;
                        if (i.length > 1) {
                            t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                            var r = t.distanceTo(e);
                            i[0].object.visible = !0;
                            for (var o = 1, a = i.length; o < a && r >= i[o].distance; o++) i[o - 1].object.visible = !1, i[o].object.visible = !0;
                            for (; o < a; o++) i[o].object.visible = !1
                        }
                    }
                }(),
                toJSON: function(t) {
                    var e = Ze.prototype.toJSON.call(this, t);
                    e.object.levels = [];
                    for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                        var o = n[i];
                        e.object.levels.push({
                            object: o.object.uuid,
                            distance: o.distance
                        })
                    }
                    return e
                }
            }), Object.assign(tr.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var n = new we;
                        this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function() {
                    var t, e, n;
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                },
                update: function() {
                    var t = new we,
                        e = new we;
                    return function() {
                        for (var n = this.bones, i = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = n.length; a < s; a++) {
                            var c = n[a] ? n[a].matrixWorld : e;
                            t.multiplyMatrices(c, i[a]), t.toArray(r, 16 * a)
                        }
                        void 0 !== o && (o.needsUpdate = !0)
                    }
                }(),
                clone: function() {
                    return new tr(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (var e = 0, n = this.bones.length; e < n; e++) {
                        var i = this.bones[e];
                        if (i.name === t) return i
                    }
                }
            }), er.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: er,
                isBone: !0
            }), nr.prototype = Object.assign(Object.create(Mn.prototype), {
                constructor: nr,
                isSkinnedMesh: !0,
                initBones: function() {
                    var t, e, n, i, r = [];
                    if (this.geometry && void 0 !== this.geometry.bones) {
                        for (n = 0, i = this.geometry.bones.length; n < i; n++) e = this.geometry.bones[n], t = new er, r.push(t), t.name = e.name, t.position.fromArray(e.pos), t.quaternion.fromArray(e.rotq), void 0 !== e.scl && t.scale.fromArray(e.scl);
                        for (n = 0, i = this.geometry.bones.length; n < i; n++) - 1 !== (e = this.geometry.bones[n]).parent && null !== e.parent && void 0 !== r[e.parent] ? r[e.parent].add(r[n]) : this.add(r[n])
                    }
                    return this.updateMatrixWorld(!0), r
                },
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    var t, e;
                    if (this.geometry && this.geometry.isGeometry)
                        for (e = 0; e < this.geometry.skinWeights.length; e++) {
                            var n = this.geometry.skinWeights[e];
                            (t = 1 / n.manhattanLength()) != 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0)
                        } else if (this.geometry && this.geometry.isBufferGeometry) {
                            var i = new Le,
                                r = this.geometry.attributes.skinWeight;
                            for (e = 0; e < r.count; e++) i.x = r.getX(e), i.y = r.getY(e), i.z = r.getZ(e), i.w = r.getW(e), (t = 1 / i.manhattanLength()) != 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0), r.setXYZW(e, i.x, i.y, i.z, i.w)
                        }
                },
                updateMatrixWorld: function(t) {
                    Mn.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), ir.prototype = Object.create(yn.prototype), ir.prototype.constructor = ir, ir.prototype.isLineBasicMaterial = !0, ir.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            }, rr.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: rr,
                isLine: !0,
                computeLineDistances: function() {
                    var t = new Te,
                        e = new Te;
                    return function() {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var i = n.attributes.position, r = [0], o = 1, a = i.count; o < a; o++) t.fromBufferAttribute(i, o - 1), e.fromBufferAttribute(i, o), r[o] = r[o - 1], r[o] += t.distanceTo(e);
                                n.addAttribute("lineDistance", new sn(r, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry) {
                            var s = n.vertices,
                                r = n.lineDistances;
                            r[0] = 0;
                            for (var o = 1, a = s.length; o < a; o++) r[o] = r[o - 1], r[o] += s[o - 1].distanceTo(s[o])
                        }
                        return this
                    }
                }(),
                raycast: function() {
                    var t = new we,
                        e = new xn,
                        n = new De;
                    return function(i, r) {
                        var o = i.linePrecision,
                            a = this.geometry,
                            s = this.matrixWorld;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(s), n.radius += o, !1 !== i.ray.intersectsSphere(n)) {
                            t.getInverse(s), e.copy(i.ray).applyMatrix4(t);
                            var c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                l = c * c,
                                h = new Te,
                                u = new Te,
                                p = new Te,
                                d = new Te,
                                f = this && this.isLineSegments ? 2 : 1;
                            if (a.isBufferGeometry) {
                                var m = a.index,
                                    v = a.attributes,
                                    g = v.position.array;
                                if (null !== m)
                                    for (var y = m.array, _ = 0, x = y.length - 1; _ < x; _ += f) {
                                        var b = y[_],
                                            w = y[_ + 1];
                                        h.fromArray(g, 3 * b), u.fromArray(g, 3 * w);
                                        var M = e.distanceSqToSegment(h, u, d, p);
                                        if (!(M > l)) {
                                            d.applyMatrix4(this.matrixWorld);
                                            var T = i.ray.origin.distanceTo(d);
                                            T < i.near || T > i.far || r.push({
                                                distance: T,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: _,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    } else
                                        for (var _ = 0, x = g.length / 3 - 1; _ < x; _ += f) {
                                            h.fromArray(g, 3 * _), u.fromArray(g, 3 * _ + 3);
                                            var M = e.distanceSqToSegment(h, u, d, p);
                                            if (!(M > l)) {
                                                d.applyMatrix4(this.matrixWorld);
                                                var T = i.ray.origin.distanceTo(d);
                                                T < i.near || T > i.far || r.push({
                                                    distance: T,
                                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                                    index: _,
                                                    face: null,
                                                    faceIndex: null,
                                                    object: this
                                                })
                                            }
                                        }
                            } else if (a.isGeometry)
                                for (var E = a.vertices, S = E.length, _ = 0; _ < S - 1; _ += f) {
                                    var M = e.distanceSqToSegment(E[_], E[_ + 1], d, p);
                                    if (!(M > l)) {
                                        d.applyMatrix4(this.matrixWorld);
                                        var T = i.ray.origin.distanceTo(d);
                                        T < i.near || T > i.far || r.push({
                                            distance: T,
                                            point: p.clone().applyMatrix4(this.matrixWorld),
                                            index: _,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), or.prototype = Object.assign(Object.create(rr.prototype), {
                constructor: or,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var t = new Te,
                        e = new Te;
                    return function() {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var i = n.attributes.position, r = [], o = 0, a = i.count; o < a; o += 2) t.fromBufferAttribute(i, o), e.fromBufferAttribute(i, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e);
                                n.addAttribute("lineDistance", new sn(r, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry)
                            for (var s = n.vertices, r = n.lineDistances, o = 0, a = s.length; o < a; o += 2) t.copy(s[o]), e.copy(s[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e);
                        return this
                    }
                }()
            }), ar.prototype = Object.assign(Object.create(rr.prototype), {
                constructor: ar,
                isLineLoop: !0
            }), sr.prototype = Object.create(yn.prototype), sr.prototype.constructor = sr, sr.prototype.isPointsMaterial = !0, sr.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            }, cr.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: cr,
                isPoints: !0,
                raycast: function() {
                    var t = new we,
                        e = new xn,
                        n = new De;
                    return function(i, r) {
                        var o = this,
                            a = this.geometry,
                            s = this.matrixWorld,
                            c = i.params.Points.threshold;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(s), n.radius += c, !1 !== i.ray.intersectsSphere(n)) {
                            t.getInverse(s), e.copy(i.ray).applyMatrix4(t);
                            var l = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                h = l * l,
                                u = new Te,
                                p = new Te;
                            if (a.isBufferGeometry) {
                                var d = a.index,
                                    f = a.attributes,
                                    m = f.position.array;
                                if (null !== d)
                                    for (var v = d.array, g = 0, y = v.length; g < y; g++) {
                                        var _ = v[g];
                                        u.fromArray(m, 3 * _), w(u, _)
                                    } else
                                        for (var g = 0, x = m.length / 3; g < x; g++) u.fromArray(m, 3 * g), w(u, g)
                            } else
                                for (var b = a.vertices, g = 0, x = b.length; g < x; g++) w(b[g], g)
                        }

                        function w(t, n) {
                            var a = e.distanceSqToPoint(t);
                            if (a < h) {
                                e.closestPointToPoint(t, p), p.applyMatrix4(s);
                                var c = i.ray.origin.distanceTo(p);
                                if (c < i.near || c > i.far) return;
                                r.push({
                                    distance: c,
                                    distanceToRay: Math.sqrt(a),
                                    point: p.clone(),
                                    index: n,
                                    face: null,
                                    object: o
                                })
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), lr.prototype = Object.assign(Object.create(Pe.prototype), {
                constructor: lr,
                isVideoTexture: !0,
                update: function() {
                    var t = this.image;
                    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), hr.prototype = Object.create(Pe.prototype), hr.prototype.constructor = hr, hr.prototype.isCompressedTexture = !0, ur.prototype = Object.create(Pe.prototype), ur.prototype.constructor = ur, ur.prototype.isCanvasTexture = !0, pr.prototype = Object.create(Pe.prototype), pr.prototype.constructor = pr, pr.prototype.isDepthTexture = !0, dr.prototype = Object.create(pn.prototype), dr.prototype.constructor = dr, fr.prototype = Object.create(Ke.prototype), fr.prototype.constructor = fr, mr.prototype = Object.create(pn.prototype), mr.prototype.constructor = mr, vr.prototype = Object.create(Ke.prototype), vr.prototype.constructor = vr, gr.prototype = Object.create(pn.prototype), gr.prototype.constructor = gr, yr.prototype = Object.create(Ke.prototype), yr.prototype.constructor = yr, _r.prototype = Object.create(gr.prototype), _r.prototype.constructor = _r, xr.prototype = Object.create(Ke.prototype), xr.prototype.constructor = xr, br.prototype = Object.create(gr.prototype), br.prototype.constructor = br, wr.prototype = Object.create(Ke.prototype), wr.prototype.constructor = wr, Mr.prototype = Object.create(gr.prototype), Mr.prototype.constructor = Mr, Tr.prototype = Object.create(Ke.prototype), Tr.prototype.constructor = Tr, Er.prototype = Object.create(gr.prototype), Er.prototype.constructor = Er, Sr.prototype = Object.create(Ke.prototype), Sr.prototype.constructor = Sr, Ar.prototype = Object.create(pn.prototype), Ar.prototype.constructor = Ar, Pr.prototype = Object.create(Ke.prototype), Pr.prototype.constructor = Pr, Lr.prototype = Object.create(pn.prototype), Lr.prototype.constructor = Lr, Rr.prototype = Object.create(Ke.prototype), Rr.prototype.constructor = Rr, Cr.prototype = Object.create(pn.prototype), Cr.prototype.constructor = Cr;
            var Or = {
                triangulate: function(t, e, n) {
                    n = n || 2;
                    var i, r, o, a, s, c, l, h = e && e.length,
                        u = h ? e[0] * n : t.length,
                        p = Ir(t, 0, u, n, !0),
                        d = [];
                    if (!p) return d;
                    if (h && (p = function(t, e, n, i) {
                            var r, o, a, s, c, l = [];
                            for (r = 0, o = e.length; r < o; r++) a = e[r] * i, s = r < o - 1 ? e[r + 1] * i : t.length, (c = Ir(t, a, s, i, !1)) === c.next && (c.steiner = !0), l.push(jr(c));
                            for (l.sort(Ur), r = 0; r < l.length; r++) zr(l[r], n), n = Dr(n, n.next);
                            return n
                        }(t, e, p, n)), t.length > 80 * n) {
                        i = o = t[0], r = a = t[1];
                        for (var f = n; f < u; f += n) s = t[f], c = t[f + 1], s < i && (i = s), c < r && (r = c), s > o && (o = s), c > a && (a = c);
                        l = 0 !== (l = Math.max(o - i, a - r)) ? 1 / l : 0
                    }
                    return Nr(p, d, n, i, r, l), d
                }
            };

            function Ir(t, e, n, i, r) {
                var o, a;
                if (r === function(t, e, n, i) {
                        for (var r = 0, o = e, a = n - i; o < n; o += i) r += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                        return r
                    }(t, e, n, i) > 0)
                    for (o = e; o < n; o += i) a = Kr(o, t[o], t[o + 1], a);
                else
                    for (o = n - i; o >= e; o -= i) a = Kr(o, t[o], t[o + 1], a);
                return a && qr(a, a.next) && (Qr(a), a = a.next), a
            }

            function Dr(t, e) {
                if (!t) return t;
                e || (e = t);
                var n, i = t;
                do {
                    if (n = !1, i.steiner || !qr(i, i.next) && 0 !== Xr(i.prev, i, i.next)) i = i.next;
                    else {
                        if (Qr(i), (i = e = i.prev) === i.next) break;
                        n = !0
                    }
                } while (n || i !== e);
                return e
            }

            function Nr(t, e, n, i, r, o, a) {
                if (t) {
                    !a && o && function(t, e, n, i) {
                        var r = t;
                        do {
                            null === r.z && (r.z = Gr(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                var e, n, i, r, o, a, s, c, l = 1;
                                do {
                                    for (n = t, t = null, o = null, a = 0; n;) {
                                        for (a++, i = n, s = 0, e = 0; e < l && (s++, i = i.nextZ); e++);
                                        for (c = l; s > 0 || c > 0 && i;) 0 !== s && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                                        n = i
                                    }
                                    o.nextZ = null, l *= 2
                                } while (a > 1)
                            }(r)
                    }(t, i, r, o);
                    for (var s, c, l = t; t.prev !== t.next;)
                        if (s = t.prev, c = t.next, o ? Hr(t, i, r, o) : Br(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), Qr(t), t = c.next, l = c.next;
                        else if ((t = c) === l) {
                        a ? 1 === a ? Nr(t = Fr(t, e, n), e, n, i, r, o, 2) : 2 === a && kr(t, e, n, i, r, o) : Nr(Dr(t), e, n, i, r, o, 1);
                        break
                    }
                }
            }

            function Br(t) {
                var e = t.prev,
                    n = t,
                    i = t.next;
                if (Xr(e, n, i) >= 0) return !1;
                for (var r = t.next.next; r !== t.prev;) {
                    if (Vr(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Xr(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function Hr(t, e, n, i) {
                var r = t.prev,
                    o = t,
                    a = t.next;
                if (Xr(r, o, a) >= 0) return !1;
                for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, c = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, l = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, h = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, u = Gr(s, c, e, n, i), p = Gr(l, h, e, n, i), d = t.nextZ; d && d.z <= p;) {
                    if (d !== t.prev && d !== t.next && Vr(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && Xr(d.prev, d, d.next) >= 0) return !1;
                    d = d.nextZ
                }
                for (d = t.prevZ; d && d.z >= u;) {
                    if (d !== t.prev && d !== t.next && Vr(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && Xr(d.prev, d, d.next) >= 0) return !1;
                    d = d.prevZ
                }
                return !0
            }

            function Fr(t, e, n) {
                var i = t;
                do {
                    var r = i.prev,
                        o = i.next.next;
                    !qr(r, o) && Yr(r, i, i.next, o) && Zr(r, o) && Zr(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), Qr(i), Qr(i.next), i = t = o), i = i.next
                } while (i !== t);
                return i
            }

            function kr(t, e, n, i, r, o) {
                var a = t;
                do {
                    for (var s = a.next.next; s !== a.prev;) {
                        if (a.i !== s.i && Wr(a, s)) {
                            var c = Jr(a, s);
                            return a = Dr(a, a.next), c = Dr(c, c.next), Nr(a, e, n, i, r, o), void Nr(c, e, n, i, r, o)
                        }
                        s = s.next
                    }
                    a = a.next
                } while (a !== t)
            }

            function Ur(t, e) {
                return t.x - e.x
            }

            function zr(t, e) {
                if (e = function(t, e) {
                        var n, i = e,
                            r = t.x,
                            o = t.y,
                            a = -1 / 0;
                        do {
                            if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
                                var s = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                if (s <= r && s > a) {
                                    if (a = s, s === r) {
                                        if (o === i.y) return i;
                                        if (o === i.next.y) return i.next
                                    }
                                    n = i.x < i.next.x ? i : i.next
                                }
                            }
                            i = i.next
                        } while (i !== e);
                        if (!n) return null;
                        if (r === a) return n.prev;
                        var c, l = n,
                            h = n.x,
                            u = n.y,
                            p = 1 / 0;
                        for (i = n.next; i !== l;) r >= i.x && i.x >= h && r !== i.x && Vr(o < u ? r : a, o, h, u, o < u ? a : r, o, i.x, i.y) && ((c = Math.abs(o - i.y) / (r - i.x)) < p || c === p && i.x > n.x) && Zr(i, t) && (n = i, p = c), i = i.next;
                        return n
                    }(t, e)) {
                    var n = Jr(e, t);
                    Dr(n, n.next)
                }
            }

            function Gr(t, e, n, i, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function jr(t) {
                var e = t,
                    n = t;
                do {
                    e.x < n.x && (n = e), e = e.next
                } while (e !== t);
                return n
            }

            function Vr(t, e, n, i, r, o, a, s) {
                return (r - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (i - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0
            }

            function Wr(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    var n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Yr(n, n.next, t, e)) return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }(t, e) && Zr(t, e) && Zr(e, t) && function(t, e) {
                    var n = t,
                        i = !1,
                        r = (t.x + e.x) / 2,
                        o = (t.y + e.y) / 2;
                    do {
                        n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== t);
                    return i
                }(t, e)
            }

            function Xr(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
            }

            function qr(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function Yr(t, e, n, i) {
                return !!(qr(t, e) && qr(n, i) || qr(t, i) && qr(n, e)) || Xr(t, e, n) > 0 != Xr(t, e, i) > 0 && Xr(n, i, t) > 0 != Xr(n, i, e) > 0
            }

            function Zr(t, e) {
                return Xr(t.prev, t, t.next) < 0 ? Xr(t, e, t.next) >= 0 && Xr(t, t.prev, e) >= 0 : Xr(t, e, t.prev) < 0 || Xr(t, t.next, e) < 0
            }

            function Jr(t, e) {
                var n = new $r(t.i, t.x, t.y),
                    i = new $r(e.i, e.x, e.y),
                    r = t.next,
                    o = e.prev;
                return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
            }

            function Kr(t, e, n, i) {
                var r = new $r(t, e, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function Qr(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function $r(t, e, n) {
                this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var to = {
                area: function(t) {
                    for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                    return .5 * n
                },
                isClockWise: function(t) {
                    return to.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    var n = [],
                        i = [],
                        r = [];
                    eo(t), no(n, t);
                    var o = t.length;
                    e.forEach(eo);
                    for (var a = 0; a < e.length; a++) i.push(o), o += e[a].length, no(n, e[a]);
                    for (var s = Or.triangulate(n, i), a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
                    return r
                }
            };

            function eo(t) {
                var e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function no(t, e) {
                for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
            }

            function io(t, e) {
                Ke.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new ro(t, e)), this.mergeVertices()
            }

            function ro(t, e) {
                pn.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: t,
                    options: e
                };
                for (var n = this, i = [], r = [], o = 0, a = (t = Array.isArray(t) ? t : [t]).length; o < a; o++) {
                    var s = t[o];
                    c(s)
                }

                function c(t) {
                    var o = [],
                        a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        s = void 0 !== e.steps ? e.steps : 1,
                        c = void 0 !== e.depth ? e.depth : 100,
                        l = void 0 === e.bevelEnabled || e.bevelEnabled,
                        h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                        u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                        p = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                        d = e.extrudePath,
                        f = void 0 !== e.UVGenerator ? e.UVGenerator : oo;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
                    var m, v, g, y, _, x, b, w, M = !1;
                    d && (m = d.getSpacedPoints(s), M = !0, l = !1, v = d.computeFrenetFrames(s, !1), g = new Te, y = new Te, _ = new Te), l || (p = 0, h = 0, u = 0);
                    var T = t.extractPoints(a),
                        E = T.shape,
                        S = T.holes,
                        A = !to.isClockWise(E);
                    if (A)
                        for (E = E.reverse(), b = 0, w = S.length; b < w; b++) x = S[b], to.isClockWise(x) && (S[b] = x.reverse());
                    var P = to.triangulateShape(E, S),
                        L = E;
                    for (b = 0, w = S.length; b < w; b++) x = S[b], E = E.concat(x);

                    function R(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                    }
                    var C, O, I, D, N, B, H = E.length,
                        F = P.length;

                    function k(t, e, n) {
                        var i, r, o, a = t.x - e.x,
                            s = t.y - e.y,
                            c = n.x - t.x,
                            l = n.y - t.y,
                            h = a * a + s * s,
                            u = a * l - s * c;
                        if (Math.abs(u) > Number.EPSILON) {
                            var p = Math.sqrt(h),
                                d = Math.sqrt(c * c + l * l),
                                f = e.x - s / p,
                                m = e.y + a / p,
                                v = n.x - l / d,
                                g = n.y + c / d,
                                y = ((v - f) * l - (g - m) * c) / (a * l - s * c);
                            i = f + a * y - t.x, r = m + s * y - t.y;
                            var _ = i * i + r * r;
                            if (_ <= 2) return new be(i, r);
                            o = Math.sqrt(_ / 2)
                        } else {
                            var x = !1;
                            a > Number.EPSILON ? c > Number.EPSILON && (x = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (x = !0) : Math.sign(s) === Math.sign(l) && (x = !0), x ? (i = -s, r = a, o = Math.sqrt(h)) : (i = a, r = s, o = Math.sqrt(h / 2))
                        }
                        return new be(i / o, r / o)
                    }
                    for (var U = [], z = 0, G = L.length, j = G - 1, V = z + 1; z < G; z++, j++, V++) j === G && (j = 0), V === G && (V = 0), U[z] = k(L[z], L[j], L[V]);
                    var W, X, q = [],
                        Y = U.concat();
                    for (b = 0, w = S.length; b < w; b++) {
                        for (x = S[b], W = [], z = 0, G = x.length, j = G - 1, V = z + 1; z < G; z++, j++, V++) j === G && (j = 0), V === G && (V = 0), W[z] = k(x[z], x[j], x[V]);
                        q.push(W), Y = Y.concat(W)
                    }
                    for (C = 0; C < p; C++) {
                        for (I = C / p, D = h * Math.cos(I * Math.PI / 2), O = u * Math.sin(I * Math.PI / 2), z = 0, G = L.length; z < G; z++) J((N = R(L[z], U[z], O)).x, N.y, -D);
                        for (b = 0, w = S.length; b < w; b++)
                            for (x = S[b], W = q[b], z = 0, G = x.length; z < G; z++) J((N = R(x[z], W[z], O)).x, N.y, -D)
                    }
                    for (O = u, z = 0; z < H; z++) N = l ? R(E[z], Y[z], O) : E[z], M ? (y.copy(v.normals[0]).multiplyScalar(N.x), g.copy(v.binormals[0]).multiplyScalar(N.y), _.copy(m[0]).add(y).add(g), J(_.x, _.y, _.z)) : J(N.x, N.y, 0);
                    for (X = 1; X <= s; X++)
                        for (z = 0; z < H; z++) N = l ? R(E[z], Y[z], O) : E[z], M ? (y.copy(v.normals[X]).multiplyScalar(N.x), g.copy(v.binormals[X]).multiplyScalar(N.y), _.copy(m[X]).add(y).add(g), J(_.x, _.y, _.z)) : J(N.x, N.y, c / s * X);
                    for (C = p - 1; C >= 0; C--) {
                        for (I = C / p, D = h * Math.cos(I * Math.PI / 2), O = u * Math.sin(I * Math.PI / 2), z = 0, G = L.length; z < G; z++) J((N = R(L[z], U[z], O)).x, N.y, c + D);
                        for (b = 0, w = S.length; b < w; b++)
                            for (x = S[b], W = q[b], z = 0, G = x.length; z < G; z++) N = R(x[z], W[z], O), M ? J(N.x, N.y + m[s - 1].y, m[s - 1].x + D) : J(N.x, N.y, c + D)
                    }

                    function Z(t, e) {
                        var n, i;
                        for (z = t.length; --z >= 0;) {
                            n = z, (i = z - 1) < 0 && (i = t.length - 1);
                            var r = 0,
                                o = s + 2 * p;
                            for (r = 0; r < o; r++) {
                                var a = H * r,
                                    c = H * (r + 1),
                                    l = e + n + a,
                                    h = e + i + a,
                                    u = e + i + c,
                                    d = e + n + c;
                                Q(l, h, u, d)
                            }
                        }
                    }

                    function J(t, e, n) {
                        o.push(t), o.push(e), o.push(n)
                    }

                    function K(t, e, r) {
                        $(t), $(e), $(r);
                        var o = i.length / 3,
                            a = f.generateTopUV(n, i, o - 3, o - 2, o - 1);
                        tt(a[0]), tt(a[1]), tt(a[2])
                    }

                    function Q(t, e, r, o) {
                        $(t), $(e), $(o), $(e), $(r), $(o);
                        var a = i.length / 3,
                            s = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                        tt(s[0]), tt(s[1]), tt(s[3]), tt(s[1]), tt(s[2]), tt(s[3])
                    }

                    function $(t) {
                        i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2])
                    }

                    function tt(t) {
                        r.push(t.x), r.push(t.y)
                    }! function() {
                        var t = i.length / 3;
                        if (l) {
                            var e = 0,
                                r = H * e;
                            for (z = 0; z < F; z++) K((B = P[z])[2] + r, B[1] + r, B[0] + r);
                            for (r = H * (e = s + 2 * p), z = 0; z < F; z++) K((B = P[z])[0] + r, B[1] + r, B[2] + r)
                        } else {
                            for (z = 0; z < F; z++) K((B = P[z])[2], B[1], B[0]);
                            for (z = 0; z < F; z++) K((B = P[z])[0] + H * s, B[1] + H * s, B[2] + H * s)
                        }
                        n.addGroup(t, i.length / 3 - t, 0)
                    }(),
                    function() {
                        var t = i.length / 3,
                            e = 0;
                        for (Z(L, e), e += L.length, b = 0, w = S.length; b < w; b++) Z(x = S[b], e), e += x.length;
                        n.addGroup(t, i.length / 3 - t, 1)
                    }()
                }
                this.addAttribute("position", new sn(i, 3)), this.addAttribute("uv", new sn(r, 2)), this.computeVertexNormals()
            }
            io.prototype = Object.create(Ke.prototype), io.prototype.constructor = io, io.prototype.toJSON = function() {
                var t = Ke.prototype.toJSON.call(this),
                    e = this.parameters.shapes,
                    n = this.parameters.options;
                return ao(e, n, t)
            }, ro.prototype = Object.create(pn.prototype), ro.prototype.constructor = ro, ro.prototype.toJSON = function() {
                var t = pn.prototype.toJSON.call(this),
                    e = this.parameters.shapes,
                    n = this.parameters.options;
                return ao(e, n, t)
            };
            var oo = {
                generateTopUV: function(t, e, n, i, r) {
                    var o = e[3 * n],
                        a = e[3 * n + 1],
                        s = e[3 * i],
                        c = e[3 * i + 1],
                        l = e[3 * r],
                        h = e[3 * r + 1];
                    return [new be(o, a), new be(s, c), new be(l, h)]
                },
                generateSideWallUV: function(t, e, n, i, r, o) {
                    var a = e[3 * n],
                        s = e[3 * n + 1],
                        c = e[3 * n + 2],
                        l = e[3 * i],
                        h = e[3 * i + 1],
                        u = e[3 * i + 2],
                        p = e[3 * r],
                        d = e[3 * r + 1],
                        f = e[3 * r + 2],
                        m = e[3 * o],
                        v = e[3 * o + 1],
                        g = e[3 * o + 2];
                    return Math.abs(s - h) < .01 ? [new be(a, 1 - c), new be(l, 1 - u), new be(p, 1 - f), new be(m, 1 - g)] : [new be(s, 1 - c), new be(h, 1 - u), new be(d, 1 - f), new be(v, 1 - g)]
                }
            };

            function ao(t, e, n) {
                if (n.shapes = [], Array.isArray(t))
                    for (var i = 0, r = t.length; i < r; i++) {
                        var o = t[i];
                        n.shapes.push(o.uuid)
                    } else n.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
            }

            function so(t, e) {
                Ke.call(this), this.type = "TextGeometry", this.parameters = {
                    text: t,
                    parameters: e
                }, this.fromBufferGeometry(new co(t, e)), this.mergeVertices()
            }

            function co(t, e) {
                var n = (e = e || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Ke;
                var i = n.generateShapes(t, e.size);
                e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), ro.call(this, i, e), this.type = "TextBufferGeometry"
            }

            function lo(t, e, n, i, r, o, a) {
                Ke.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: a
                }, this.fromBufferGeometry(new ho(t, e, n, i, r, o, a)), this.mergeVertices()
            }

            function ho(t, e, n, i, r, o, a) {
                pn.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: a
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
                var s, c, l = o + a,
                    h = 0,
                    u = [],
                    p = new Te,
                    d = new Te,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (c = 0; c <= n; c++) {
                    var y = [],
                        _ = c / n;
                    for (s = 0; s <= e; s++) {
                        var x = s / e;
                        p.x = -t * Math.cos(i + x * r) * Math.sin(o + _ * a), p.y = t * Math.cos(o + _ * a), p.z = t * Math.sin(i + x * r) * Math.sin(o + _ * a), m.push(p.x, p.y, p.z), d.set(p.x, p.y, p.z).normalize(), v.push(d.x, d.y, d.z), g.push(x, 1 - _), y.push(h++)
                    }
                    u.push(y)
                }
                for (c = 0; c < n; c++)
                    for (s = 0; s < e; s++) {
                        var b = u[c][s + 1],
                            w = u[c][s],
                            M = u[c + 1][s],
                            T = u[c + 1][s + 1];
                        (0 !== c || o > 0) && f.push(b, w, T), (c !== n - 1 || l < Math.PI) && f.push(w, M, T)
                    }
                this.setIndex(f), this.addAttribute("position", new sn(m, 3)), this.addAttribute("normal", new sn(v, 3)), this.addAttribute("uv", new sn(g, 2))
            }

            function uo(t, e, n, i, r, o) {
                Ke.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: o
                }, this.fromBufferGeometry(new po(t, e, n, i, r, o)), this.mergeVertices()
            }

            function po(t, e, n, i, r, o) {
                pn.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: o
                }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, i = void 0 !== i ? Math.max(1, i) : 1;
                var a, s, c, l = [],
                    h = [],
                    u = [],
                    p = [],
                    d = t,
                    f = (e - t) / i,
                    m = new Te,
                    v = new be;
                for (s = 0; s <= i; s++) {
                    for (c = 0; c <= n; c++) a = r + c / n * o, m.x = d * Math.cos(a), m.y = d * Math.sin(a), h.push(m.x, m.y, m.z), u.push(0, 0, 1), v.x = (m.x / e + 1) / 2, v.y = (m.y / e + 1) / 2, p.push(v.x, v.y);
                    d += f
                }
                for (s = 0; s < i; s++) {
                    var g = s * (n + 1);
                    for (c = 0; c < n; c++) {
                        var y = a = c + g,
                            _ = a + n + 1,
                            x = a + n + 2,
                            b = a + 1;
                        l.push(y, _, b), l.push(_, x, b)
                    }
                }
                this.setIndex(l), this.addAttribute("position", new sn(h, 3)), this.addAttribute("normal", new sn(u, 3)), this.addAttribute("uv", new sn(p, 2))
            }

            function fo(t, e, n, i) {
                Ke.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: i
                }, this.fromBufferGeometry(new mo(t, e, n, i)), this.mergeVertices()
            }

            function mo(t, e, n, i) {
                pn.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: i
                }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = xe.clamp(i, 0, 2 * Math.PI);
                var r, o, a, s = [],
                    c = [],
                    l = [],
                    h = 1 / e,
                    u = new Te,
                    p = new be;
                for (o = 0; o <= e; o++) {
                    var d = n + o * h * i,
                        f = Math.sin(d),
                        m = Math.cos(d);
                    for (a = 0; a <= t.length - 1; a++) u.x = t[a].x * f, u.y = t[a].y, u.z = t[a].x * m, c.push(u.x, u.y, u.z), p.x = o / e, p.y = a / (t.length - 1), l.push(p.x, p.y)
                }
                for (o = 0; o < e; o++)
                    for (a = 0; a < t.length - 1; a++) {
                        var v = r = a + o * t.length,
                            g = r + t.length,
                            y = r + t.length + 1,
                            _ = r + 1;
                        s.push(v, g, _), s.push(g, y, _)
                    }
                if (this.setIndex(s), this.addAttribute("position", new sn(c, 3)), this.addAttribute("uv", new sn(l, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                    var x = this.attributes.normal.array,
                        b = new Te,
                        w = new Te,
                        M = new Te;
                    for (r = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3) b.x = x[a + 0], b.y = x[a + 1], b.z = x[a + 2], w.x = x[r + a + 0], w.y = x[r + a + 1], w.z = x[r + a + 2], M.addVectors(b, w).normalize(), x[a + 0] = x[r + a + 0] = M.x, x[a + 1] = x[r + a + 1] = M.y, x[a + 2] = x[r + a + 2] = M.z
                }
            }

            function vo(t, e) {
                Ke.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new go(t, e)), this.mergeVertices()
            }

            function go(t, e) {
                pn.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, e = e || 12;
                var n = [],
                    i = [],
                    r = [],
                    o = [],
                    a = 0,
                    s = 0;
                if (!1 === Array.isArray(t)) l(t);
                else
                    for (var c = 0; c < t.length; c++) l(t[c]), this.addGroup(a, s, c), a += s, s = 0;

                function l(t) {
                    var a, c, l, h = i.length / 3,
                        u = t.extractPoints(e),
                        p = u.shape,
                        d = u.holes;
                    if (!1 === to.isClockWise(p))
                        for (p = p.reverse(), a = 0, c = d.length; a < c; a++) l = d[a], !0 === to.isClockWise(l) && (d[a] = l.reverse());
                    var f = to.triangulateShape(p, d);
                    for (a = 0, c = d.length; a < c; a++) l = d[a], p = p.concat(l);
                    for (a = 0, c = p.length; a < c; a++) {
                        var m = p[a];
                        i.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y)
                    }
                    for (a = 0, c = f.length; a < c; a++) {
                        var v = f[a],
                            g = v[0] + h,
                            y = v[1] + h,
                            _ = v[2] + h;
                        n.push(g, y, _), s += 3
                    }
                }
                this.setIndex(n), this.addAttribute("position", new sn(i, 3)), this.addAttribute("normal", new sn(r, 3)), this.addAttribute("uv", new sn(o, 2))
            }

            function yo(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (var n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }

            function _o(t, e) {
                pn.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var n, i, r, o, a = [],
                    s = Math.cos(xe.DEG2RAD * e),
                    c = [0, 0],
                    l = {},
                    h = ["a", "b", "c"];
                t.isBufferGeometry ? (o = new Ke).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var u = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
                    for (var m = p[d], v = 0; v < 3; v++) n = m[h[v]], i = m[h[(v + 1) % 3]], c[0] = Math.min(n, i), c[1] = Math.max(n, i), r = c[0] + "," + c[1], void 0 === l[r] ? l[r] = {
                        index1: c[0],
                        index2: c[1],
                        face1: d,
                        face2: void 0
                    } : l[r].face2 = d;
                for (r in l) {
                    var g = l[r];
                    if (void 0 === g.face2 || p[g.face1].normal.dot(p[g.face2].normal) <= s) {
                        var y = u[g.index1];
                        a.push(y.x, y.y, y.z), y = u[g.index2], a.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new sn(a, 3))
            }

            function xo(t, e, n, i, r, o, a, s) {
                Ke.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new bo(t, e, n, i, r, o, a, s)), this.mergeVertices()
            }

            function bo(t, e, n, i, r, o, a, s) {
                pn.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                };
                var c = this;
                t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
                var l = [],
                    h = [],
                    u = [],
                    p = [],
                    d = 0,
                    f = [],
                    m = n / 2,
                    v = 0;

                function g(n) {
                    var r, o, f, g = new be,
                        y = new Te,
                        _ = 0,
                        x = !0 === n ? t : e,
                        b = !0 === n ? 1 : -1;
                    for (o = d, r = 1; r <= i; r++) h.push(0, m * b, 0), u.push(0, b, 0), p.push(.5, .5), d++;
                    for (f = d, r = 0; r <= i; r++) {
                        var w = r / i,
                            M = w * s + a,
                            T = Math.cos(M),
                            E = Math.sin(M);
                        y.x = x * E, y.y = m * b, y.z = x * T, h.push(y.x, y.y, y.z), u.push(0, b, 0), g.x = .5 * T + .5, g.y = .5 * E * b + .5, p.push(g.x, g.y), d++
                    }
                    for (r = 0; r < i; r++) {
                        var S = o + r,
                            A = f + r;
                        !0 === n ? l.push(A, A + 1, S) : l.push(A + 1, A, S), _ += 3
                    }
                    c.addGroup(v, _, !0 === n ? 1 : 2), v += _
                }! function() {
                    var o, g, y = new Te,
                        _ = new Te,
                        x = 0,
                        b = (e - t) / n;
                    for (g = 0; g <= r; g++) {
                        var w = [],
                            M = g / r,
                            T = M * (e - t) + t;
                        for (o = 0; o <= i; o++) {
                            var E = o / i,
                                S = E * s + a,
                                A = Math.sin(S),
                                P = Math.cos(S);
                            _.x = T * A, _.y = -M * n + m, _.z = T * P, h.push(_.x, _.y, _.z), y.set(A, b, P).normalize(), u.push(y.x, y.y, y.z), p.push(E, 1 - M), w.push(d++)
                        }
                        f.push(w)
                    }
                    for (o = 0; o < i; o++)
                        for (g = 0; g < r; g++) {
                            var L = f[g][o],
                                R = f[g + 1][o],
                                C = f[g + 1][o + 1],
                                O = f[g][o + 1];
                            l.push(L, R, O), l.push(R, C, O), x += 6
                        }
                    c.addGroup(v, x, 0), v += x
                }(), !1 === o && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(l), this.addAttribute("position", new sn(h, 3)), this.addAttribute("normal", new sn(u, 3)), this.addAttribute("uv", new sn(p, 2))
            }

            function wo(t, e, n, i, r, o, a) {
                xo.call(this, 0, t, e, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Mo(t, e, n, i, r, o, a) {
                bo.call(this, 0, t, e, n, i, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function To(t, e, n, i) {
                Ke.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: i
                }, this.fromBufferGeometry(new Eo(t, e, n, i)), this.mergeVertices()
            }

            function Eo(t, e, n, i) {
                pn.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: i
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI;
                var r, o, a = [],
                    s = [],
                    c = [],
                    l = [],
                    h = new Te,
                    u = new be;
                for (s.push(0, 0, 0), c.push(0, 0, 1), l.push(.5, .5), o = 0, r = 3; o <= e; o++, r += 3) {
                    var p = n + o / e * i;
                    h.x = t * Math.cos(p), h.y = t * Math.sin(p), s.push(h.x, h.y, h.z), c.push(0, 0, 1), u.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, l.push(u.x, u.y)
                }
                for (r = 1; r <= e; r++) a.push(r, r + 1, 0);
                this.setIndex(a), this.addAttribute("position", new sn(s, 3)), this.addAttribute("normal", new sn(c, 3)), this.addAttribute("uv", new sn(l, 2))
            }
            so.prototype = Object.create(Ke.prototype), so.prototype.constructor = so, co.prototype = Object.create(ro.prototype), co.prototype.constructor = co, lo.prototype = Object.create(Ke.prototype), lo.prototype.constructor = lo, ho.prototype = Object.create(pn.prototype), ho.prototype.constructor = ho, uo.prototype = Object.create(Ke.prototype), uo.prototype.constructor = uo, po.prototype = Object.create(pn.prototype), po.prototype.constructor = po, fo.prototype = Object.create(Ke.prototype), fo.prototype.constructor = fo, mo.prototype = Object.create(pn.prototype), mo.prototype.constructor = mo, vo.prototype = Object.create(Ke.prototype), vo.prototype.constructor = vo, vo.prototype.toJSON = function() {
                var t = Ke.prototype.toJSON.call(this),
                    e = this.parameters.shapes;
                return yo(e, t)
            }, go.prototype = Object.create(pn.prototype), go.prototype.constructor = go, go.prototype.toJSON = function() {
                var t = pn.prototype.toJSON.call(this),
                    e = this.parameters.shapes;
                return yo(e, t)
            }, _o.prototype = Object.create(pn.prototype), _o.prototype.constructor = _o, xo.prototype = Object.create(Ke.prototype), xo.prototype.constructor = xo, bo.prototype = Object.create(pn.prototype), bo.prototype.constructor = bo, wo.prototype = Object.create(xo.prototype), wo.prototype.constructor = wo, Mo.prototype = Object.create(bo.prototype), Mo.prototype.constructor = Mo, To.prototype = Object.create(Ke.prototype), To.prototype.constructor = To, Eo.prototype = Object.create(pn.prototype), Eo.prototype.constructor = Eo;
            var So = Object.freeze({
                WireframeGeometry: dr,
                ParametricGeometry: fr,
                ParametricBufferGeometry: mr,
                TetrahedronGeometry: yr,
                TetrahedronBufferGeometry: _r,
                OctahedronGeometry: xr,
                OctahedronBufferGeometry: br,
                IcosahedronGeometry: wr,
                IcosahedronBufferGeometry: Mr,
                DodecahedronGeometry: Tr,
                DodecahedronBufferGeometry: Er,
                PolyhedronGeometry: vr,
                PolyhedronBufferGeometry: gr,
                TubeGeometry: Sr,
                TubeBufferGeometry: Ar,
                TorusKnotGeometry: Pr,
                TorusKnotBufferGeometry: Lr,
                TorusGeometry: Rr,
                TorusBufferGeometry: Cr,
                TextGeometry: so,
                TextBufferGeometry: co,
                SphereGeometry: lo,
                SphereBufferGeometry: ho,
                RingGeometry: uo,
                RingBufferGeometry: po,
                PlaneGeometry: mn,
                PlaneBufferGeometry: vn,
                LatheGeometry: fo,
                LatheBufferGeometry: mo,
                ShapeGeometry: vo,
                ShapeBufferGeometry: go,
                ExtrudeGeometry: io,
                ExtrudeBufferGeometry: ro,
                EdgesGeometry: _o,
                ConeGeometry: wo,
                ConeBufferGeometry: Mo,
                CylinderGeometry: xo,
                CylinderBufferGeometry: bo,
                CircleGeometry: To,
                CircleBufferGeometry: Eo,
                BoxGeometry: dn,
                BoxBufferGeometry: fn
            });

            function Ao(t) {
                yn.call(this), this.type = "ShadowMaterial", this.color = new Ue(0), this.transparent = !0, this.setValues(t)
            }

            function Po(t) {
                _n.call(this, t), this.type = "RawShaderMaterial"
            }

            function Lo(t) {
                yn.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new Ue(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ye, this.normalScale = new be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Ro(t) {
                Lo.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
            }

            function Co(t) {
                yn.call(this), this.type = "MeshPhongMaterial", this.color = new Ue(16777215), this.specular = new Ue(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ye, this.normalScale = new be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Oo(t) {
                Co.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
            }

            function Io(t) {
                yn.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ye, this.normalScale = new be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Do(t) {
                yn.call(this), this.type = "MeshLambertMaterial", this.color = new Ue(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function No(t) {
                if (yn.call(this), this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new Ue(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ye, this.normalScale = new be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t), null === this.matcap) {
                    var e = document.createElement("canvas");
                    e.width = 1, e.height = 1;
                    var n = e.getContext("2d");
                    n.fillStyle = "#fff", n.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(e)
                }
            }

            function Bo(t) {
                ir.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            Ao.prototype = Object.create(yn.prototype), Ao.prototype.constructor = Ao, Ao.prototype.isShadowMaterial = !0, Ao.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, Po.prototype = Object.create(_n.prototype), Po.prototype.constructor = Po, Po.prototype.isRawShaderMaterial = !0, Lo.prototype = Object.create(yn.prototype), Lo.prototype.constructor = Lo, Lo.prototype.isMeshStandardMaterial = !0, Lo.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Ro.prototype = Object.create(Lo.prototype), Ro.prototype.constructor = Ro, Ro.prototype.isMeshPhysicalMaterial = !0, Ro.prototype.copy = function(t) {
                return Lo.prototype.copy.call(this, t), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
            }, Co.prototype = Object.create(yn.prototype), Co.prototype.constructor = Co, Co.prototype.isMeshPhongMaterial = !0, Co.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Oo.prototype = Object.create(Co.prototype), Oo.prototype.constructor = Oo, Oo.prototype.isMeshToonMaterial = !0, Oo.prototype.copy = function(t) {
                return Co.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
            }, Io.prototype = Object.create(yn.prototype), Io.prototype.constructor = Io, Io.prototype.isMeshNormalMaterial = !0, Io.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Do.prototype = Object.create(yn.prototype), Do.prototype.constructor = Do, Do.prototype.isMeshLambertMaterial = !0, Do.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, No.prototype = Object.create(yn.prototype), No.prototype.constructor = No, No.prototype.isMeshMatcapMaterial = !0, No.prototype.copy = function(t) {
                return yn.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Bo.prototype = Object.create(ir.prototype), Bo.prototype.constructor = Bo, Bo.prototype.isLineDashedMaterial = !0, Bo.prototype.copy = function(t) {
                return ir.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var Ho = Object.freeze({
                    ShadowMaterial: Ao,
                    SpriteMaterial: Ki,
                    RawShaderMaterial: Po,
                    ShaderMaterial: _n,
                    PointsMaterial: sr,
                    MeshPhysicalMaterial: Ro,
                    MeshStandardMaterial: Lo,
                    MeshPhongMaterial: Co,
                    MeshToonMaterial: Oo,
                    MeshNormalMaterial: Io,
                    MeshLambertMaterial: Do,
                    MeshDepthMaterial: Ni,
                    MeshDistanceMaterial: Bi,
                    MeshBasicMaterial: wn,
                    MeshMatcapMaterial: No,
                    LineDashedMaterial: Bo,
                    LineBasicMaterial: ir,
                    Material: yn
                }),
                Fo = {
                    enabled: !1,
                    files: {},
                    add: function(t, e) {
                        !1 !== this.enabled && (this.files[t] = e)
                    },
                    get: function(t) {
                        if (!1 !== this.enabled) return this.files[t]
                    },
                    remove: function(t) {
                        delete this.files[t]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };

            function ko(t, e, n) {
                var i = this,
                    r = !1,
                    o = 0,
                    a = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    a++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, a), r = !0
                }, this.itemEnd = function(t) {
                    o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (r = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function(t) {
                    return s ? s(t) : t
                }, this.setURLModifier = function(t) {
                    return s = t, this
                }
            }
            var Uo = new ko,
                zo = {};

            function Go(t) {
                this.manager = void 0 !== t ? t : Uo
            }

            function jo(t) {
                this.manager = void 0 !== t ? t : Uo, this._parser = null
            }

            function Vo(t) {
                this.manager = void 0 !== t ? t : Uo, this._parser = null
            }

            function Wo(t) {
                this.manager = void 0 !== t ? t : Uo
            }

            function Xo(t) {
                this.manager = void 0 !== t ? t : Uo
            }

            function qo(t) {
                this.manager = void 0 !== t ? t : Uo
            }

            function Yo() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function Zo(t, e, n, i, r, o, a, s) {
                Yo.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
            }

            function Jo(t, e, n, i, r, o) {
                Zo.call(this, t, e, n, n, i, r, o), this.type = "ArcCurve"
            }

            function Ko() {
                var t = 0,
                    e = 0,
                    n = 0,
                    i = 0;

                function r(r, o, a, s) {
                    t = r, e = a, n = -3 * r + 3 * o - 2 * a - s, i = 2 * r - 2 * o + a + s
                }
                return {
                    initCatmullRom: function(t, e, n, i, o) {
                        r(e, n, o * (n - t), o * (i - e))
                    },
                    initNonuniformCatmullRom: function(t, e, n, i, o, a, s) {
                        var c = (e - t) / o - (n - t) / (o + a) + (n - e) / a,
                            l = (n - e) / a - (i - e) / (a + s) + (i - n) / s;
                        r(e, n, c *= a, l *= a)
                    },
                    calc: function(r) {
                        var o = r * r,
                            a = o * r;
                        return t + e * r + n * o + i * a
                    }
                }
            }
            Object.assign(Go.prototype, {
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Fo.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    if (void 0 === zo[t]) {
                        var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (a) {
                            var s = a[1],
                                c = !!a[2],
                                l = a[3];
                            l = window.decodeURIComponent(l), c && (l = window.atob(l));
                            try {
                                var h, u = (this.responseType || "").toLowerCase();
                                switch (u) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var p = new Uint8Array(l.length), d = 0; d < l.length; d++) p[d] = l.charCodeAt(d);
                                        h = "blob" === u ? new Blob([p.buffer], {
                                            type: s
                                        }) : p.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        h = f.parseFromString(l, s);
                                        break;
                                    case "json":
                                        h = JSON.parse(l);
                                        break;
                                    default:
                                        h = l
                                }
                                window.setTimeout(function() {
                                    e && e(h), r.manager.itemEnd(t)
                                }, 0)
                            } catch (e) {
                                window.setTimeout(function() {
                                    i && i(e), r.manager.itemEnd(t), r.manager.itemError(t)
                                }, 0)
                            }
                        } else {
                            zo[t] = [], zo[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: i
                            });
                            var m = new XMLHttpRequest;
                            for (var v in m.open("GET", t, !0), m.addEventListener("load", function(e) {
                                    var n = this.response;
                                    Fo.add(t, n);
                                    var i = zo[t];
                                    if (delete zo[t], 200 === this.status || 0 === this.status) {
                                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                        for (var o = 0, a = i.length; o < a; o++) {
                                            var s = i[o];
                                            s.onLoad && s.onLoad(n)
                                        }
                                        r.manager.itemEnd(t)
                                    } else {
                                        for (var o = 0, a = i.length; o < a; o++) {
                                            var s = i[o];
                                            s.onError && s.onError(e)
                                        }
                                        r.manager.itemEnd(t), r.manager.itemError(t)
                                    }
                                }, !1), m.addEventListener("progress", function(e) {
                                    for (var n = zo[t], i = 0, r = n.length; i < r; i++) {
                                        var o = n[i];
                                        o.onProgress && o.onProgress(e)
                                    }
                                }, !1), m.addEventListener("error", function(e) {
                                    var n = zo[t];
                                    delete zo[t];
                                    for (var i = 0, o = n.length; i < o; i++) {
                                        var a = n[i];
                                        a.onError && a.onError(e)
                                    }
                                    r.manager.itemEnd(t), r.manager.itemError(t)
                                }, !1), m.addEventListener("abort", function(e) {
                                    var n = zo[t];
                                    delete zo[t];
                                    for (var i = 0, o = n.length; i < o; i++) {
                                        var a = n[i];
                                        a.onError && a.onError(e)
                                    }
                                    r.manager.itemEnd(t), r.manager.itemError(t)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                            m.send(null)
                        }
                        return r.manager.itemStart(t), m
                    }
                    zo[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    })
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            }), Object.assign(jo.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        o = [],
                        a = new hr;
                    a.image = o;
                    var s = new Go(this.manager);

                    function c(c) {
                        s.load(t[c], function(t) {
                            var n = r._parser(t, !0);
                            o[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, 6 === (l += 1) && (1 === n.mipmapCount && (a.minFilter = ut), a.format = n.format, a.needsUpdate = !0, e && e(a))
                        }, n, i)
                    }
                    if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                        for (var l = 0, h = 0, u = t.length; h < u; ++h) c(h);
                    else s.load(t, function(t) {
                        var n = r._parser(t, !0);
                        if (n.isCubemap)
                            for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                                o[s] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < n.mipmapCount; c++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
                            } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (a.minFilter = ut), a.format = n.format, a.needsUpdate = !0, e && e(a)
                    }, n, i);
                    return a
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Vo.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        o = new Oe,
                        a = new Go(this.manager);
                    return a.setResponseType("arraybuffer"), a.load(t, function(t) {
                        var n = r._parser(t);
                        n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : at, o.wrapT = void 0 !== n.wrapT ? n.wrapT : at, o.magFilter = void 0 !== n.magFilter ? n.magFilter : ut, o.minFilter = void 0 !== n.minFilter ? n.minFilter : dt, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps), 1 === n.mipmapCount && (o.minFilter = ut), o.needsUpdate = !0, e && e(o, n))
                    }, n, i), o
                }
            }), Object.assign(Wo.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Fo.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), Fo.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function c(e) {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), i && i(e), r.manager.itemEnd(t), r.manager.itemError(t)
                    }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Xo.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    var r = new En,
                        o = new Wo(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;

                    function s(n) {
                        o.load(t[n], function(t) {
                            r.images[n] = t, 6 == ++a && (r.needsUpdate = !0, e && e(r))
                        }, void 0, i)
                    }
                    for (var c = 0; c < t.length; ++c) s(c);
                    return r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(qo.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    var r = new Pe,
                        o = new Wo(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(n) {
                        r.image = n;
                        var i = t.search(/\.jpe?g$/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        r.format = i ? At : Pt, r.needsUpdate = !0, void 0 !== e && e(r)
                    }, n, i), r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Yo.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    var n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, n, i = [],
                        r = this.getPoint(0),
                        o = 0;
                    for (i.push(0), n = 1; n <= t; n++) e = this.getPoint(n / t), o += e.distanceTo(r), i.push(o), r = e;
                    return this.cacheArcLengths = i, i
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    var n, i = this.getLengths(),
                        r = 0,
                        o = i.length;
                    n = e || t * i[o - 1];
                    for (var a, s = 0, c = o - 1; s <= c;)
                        if (r = Math.floor(s + (c - s) / 2), (a = i[r] - n) < 0) s = r + 1;
                        else {
                            if (!(a > 0)) {
                                c = r;
                                break
                            }
                            c = r - 1
                        }
                    if (i[r = c] === n) return r / (o - 1);
                    var l = i[r],
                        h = i[r + 1],
                        u = h - l,
                        p = (n - l) / u,
                        d = (r + p) / (o - 1);
                    return d
                },
                getTangent: function(t) {
                    var e = t - 1e-4,
                        n = t + 1e-4;
                    e < 0 && (e = 0), n > 1 && (n = 1);
                    var i = this.getPoint(e),
                        r = this.getPoint(n),
                        o = r.clone().sub(i);
                    return o.normalize()
                },
                getTangentAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getTangent(e)
                },
                computeFrenetFrames: function(t, e) {
                    var n, i, r, o = new Te,
                        a = [],
                        s = [],
                        c = [],
                        l = new Te,
                        h = new we;
                    for (n = 0; n <= t; n++) i = n / t, a[n] = this.getTangentAt(i), a[n].normalize();
                    s[0] = new Te, c[0] = new Te;
                    var u = Number.MAX_VALUE,
                        p = Math.abs(a[0].x),
                        d = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (p <= u && (u = p, o.set(1, 0, 0)), d <= u && (u = d, o.set(0, 1, 0)), f <= u && o.set(0, 0, 1), l.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], l), c[0].crossVectors(a[0], s[0]), n = 1; n <= t; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), l.crossVectors(a[n - 1], a[n]), l.length() > Number.EPSILON && (l.normalize(), r = Math.acos(xe.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(h.makeRotationAxis(l, r))), c[n].crossVectors(a[n], s[n]);
                    if (!0 === e)
                        for (r = Math.acos(xe.clamp(s[0].dot(s[t]), -1, 1)), r /= t, a[0].dot(l.crossVectors(s[0], s[t])) > 0 && (r = -r), n = 1; n <= t; n++) s[n].applyMatrix4(h.makeRotationAxis(a[n], r * n)), c[n].crossVectors(a[n], s[n]);
                    return {
                        tangents: a,
                        normals: s,
                        binormals: c
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), Zo.prototype = Object.create(Yo.prototype), Zo.prototype.constructor = Zo, Zo.prototype.isEllipseCurve = !0, Zo.prototype.getPoint = function(t, e) {
                for (var n = e || new be, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0;) r += i;
                for (; r > i;) r -= i;
                r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
                var a = this.aStartAngle + t * r,
                    s = this.aX + this.xRadius * Math.cos(a),
                    c = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var l = Math.cos(this.aRotation),
                        h = Math.sin(this.aRotation),
                        u = s - this.aX,
                        p = c - this.aY;
                    s = u * l - p * h + this.aX, c = u * h + p * l + this.aY
                }
                return n.set(s, c)
            }, Zo.prototype.copy = function(t) {
                return Yo.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Zo.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, Zo.prototype.fromJSON = function(t) {
                return Yo.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Jo.prototype = Object.create(Zo.prototype), Jo.prototype.constructor = Jo, Jo.prototype.isArcCurve = !0;
            var Qo = new Te,
                $o = new Ko,
                ta = new Ko,
                ea = new Ko;

            function na(t, e, n, i) {
                Yo.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = i || .5
            }

            function ia(t, e, n, i, r) {
                var o = .5 * (i - e),
                    a = .5 * (r - n),
                    s = t * t,
                    c = t * s;
                return (2 * n - 2 * i + o + a) * c + (-3 * n + 3 * i - 2 * o - a) * s + o * t + n
            }

            function ra(t, e, n, i) {
                return function(t, e) {
                    var n = 1 - t;
                    return n * n * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, n) + function(t, e) {
                    return t * t * e
                }(t, i)
            }

            function oa(t, e, n, i, r) {
                return function(t, e) {
                    var n = 1 - t;
                    return n * n * n * e
                }(t, e) + function(t, e) {
                    var n = 1 - t;
                    return 3 * n * n * t * e
                }(t, n) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, i) + function(t, e) {
                    return t * t * t * e
                }(t, r)
            }

            function aa(t, e, n, i) {
                Yo.call(this), this.type = "CubicBezierCurve", this.v0 = t || new be, this.v1 = e || new be, this.v2 = n || new be, this.v3 = i || new be
            }

            function sa(t, e, n, i) {
                Yo.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Te, this.v1 = e || new Te, this.v2 = n || new Te, this.v3 = i || new Te
            }

            function ca(t, e) {
                Yo.call(this), this.type = "LineCurve", this.v1 = t || new be, this.v2 = e || new be
            }

            function la(t, e) {
                Yo.call(this), this.type = "LineCurve3", this.v1 = t || new Te, this.v2 = e || new Te
            }

            function ha(t, e, n) {
                Yo.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new be, this.v1 = e || new be, this.v2 = n || new be
            }

            function ua(t, e, n) {
                Yo.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Te, this.v1 = e || new Te, this.v2 = n || new Te
            }

            function pa(t) {
                Yo.call(this), this.type = "SplineCurve", this.points = t || []
            }
            na.prototype = Object.create(Yo.prototype), na.prototype.constructor = na, na.prototype.isCatmullRomCurve3 = !0, na.prototype.getPoint = function(t, e) {
                var n, i, r, o, a = e || new Te,
                    s = this.points,
                    c = s.length,
                    l = (c - (this.closed ? 0 : 1)) * t,
                    h = Math.floor(l),
                    u = l - h;
                if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / c) + 1) * c : 0 === u && h === c - 1 && (h = c - 2, u = 1), this.closed || h > 0 ? n = s[(h - 1) % c] : (Qo.subVectors(s[0], s[1]).add(s[0]), n = Qo), i = s[h % c], r = s[(h + 1) % c], this.closed || h + 2 < c ? o = s[(h + 2) % c] : (Qo.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = Qo), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var p = "chordal" === this.curveType ? .5 : .25,
                        d = Math.pow(n.distanceToSquared(i), p),
                        f = Math.pow(i.distanceToSquared(r), p),
                        m = Math.pow(r.distanceToSquared(o), p);
                    f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), $o.initNonuniformCatmullRom(n.x, i.x, r.x, o.x, d, f, m), ta.initNonuniformCatmullRom(n.y, i.y, r.y, o.y, d, f, m), ea.initNonuniformCatmullRom(n.z, i.z, r.z, o.z, d, f, m)
                } else "catmullrom" === this.curveType && ($o.initCatmullRom(n.x, i.x, r.x, o.x, this.tension), ta.initCatmullRom(n.y, i.y, r.y, o.y, this.tension), ea.initCatmullRom(n.z, i.z, r.z, o.z, this.tension));
                return a.set($o.calc(u), ta.calc(u), ea.calc(u)), a
            }, na.prototype.copy = function(t) {
                Yo.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push(i.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, na.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, na.prototype.fromJSON = function(t) {
                Yo.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push((new Te).fromArray(i))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, aa.prototype = Object.create(Yo.prototype), aa.prototype.constructor = aa, aa.prototype.isCubicBezierCurve = !0, aa.prototype.getPoint = function(t, e) {
                var n = e || new be,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(oa(t, i.x, r.x, o.x, a.x), oa(t, i.y, r.y, o.y, a.y)), n
            }, aa.prototype.copy = function(t) {
                return Yo.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, aa.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, aa.prototype.fromJSON = function(t) {
                return Yo.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, sa.prototype = Object.create(Yo.prototype), sa.prototype.constructor = sa, sa.prototype.isCubicBezierCurve3 = !0, sa.prototype.getPoint = function(t, e) {
                var n = e || new Te,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(oa(t, i.x, r.x, o.x, a.x), oa(t, i.y, r.y, o.y, a.y), oa(t, i.z, r.z, o.z, a.z)), n
            }, sa.prototype.copy = function(t) {
                return Yo.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, sa.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, sa.prototype.fromJSON = function(t) {
                return Yo.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, ca.prototype = Object.create(Yo.prototype), ca.prototype.constructor = ca, ca.prototype.isLineCurve = !0, ca.prototype.getPoint = function(t, e) {
                var n = e || new be;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, ca.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, ca.prototype.getTangent = function() {
                var t = this.v2.clone().sub(this.v1);
                return t.normalize()
            }, ca.prototype.copy = function(t) {
                return Yo.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, ca.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, ca.prototype.fromJSON = function(t) {
                return Yo.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, la.prototype = Object.create(Yo.prototype), la.prototype.constructor = la, la.prototype.isLineCurve3 = !0, la.prototype.getPoint = function(t, e) {
                var n = e || new Te;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, la.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, la.prototype.copy = function(t) {
                return Yo.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, la.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, la.prototype.fromJSON = function(t) {
                return Yo.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, ha.prototype = Object.create(Yo.prototype), ha.prototype.constructor = ha, ha.prototype.isQuadraticBezierCurve = !0, ha.prototype.getPoint = function(t, e) {
                var n = e || new be,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2;
                return n.set(ra(t, i.x, r.x, o.x), ra(t, i.y, r.y, o.y)), n
            }, ha.prototype.copy = function(t) {
                return Yo.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, ha.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, ha.prototype.fromJSON = function(t) {
                return Yo.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, ua.prototype = Object.create(Yo.prototype), ua.prototype.constructor = ua, ua.prototype.isQuadraticBezierCurve3 = !0, ua.prototype.getPoint = function(t, e) {
                var n = e || new Te,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2;
                return n.set(ra(t, i.x, r.x, o.x), ra(t, i.y, r.y, o.y), ra(t, i.z, r.z, o.z)), n
            }, ua.prototype.copy = function(t) {
                return Yo.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, ua.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, ua.prototype.fromJSON = function(t) {
                return Yo.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, pa.prototype = Object.create(Yo.prototype), pa.prototype.constructor = pa, pa.prototype.isSplineCurve = !0, pa.prototype.getPoint = function(t, e) {
                var n = e || new be,
                    i = this.points,
                    r = (i.length - 1) * t,
                    o = Math.floor(r),
                    a = r - o,
                    s = i[0 === o ? o : o - 1],
                    c = i[o],
                    l = i[o > i.length - 2 ? i.length - 1 : o + 1],
                    h = i[o > i.length - 3 ? i.length - 1 : o + 2];
                return n.set(ia(a, s.x, c.x, l.x, h.x), ia(a, s.y, c.y, l.y, h.y)), n
            }, pa.prototype.copy = function(t) {
                Yo.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push(i.clone())
                }
                return this
            }, pa.prototype.toJSON = function() {
                var t = Yo.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t
            }, pa.prototype.fromJSON = function(t) {
                Yo.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push((new be).fromArray(i))
                }
                return this
            };
            var da = Object.freeze({
                ArcCurve: Jo,
                CatmullRomCurve3: na,
                CubicBezierCurve: aa,
                CubicBezierCurve3: sa,
                EllipseCurve: Zo,
                LineCurve: ca,
                LineCurve3: la,
                QuadraticBezierCurve: ha,
                QuadraticBezierCurve3: ua,
                SplineCurve: pa
            });

            function fa() {
                Yo.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function ma(t) {
                fa.call(this), this.type = "Path", this.currentPoint = new be, t && this.setFromPoints(t)
            }

            function va(t) {
                ma.call(this, t), this.uuid = xe.generateUUID(), this.type = "Shape", this.holes = []
            }

            function ga(t, e) {
                Ze.call(this), this.type = "Light", this.color = new Ue(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
            }

            function ya(t, e, n) {
                ga.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Ze.DefaultUp), this.updateMatrix(), this.groundColor = new Ue(e)
            }

            function _a(t) {
                this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new be(512, 512), this.map = null, this.matrix = new we
            }

            function xa() {
                _a.call(this, new Gi(50, 1, .5, 500))
            }

            function ba(t, e, n, i, r, o) {
                ga.call(this, t, e), this.type = "SpotLight", this.position.copy(Ze.DefaultUp), this.updateMatrix(), this.target = new Ze, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new xa
            }

            function wa(t, e, n, i) {
                ga.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new _a(new Gi(90, 1, .5, 500))
            }

            function Ma(t, e, n, i, r, o) {
                zi.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
            }

            function Ta() {
                _a.call(this, new Ma(-5, 5, 5, -5, .5, 500))
            }

            function Ea(t, e) {
                ga.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Ze.DefaultUp), this.updateMatrix(), this.target = new Ze, this.shadow = new Ta
            }

            function Sa(t, e) {
                ga.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
            }

            function Aa(t, e, n, i) {
                ga.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
            }
            fa.prototype = Object.assign(Object.create(Yo.prototype), {
                constructor: fa,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new ca(e, t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                        if (n[i] >= e) {
                            var r = n[i] - e,
                                o = this.curves[i],
                                a = o.getLength(),
                                s = 0 === a ? 0 : 1 - r / a;
                            return o.getPointAt(s)
                        }
                        i++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
                        for (var o = r[i], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) {
                            var l = s[c];
                            e && e.equals(l) || (n.push(l), e = l)
                        }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function(t) {
                    Yo.prototype.copy.call(this, t), this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var i = t.curves[e];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    var t = Yo.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (var e = 0, n = this.curves.length; e < n; e++) {
                        var i = this.curves[e];
                        t.curves.push(i.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    Yo.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var i = t.curves[e];
                        this.curves.push((new da[i.type]).fromJSON(i))
                    }
                    return this
                }
            }), ma.prototype = Object.assign(Object.create(fa.prototype), {
                constructor: ma,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
                },
                moveTo: function(t, e) {
                    this.currentPoint.set(t, e)
                },
                lineTo: function(t, e) {
                    var n = new ca(this.currentPoint.clone(), new be(t, e));
                    this.curves.push(n), this.currentPoint.set(t, e)
                },
                quadraticCurveTo: function(t, e, n, i) {
                    var r = new ha(this.currentPoint.clone(), new be(t, e), new be(n, i));
                    this.curves.push(r), this.currentPoint.set(n, i)
                },
                bezierCurveTo: function(t, e, n, i, r, o) {
                    var a = new aa(this.currentPoint.clone(), new be(t, e), new be(n, i), new be(r, o));
                    this.curves.push(a), this.currentPoint.set(r, o)
                },
                splineThru: function(t) {
                    var e = [this.currentPoint.clone()].concat(t),
                        n = new pa(e);
                    this.curves.push(n), this.currentPoint.copy(t[t.length - 1])
                },
                arc: function(t, e, n, i, r, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(t + a, e + s, n, i, r, o)
                },
                absarc: function(t, e, n, i, r, o) {
                    this.absellipse(t, e, n, n, i, r, o)
                },
                ellipse: function(t, e, n, i, r, o, a, s) {
                    var c = this.currentPoint.x,
                        l = this.currentPoint.y;
                    this.absellipse(t + c, e + l, n, i, r, o, a, s)
                },
                absellipse: function(t, e, n, i, r, o, a, s) {
                    var c = new Zo(t, e, n, i, r, o, a, s);
                    if (this.curves.length > 0) {
                        var l = c.getPoint(0);
                        l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
                    }
                    this.curves.push(c);
                    var h = c.getPoint(1);
                    this.currentPoint.copy(h)
                },
                copy: function(t) {
                    return fa.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    var t = fa.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return fa.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), va.prototype = Object.assign(Object.create(ma.prototype), {
                constructor: va,
                getPointsHoles: function(t) {
                    for (var e = [], n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    ma.prototype.copy.call(this, t), this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var i = t.holes[e];
                        this.holes.push(i.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var t = ma.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (var e = 0, n = this.holes.length; e < n; e++) {
                        var i = this.holes[e];
                        t.holes.push(i.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    ma.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var i = t.holes[e];
                        this.holes.push((new ma).fromJSON(i))
                    }
                    return this
                }
            }), ga.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: ga,
                isLight: !0,
                copy: function(t) {
                    return Ze.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = Ze.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), ya.prototype = Object.assign(Object.create(ga.prototype), {
                constructor: ya,
                isHemisphereLight: !0,
                copy: function(t) {
                    return ga.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(_a.prototype, {
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), xa.prototype = Object.assign(Object.create(_a.prototype), {
                constructor: xa,
                isSpotLightShadow: !0,
                update: function(t) {
                    var e = this.camera,
                        n = 2 * xe.RAD2DEG * t.angle,
                        i = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix())
                }
            }), ba.prototype = Object.assign(Object.create(ga.prototype), {
                constructor: ba,
                isSpotLight: !0,
                copy: function(t) {
                    return ga.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), wa.prototype = Object.assign(Object.create(ga.prototype), {
                constructor: wa,
                isPointLight: !0,
                copy: function(t) {
                    return ga.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), Ma.prototype = Object.assign(Object.create(zi.prototype), {
                constructor: Ma,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return zi.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, n, i, r, o) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2,
                        r = n - t,
                        o = n + t,
                        a = i + e,
                        s = i - e;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            l = this.zoom / (this.view.height / this.view.fullHeight),
                            h = (this.right - this.left) / this.view.width,
                            u = (this.top - this.bottom) / this.view.height;
                        r += h * (this.view.offsetX / c), o = r + h * (this.view.width / c), a -= u * (this.view.offsetY / l), s = a - u * (this.view.height / l)
                    }
                    this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = Ze.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), Ta.prototype = Object.assign(Object.create(_a.prototype), {
                constructor: Ta
            }), Ea.prototype = Object.assign(Object.create(ga.prototype), {
                constructor: Ea,
                isDirectionalLight: !0,
                copy: function(t) {
                    return ga.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Sa.prototype = Object.assign(Object.create(ga.prototype), {
                constructor: Sa,
                isAmbientLight: !0
            }), Aa.prototype = Object.assign(Object.create(ga.prototype), {
                constructor: Aa,
                isRectAreaLight: !0,
                copy: function(t) {
                    return ga.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    var e = ga.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            });
            var Pa = {
                arraySlice: function(t, e, n) {
                    return Pa.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                },
                convertArray: function(t, e, n) {
                    return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(t) {
                    for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i) n[i] = i;
                    return n.sort(function(e, n) {
                        return t[e] - t[n]
                    }), n
                },
                sortedArray: function(t, e, n) {
                    for (var i = t.length, r = new t.constructor(i), o = 0, a = 0; a !== i; ++o)
                        for (var s = n[o] * e, c = 0; c !== e; ++c) r[a++] = t[s + c];
                    return r
                },
                flattenJSON: function(t, e, n, i) {
                    for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[i];) o = t[r++];
                    if (void 0 !== o) {
                        var a = o[i];
                        if (void 0 !== a)
                            if (Array.isArray(a))
                                do {
                                    void 0 !== (a = o[i]) && (e.push(o.time), n.push.apply(n, a)), o = t[r++]
                                } while (void 0 !== o);
                            else if (void 0 !== a.toArray)
                            do {
                                void 0 !== (a = o[i]) && (e.push(o.time), a.toArray(n, n.length)), o = t[r++]
                            } while (void 0 !== o);
                        else
                            do {
                                void 0 !== (a = o[i]) && (e.push(o.time), n.push(a)), o = t[r++]
                            } while (void 0 !== o)
                    }
                }
            };

            function La(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
            }

            function Ra(t, e, n, i) {
                La.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function Ca(t, e, n, i) {
                La.call(this, t, e, n, i)
            }

            function Oa(t, e, n, i) {
                La.call(this, t, e, n, i)
            }

            function Ia(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Pa.convertArray(e, this.TimeBufferType), this.values = Pa.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }

            function Da(t, e, n) {
                Ia.call(this, t, e, n)
            }

            function Na(t, e, n, i) {
                Ia.call(this, t, e, n, i)
            }

            function Ba(t, e, n, i) {
                Ia.call(this, t, e, n, i)
            }

            function Ha(t, e, n, i) {
                La.call(this, t, e, n, i)
            }

            function Fa(t, e, n, i) {
                Ia.call(this, t, e, n, i)
            }

            function ka(t, e, n, i) {
                Ia.call(this, t, e, n, i)
            }

            function Ua(t, e, n, i) {
                Ia.call(this, t, e, n, i)
            }

            function za(t, e, n) {
                this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = xe.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function Ga(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Ba;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Ua;
                        case "color":
                            return Na;
                        case "quaternion":
                            return Fa;
                        case "bool":
                        case "boolean":
                            return Da;
                        case "string":
                            return ka
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    var n = [],
                        i = [];
                    Pa.flattenJSON(t.keys, n, i, "value"), t.times = n, t.values = i
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }

            function ja(t) {
                this.manager = void 0 !== t ? t : Uo, this.textures = {}
            }

            function Va(t) {
                this.manager = void 0 !== t ? t : Uo
            }
            Object.assign(La.prototype, {
                    evaluate: function(t) {
                        var e = this.parameterPositions,
                            n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                var o;n: {
                                    i: if (!(t < i)) {
                                        for (var a = n + 2;;) {
                                            if (void 0 === i) {
                                                if (t < r) break i;
                                                return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                            }
                                            if (n === a) break;
                                            if (r = i, i = e[++n], t < i) break e
                                        }
                                        o = e.length;
                                        break n
                                    }if (t >= r) break t;
                                    var s = e[1];t < s && (n = 2, r = s);
                                    for (var a = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                        if (n === a) break;
                                        if (i = r, r = e[--n - 1], t >= r) break e
                                    }
                                    o = n,
                                    n = 0
                                }
                                for (; n < o;) {
                                    var c = n + o >>> 1;
                                    t < e[c] ? o = c : n = c + 1
                                }
                                if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, r, i)
                        }
                        return this.interpolate_(n, r, t, i)
                    },
                    settings: null,
                    DefaultSettings_: {},
                    getSettings_: function() {
                        return this.settings || this.DefaultSettings_
                    },
                    copySampleValue_: function(t) {
                        for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, o = 0; o !== i; ++o) e[o] = n[r + o];
                        return e
                    },
                    interpolate_: function() {
                        throw new Error("call to abstract method")
                    },
                    intervalChanged_: function() {}
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(La.prototype, {
                    beforeStart_: La.prototype.copySampleValue_,
                    afterEnd_: La.prototype.copySampleValue_
                }), Ra.prototype = Object.assign(Object.create(La.prototype), {
                    constructor: Ra,
                    DefaultSettings_: {
                        endingStart: oe,
                        endingEnd: oe
                    },
                    intervalChanged_: function(t, e, n) {
                        var i = this.parameterPositions,
                            r = t - 2,
                            o = t + 1,
                            a = i[r],
                            s = i[o];
                        if (void 0 === a) switch (this.getSettings_().endingStart) {
                            case 2401:
                                r = t, a = 2 * e - n;
                                break;
                            case 2402:
                                r = i.length - 2, a = e + i[r] - i[r + 1];
                                break;
                            default:
                                r = t, a = n
                        }
                        if (void 0 === s) switch (this.getSettings_().endingEnd) {
                            case 2401:
                                o = t, s = 2 * n - e;
                                break;
                            case 2402:
                                o = 1, s = n + i[1] - i[0];
                                break;
                            default:
                                o = t - 1, s = e
                        }
                        var c = .5 * (n - e),
                            l = this.valueSize;
                        this._weightPrev = c / (e - a), this._weightNext = c / (s - n), this._offsetPrev = r * l, this._offsetNext = o * l
                    },
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (n - e) / (i - e), f = d * d, m = f * d, v = -u * m + 2 * u * f - u * d, g = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, _ = p * m - p * f, x = 0; x !== a; ++x) r[x] = v * o[l + x] + g * o[c + x] + y * o[s + x] + _ * o[h + x];
                        return r
                    }
                }), Ca.prototype = Object.assign(Object.create(La.prototype), {
                    constructor: Ca,
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = (n - e) / (i - e), h = 1 - l, u = 0; u !== a; ++u) r[u] = o[c + u] * h + o[s + u] * l;
                        return r
                    }
                }), Oa.prototype = Object.assign(Object.create(La.prototype), {
                    constructor: Oa,
                    interpolate_: function(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }), Object.assign(Ia, {
                    toJSON: function(t) {
                        var e, n = t.constructor;
                        if (void 0 !== n.toJSON) e = n.toJSON(t);
                        else {
                            e = {
                                name: t.name,
                                times: Pa.convertArray(t.times, Array),
                                values: Pa.convertArray(t.values, Array)
                            };
                            var i = t.getInterpolation();
                            i !== t.DefaultInterpolation && (e.interpolation = i)
                        }
                        return e.type = t.ValueTypeName, e
                    }
                }), Object.assign(Ia.prototype, {
                    constructor: Ia,
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: 2301,
                    InterpolantFactoryMethodDiscrete: function(t) {
                        return new Oa(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodLinear: function(t) {
                        return new Ca(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: function(t) {
                        return new Ra(this.times, this.values, this.getValueSize(), t)
                    },
                    setInterpolation: function(t) {
                        var e;
                        switch (t) {
                            case 2300:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case 2301:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case 2302:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(n);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", n), this
                        }
                        return this.createInterpolant = e, this
                    },
                    getInterpolation: function() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return 2300;
                            case this.InterpolantFactoryMethodLinear:
                                return 2301;
                            case this.InterpolantFactoryMethodSmooth:
                                return 2302
                        }
                    },
                    getValueSize: function() {
                        return this.values.length / this.times.length
                    },
                    shift: function(t) {
                        if (0 !== t)
                            for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] += t;
                        return this
                    },
                    scale: function(t) {
                        if (1 !== t)
                            for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] *= t;
                        return this
                    },
                    trim: function(t, e) {
                        for (var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < t;) ++r;
                        for (; - 1 !== o && n[o] > e;) --o;
                        if (++o, 0 !== r || o !== i) {
                            r >= o && (o = Math.max(o, 1), r = o - 1);
                            var a = this.getValueSize();
                            this.times = Pa.arraySlice(n, r, o), this.values = Pa.arraySlice(this.values, r * a, o * a)
                        }
                        return this
                    },
                    validate: function() {
                        var t = !0,
                            e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        var n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        for (var o = null, a = 0; a !== r; a++) {
                            var s = n[a];
                            if ("number" == typeof s && isNaN(s)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                                break
                            }
                            if (null !== o && o > s) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                                break
                            }
                            o = s
                        }
                        if (void 0 !== i && Pa.isTypedArray(i))
                            for (var a = 0, c = i.length; a !== c; ++a) {
                                var l = i[a];
                                if (isNaN(l)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), t = !1;
                                    break
                                }
                            }
                        return t
                    },
                    optimize: function() {
                        for (var t = this.times, e = this.values, n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                            var s = !1,
                                c = t[a],
                                l = t[a + 1];
                            if (c !== l && (1 !== a || c !== c[0]))
                                if (i) s = !0;
                                else
                                    for (var h = a * n, u = h - n, p = h + n, d = 0; d !== n; ++d) {
                                        var f = e[h + d];
                                        if (f !== e[u + d] || f !== e[p + d]) {
                                            s = !0;
                                            break
                                        }
                                    }
                            if (s) {
                                if (a !== r) {
                                    t[r] = t[a];
                                    for (var m = a * n, v = r * n, d = 0; d !== n; ++d) e[v + d] = e[m + d]
                                }++r
                            }
                        }
                        if (o > 0) {
                            t[r] = t[o];
                            for (var m = o * n, v = r * n, d = 0; d !== n; ++d) e[v + d] = e[m + d];
                            ++r
                        }
                        return r !== t.length && (this.times = Pa.arraySlice(t, 0, r), this.values = Pa.arraySlice(e, 0, r * n)), this
                    }
                }), Da.prototype = Object.assign(Object.create(Ia.prototype), {
                    constructor: Da,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: 2300,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), Na.prototype = Object.assign(Object.create(Ia.prototype), {
                    constructor: Na,
                    ValueTypeName: "color"
                }), Ba.prototype = Object.assign(Object.create(Ia.prototype), {
                    constructor: Ba,
                    ValueTypeName: "number"
                }), Ha.prototype = Object.assign(Object.create(La.prototype), {
                    constructor: Ha,
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = (n - e) / (i - e), l = s + a; s !== l; s += 4) Me.slerpFlat(r, 0, o, s - a, o, s, c);
                        return r
                    }
                }), Fa.prototype = Object.assign(Object.create(Ia.prototype), {
                    constructor: Fa,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: 2301,
                    InterpolantFactoryMethodLinear: function(t) {
                        return new Ha(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: void 0
                }), ka.prototype = Object.assign(Object.create(Ia.prototype), {
                    constructor: ka,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: 2300,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), Ua.prototype = Object.assign(Object.create(Ia.prototype), {
                    constructor: Ua,
                    ValueTypeName: "vector"
                }), Object.assign(za, {
                    parse: function(t) {
                        for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, o = n.length; r !== o; ++r) e.push(Ga(n[r]).scale(i));
                        return new za(t.name, t.duration, e)
                    },
                    toJSON: function(t) {
                        for (var e = [], n = t.tracks, i = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid
                            }, r = 0, o = n.length; r !== o; ++r) e.push(Ia.toJSON(n[r]));
                        return i
                    },
                    CreateFromMorphTargetSequence: function(t, e, n, i) {
                        for (var r = e.length, o = [], a = 0; a < r; a++) {
                            var s = [],
                                c = [];
                            s.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
                            var l = Pa.getKeyframeOrder(s);
                            s = Pa.sortedArray(s, 1, l), c = Pa.sortedArray(c, 1, l), i || 0 !== s[0] || (s.push(r), c.push(c[0])), o.push(new Ba(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(1 / n))
                        }
                        return new za(t, -1, o)
                    },
                    findByName: function(t, e) {
                        var n = t;
                        if (!Array.isArray(t)) {
                            var i = t;
                            n = i.geometry && i.geometry.animations || i.animations
                        }
                        for (var r = 0; r < n.length; r++)
                            if (n[r].name === e) return n[r];
                        return null
                    },
                    CreateClipsFromMorphTargetSequences: function(t, e, n) {
                        for (var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                            var s = t[o],
                                c = s.name.match(r);
                            if (c && c.length > 1) {
                                var l = c[1],
                                    h = i[l];
                                h || (i[l] = h = []), h.push(s)
                            }
                        }
                        var u = [];
                        for (var l in i) u.push(za.CreateFromMorphTargetSequence(l, i[l], e, n));
                        return u
                    },
                    parseAnimation: function(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        for (var n = function(t, e, n, i, r) {
                                if (0 !== n.length) {
                                    var o = [],
                                        a = [];
                                    Pa.flattenJSON(n, o, a, i), 0 !== o.length && r.push(new t(e, o, a))
                                }
                            }, i = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                            var l = s[c].keys;
                            if (l && 0 !== l.length)
                                if (l[0].morphTargets) {
                                    for (var h = {}, u = 0; u < l.length; u++)
                                        if (l[u].morphTargets)
                                            for (var p = 0; p < l[u].morphTargets.length; p++) h[l[u].morphTargets[p]] = -1;
                                    for (var d in h) {
                                        for (var f = [], m = [], p = 0; p !== l[u].morphTargets.length; ++p) {
                                            var v = l[u];
                                            f.push(v.time), m.push(v.morphTarget === d ? 1 : 0)
                                        }
                                        i.push(new Ba(".morphTargetInfluence[" + d + "]", f, m))
                                    }
                                    o = h.length * (a || 1)
                                } else {
                                    var g = ".bones[" + e[c].name + "]";
                                    n(Ua, g + ".position", l, "pos", i), n(Fa, g + ".quaternion", l, "rot", i), n(Ua, g + ".scale", l, "scl", i)
                                }
                        }
                        if (0 === i.length) return null;
                        var y = new za(r, o, i);
                        return y
                    }
                }), Object.assign(za.prototype, {
                    resetDuration: function() {
                        for (var t = this.tracks, e = 0, n = 0, i = t.length; n !== i; ++n) {
                            var r = this.tracks[n];
                            e = Math.max(e, r.times[r.times.length - 1])
                        }
                        return this.duration = e, this
                    },
                    trim: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                        return this
                    },
                    validate: function() {
                        for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                        return t
                    },
                    optimize: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                        return this
                    }
                }), Object.assign(ja.prototype, {
                    load: function(t, e, n, i) {
                        var r = this,
                            o = new Go(r.manager);
                        o.load(t, function(t) {
                            e(r.parse(JSON.parse(t)))
                        }, n, i)
                    },
                    setTextures: function(t) {
                        this.textures = t
                    },
                    parse: function(t) {
                        var e = this.textures;

                        function n(t) {
                            return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                        }
                        var i = new Ho[t.type];
                        if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearCoat && (i.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (i.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (i.vertexColors = t.vertexColors), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.uniforms)
                            for (var r in t.uniforms) {
                                var o = t.uniforms[r];
                                switch (i.uniforms[r] = {}, o.type) {
                                    case "t":
                                        i.uniforms[r].value = n(o.value);
                                        break;
                                    case "c":
                                        i.uniforms[r].value = (new Ue).setHex(o.value);
                                        break;
                                    case "v2":
                                        i.uniforms[r].value = (new be).fromArray(o.value);
                                        break;
                                    case "v3":
                                        i.uniforms[r].value = (new Te).fromArray(o.value);
                                        break;
                                    case "v4":
                                        i.uniforms[r].value = (new Le).fromArray(o.value);
                                        break;
                                    case "m4":
                                        i.uniforms[r].value = (new we).fromArray(o.value);
                                        break;
                                    default:
                                        i.uniforms[r].value = o.value
                                }
                            }
                        if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap), i.transparent = !0), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                            var a = t.normalScale;
                            !1 === Array.isArray(a) && (a = [a, a]), i.normalScale = (new be).fromArray(a)
                        }
                        return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), i
                    }
                }), Object.assign(Va.prototype, {
                    load: function(t, e, n, i) {
                        var r = this,
                            o = new Go(r.manager);
                        o.load(t, function(t) {
                            e(r.parse(JSON.parse(t)))
                        }, n, i)
                    },
                    parse: function(t) {
                        var e = new pn,
                            n = t.data.index;
                        if (void 0 !== n) {
                            var i = new Wa[n.type](n.array);
                            e.setIndex(new Qe(i, 1))
                        }
                        var r = t.data.attributes;
                        for (var o in r) {
                            var a = r[o],
                                i = new Wa[a.type](a.array);
                            e.addAttribute(o, new Qe(i, a.itemSize, a.normalized))
                        }
                        var s = t.data.groups || t.data.drawcalls || t.data.offsets;
                        if (void 0 !== s)
                            for (var c = 0, l = s.length; c !== l; ++c) {
                                var h = s[c];
                                e.addGroup(h.start, h.count, h.materialIndex)
                            }
                        var u = t.data.boundingSphere;
                        if (void 0 !== u) {
                            var p = new Te;
                            void 0 !== u.center && p.fromArray(u.center), e.boundingSphere = new De(p, u.radius)
                        }
                        return e
                    }
                });
            var Wa = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function Xa() {}
            Xa.Handlers = {
                handlers: [],
                add: function(t, e) {
                    this.handlers.push(t, e)
                },
                get: function(t) {
                    for (var e = this.handlers, n = 0, i = e.length; n < i; n += 2) {
                        var r = e[n],
                            o = e[n + 1];
                        if (r.test(t)) return o
                    }
                    return null
                }
            }, Object.assign(Xa.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function() {},
                onLoadProgress: function() {},
                onLoadComplete: function() {},
                initMaterials: function(t, e, n) {
                    for (var i = [], r = 0; r < t.length; ++r) i[r] = this.createMaterial(t[r], e, n);
                    return i
                },
                createMaterial: function() {
                    var t = {
                            NoBlending: f,
                            NormalBlending: m,
                            AdditiveBlending: v,
                            SubtractiveBlending: g,
                            MultiplyBlending: y,
                            CustomBlending: _
                        },
                        e = new Ue,
                        n = new qo,
                        i = new ja;
                    return function(r, o, a) {
                        var s = {};

                        function c(t, e, i, r, c) {
                            var l, h = o + t,
                                u = Xa.Handlers.get(h);
                            null !== u ? l = u.load(h) : (n.setCrossOrigin(a), l = n.load(h)), void 0 !== e && (l.repeat.fromArray(e), 1 !== e[0] && (l.wrapS = ot), 1 !== e[1] && (l.wrapT = ot)), void 0 !== i && l.offset.fromArray(i), void 0 !== r && ("repeat" === r[0] && (l.wrapS = ot), "mirror" === r[0] && (l.wrapS = st), "repeat" === r[1] && (l.wrapT = ot), "mirror" === r[1] && (l.wrapT = st)), void 0 !== c && (l.anisotropy = c);
                            var p = xe.generateUUID();
                            return s[p] = l, p
                        }
                        var u = {
                            uuid: xe.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                        for (var f in r) {
                            var m = r[f];
                            switch (f) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    u.name = m;
                                    break;
                                case "blending":
                                    u.blending = t[m];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", f, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    u.color = e.fromArray(m).getHex();
                                    break;
                                case "colorSpecular":
                                    u.specular = e.fromArray(m).getHex();
                                    break;
                                case "colorEmissive":
                                    u.emissive = e.fromArray(m).getHex();
                                    break;
                                case "specularCoef":
                                    u.shininess = m;
                                    break;
                                case "shading":
                                    "basic" === m.toLowerCase() && (u.type = "MeshBasicMaterial"), "phong" === m.toLowerCase() && (u.type = "MeshPhongMaterial"), "standard" === m.toLowerCase() && (u.type = "MeshStandardMaterial");
                                    break;
                                case "mapDiffuse":
                                    u.map = c(m, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    u.emissiveMap = c(m, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    u.lightMap = c(m, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    u.aoMap = c(m, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    u.bumpMap = c(m, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    u.bumpScale = m;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    u.normalMap = c(m, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    u.normalScale = m;
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    u.specularMap = c(m, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    u.metalnessMap = c(m, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    u.roughnessMap = c(m, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    u.alphaMap = c(m, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    u.side = l;
                                    break;
                                case "doubleSided":
                                    u.side = h;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), u.opacity = m;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    u[f] = m;
                                    break;
                                case "vertexColors":
                                    !0 === m && (u.vertexColors = d), "face" === m && (u.vertexColors = p);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", f, m)
                            }
                        }
                        return "MeshBasicMaterial" === u.type && delete u.emissive, "MeshPhongMaterial" !== u.type && delete u.specular, u.opacity < 1 && (u.transparent = !0), i.setTextures(s), i.parse(u)
                    }
                }()
            });
            var qa = {
                decodeText: function(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    for (var e = "", n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                    return decodeURIComponent(escape(e))
                },
                extractUrlBase: function(t) {
                    var e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            };

            function Ya(t) {
                "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : Uo, this.withCredentials = !1
            }

            function Za(t) {
                this.manager = void 0 !== t ? t : Uo, this.texturePath = ""
            }
            Object.assign(Ya.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    var r = this,
                        o = void 0 === this.path ? qa.extractUrlBase(t) : this.path,
                        a = new Go(this.manager);
                    a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(t, function(n) {
                        var i = JSON.parse(n),
                            a = i.metadata;
                        if (void 0 !== a) {
                            var s = a.type;
                            if (void 0 !== s && "object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.")
                        }
                        var c = r.parse(i, o);
                        e(c.geometry, c.materials)
                    }, n, i)
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                parse: function(t, e) {
                    void 0 !== t.data && (t = t.data), void 0 !== t.scale ? t.scale = 1 / t.scale : t.scale = 1;
                    var n = new Ke;
                    if (function(t, e) {
                            function n(t, e) {
                                return t & 1 << e
                            }
                            var i, r, o, a, s, c, l, h, u, p, d, f, m, v, g, y, _, x, b, w, M, T, E, S, A, P, L, R = t.faces,
                                C = t.vertices,
                                O = t.normals,
                                I = t.colors,
                                D = t.scale,
                                N = 0;
                            if (void 0 !== t.uvs) {
                                for (i = 0; i < t.uvs.length; i++) t.uvs[i].length && N++;
                                for (i = 0; i < N; i++) e.faceVertexUvs[i] = []
                            }
                            for (a = 0, s = C.length; a < s;)(x = new Te).x = C[a++] * D, x.y = C[a++] * D, x.z = C[a++] * D, e.vertices.push(x);
                            for (a = 0, s = R.length; a < s;)
                                if (p = R[a++], d = n(p, 0), f = n(p, 1), m = n(p, 3), v = n(p, 4), g = n(p, 5), y = n(p, 6), _ = n(p, 7), d) {
                                    if ((w = new We).a = R[a], w.b = R[a + 1], w.c = R[a + 3], (M = new We).a = R[a + 1], M.b = R[a + 2], M.c = R[a + 3], a += 4, f && (u = R[a++], w.materialIndex = u, M.materialIndex = u), o = e.faces.length, m)
                                        for (i = 0; i < N; i++)
                                            for (S = t.uvs[i], e.faceVertexUvs[i][o] = [], e.faceVertexUvs[i][o + 1] = [], r = 0; r < 4; r++) h = R[a++], P = S[2 * h], L = S[2 * h + 1], A = new be(P, L), 2 !== r && e.faceVertexUvs[i][o].push(A), 0 !== r && e.faceVertexUvs[i][o + 1].push(A);
                                    if (v && (l = 3 * R[a++], w.normal.set(O[l++], O[l++], O[l]), M.normal.copy(w.normal)), g)
                                        for (i = 0; i < 4; i++) l = 3 * R[a++], E = new Te(O[l++], O[l++], O[l]), 2 !== i && w.vertexNormals.push(E), 0 !== i && M.vertexNormals.push(E);
                                    if (y && (c = R[a++], T = I[c], w.color.setHex(T), M.color.setHex(T)), _)
                                        for (i = 0; i < 4; i++) c = R[a++], T = I[c], 2 !== i && w.vertexColors.push(new Ue(T)), 0 !== i && M.vertexColors.push(new Ue(T));
                                    e.faces.push(w), e.faces.push(M)
                                } else {
                                    if ((b = new We).a = R[a++], b.b = R[a++], b.c = R[a++], f && (u = R[a++], b.materialIndex = u), o = e.faces.length, m)
                                        for (i = 0; i < N; i++)
                                            for (S = t.uvs[i], e.faceVertexUvs[i][o] = [], r = 0; r < 3; r++) h = R[a++], P = S[2 * h], L = S[2 * h + 1], A = new be(P, L), e.faceVertexUvs[i][o].push(A);
                                    if (v && (l = 3 * R[a++], b.normal.set(O[l++], O[l++], O[l])), g)
                                        for (i = 0; i < 3; i++) l = 3 * R[a++], E = new Te(O[l++], O[l++], O[l]), b.vertexNormals.push(E);
                                    if (y && (c = R[a++], b.color.setHex(I[c])), _)
                                        for (i = 0; i < 3; i++) c = R[a++], b.vertexColors.push(new Ue(I[c]));
                                    e.faces.push(b)
                                }
                        }(t, n), function(t, e) {
                            var n = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                            if (t.skinWeights)
                                for (var i = 0, r = t.skinWeights.length; i < r; i += n) {
                                    var o = t.skinWeights[i],
                                        a = n > 1 ? t.skinWeights[i + 1] : 0,
                                        s = n > 2 ? t.skinWeights[i + 2] : 0,
                                        c = n > 3 ? t.skinWeights[i + 3] : 0;
                                    e.skinWeights.push(new Le(o, a, s, c))
                                }
                            if (t.skinIndices)
                                for (var i = 0, r = t.skinIndices.length; i < r; i += n) {
                                    var l = t.skinIndices[i],
                                        h = n > 1 ? t.skinIndices[i + 1] : 0,
                                        u = n > 2 ? t.skinIndices[i + 2] : 0,
                                        p = n > 3 ? t.skinIndices[i + 3] : 0;
                                    e.skinIndices.push(new Le(l, h, u, p))
                                }
                            e.bones = t.bones, e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
                        }(t, n), function(t, e) {
                            var n = t.scale;
                            if (void 0 !== t.morphTargets)
                                for (var i = 0, r = t.morphTargets.length; i < r; i++) {
                                    e.morphTargets[i] = {}, e.morphTargets[i].name = t.morphTargets[i].name, e.morphTargets[i].vertices = [];
                                    for (var o = e.morphTargets[i].vertices, a = t.morphTargets[i].vertices, s = 0, c = a.length; s < c; s += 3) {
                                        var l = new Te;
                                        l.x = a[s] * n, l.y = a[s + 1] * n, l.z = a[s + 2] * n, o.push(l)
                                    }
                                }
                            if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                                console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                                for (var h = e.faces, u = t.morphColors[0].colors, i = 0, r = h.length; i < r; i++) h[i].color.fromArray(u, 3 * i)
                            }
                        }(t, n), function(t, e) {
                            var n = [],
                                i = [];
                            void 0 !== t.animation && i.push(t.animation), void 0 !== t.animations && (t.animations.length ? i = i.concat(t.animations) : i.push(t.animations));
                            for (var r = 0; r < i.length; r++) {
                                var o = za.parseAnimation(i[r], e.bones);
                                o && n.push(o)
                            }
                            if (e.morphTargets) {
                                var a = za.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                                n = n.concat(a)
                            }
                            n.length > 0 && (e.animations = n)
                        }(t, n), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length) return {
                        geometry: n
                    };
                    var i = Xa.prototype.initMaterials(t.materials, this.resourcePath || e, this.crossOrigin);
                    return {
                        geometry: n,
                        materials: i
                    }
                }
            }), Object.assign(Za.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                    var r = this,
                        o = new Go(r.manager);
                    o.load(t, function(n) {
                        var o = null;
                        try {
                            o = JSON.parse(n)
                        } catch (e) {
                            return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                        }
                        var a = o.metadata;
                        void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.")
                    }, n, i)
                },
                setTexturePath: function(t) {
                    return this.texturePath = t, this
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                parse: function(t, e) {
                    var n = this.parseShape(t.shapes),
                        i = this.parseGeometries(t.geometries, n),
                        r = this.parseImages(t.images, function() {
                            void 0 !== e && e(s)
                        }),
                        o = this.parseTextures(t.textures, r),
                        a = this.parseMaterials(t.materials, o),
                        s = this.parseObject(t.object, i, a);
                    return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
                },
                parseShape: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var n = 0, i = t.length; n < i; n++) {
                            var r = (new va).fromJSON(t[n]);
                            e[r.uuid] = r
                        }
                    return e
                },
                parseGeometries: function(t, e) {
                    var n = {};
                    if (void 0 !== t)
                        for (var i = new Ya, r = new Va, o = 0, a = t.length; o < a; o++) {
                            var s, c = t[o];
                            switch (c.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new So[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new So[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new So[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new So[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new So[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new So[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new So[c.type](c.radius, c.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new So[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new So[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new So[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new So[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new So[c.type](c.vertices, c.indices, c.radius, c.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var l = [], h = 0, u = c.shapes.length; h < u; h++) {
                                        var p = e[c.shapes[h]];
                                        l.push(p)
                                    }
                                    s = new So[c.type](l, c.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (var l = [], h = 0, u = c.shapes.length; h < u; h++) {
                                        var p = e[c.shapes[h]];
                                        l.push(p)
                                    }
                                    var d = c.options.extrudePath;
                                    void 0 !== d && (c.options.extrudePath = (new da[d.type]).fromJSON(d)), s = new So[c.type](l, c.options);
                                    break;
                                case "BufferGeometry":
                                    s = r.parse(c);
                                    break;
                                case "Geometry":
                                    s = i.parse(c, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
                                    continue
                            }
                            s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), !0 === s.isBufferGeometry && void 0 !== c.userData && (s.userData = c.userData), n[c.uuid] = s
                        }
                    return n
                },
                parseMaterials: function(t, e) {
                    var n = {};
                    if (void 0 !== t) {
                        var i = new ja;
                        i.setTextures(e);
                        for (var r = 0, o = t.length; r < o; r++) {
                            var a = t[r];
                            if ("MultiMaterial" === a.type) {
                                for (var s = [], c = 0; c < a.materials.length; c++) s.push(i.parse(a.materials[c]));
                                n[a.uuid] = s
                            } else n[a.uuid] = i.parse(a)
                        }
                    }
                    return n
                },
                parseAnimations: function(t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                        var i = t[n],
                            r = za.parse(i);
                        void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    var n = this,
                        i = {};

                    function r(t) {
                        return n.manager.itemStart(t), a.load(t, function() {
                            n.manager.itemEnd(t)
                        }, void 0, function() {
                            n.manager.itemEnd(t), n.manager.itemError(t)
                        })
                    }
                    if (void 0 !== t && t.length > 0) {
                        var o = new ko(e),
                            a = new Wo(o);
                        a.setCrossOrigin(this.crossOrigin);
                        for (var s = 0, c = t.length; s < c; s++) {
                            var l = t[s],
                                h = l.url;
                            if (Array.isArray(h)) {
                                i[l.uuid] = [];
                                for (var u = 0, p = h.length; u < p; u++) {
                                    var d = h[u],
                                        f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.texturePath + d;
                                    i[l.uuid].push(r(f))
                                }
                            } else {
                                var f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.texturePath + l.url;
                                i[l.uuid] = r(f)
                            }
                        }
                    }
                    return i
                },
                parseTextures: function(t, e) {
                    function n(t, e) {
                        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                    }
                    var i = {};
                    if (void 0 !== t)
                        for (var r = 0, o = t.length; r < o; r++) {
                            var a, s = t[r];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(e[s.image]) ? new En(e[s.image]) : new Pe(e[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, Ka)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], Qa), a.wrapT = n(s.wrap[1], Qa)), void 0 !== s.format && (a.format = s.format), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, $a)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, $a)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), i[s.uuid] = a
                        }
                    return i
                },
                parseObject: function(t, e, n) {
                    var i;

                    function r(t) {
                        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                    }

                    function o(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], i = 0, r = t.length; i < r; i++) {
                                    var o = t[i];
                                    void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(n[o])
                                }
                                return e
                            }
                            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                        }
                    }
                    switch (t.type) {
                        case "Scene":
                            i = new Yi, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new Ue(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new qi(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new Xi(t.fog.color, t.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            i = new Gi(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            i = new Ma(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                            break;
                        case "AmbientLight":
                            i = new Sa(t.color, t.intensity);
                            break;
                        case "DirectionalLight":
                            i = new Ea(t.color, t.intensity);
                            break;
                        case "PointLight":
                            i = new wa(t.color, t.intensity, t.distance, t.decay);
                            break;
                        case "RectAreaLight":
                            i = new Aa(t.color, t.intensity, t.width, t.height);
                            break;
                        case "SpotLight":
                            i = new ba(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                            break;
                        case "HemisphereLight":
                            i = new ya(t.color, t.groundColor, t.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var a = r(t.geometry),
                                s = o(t.material);
                            i = a.bones && a.bones.length > 0 ? new nr(a, s) : new Mn(a, s);
                            break;
                        case "LOD":
                            i = new $i;
                            break;
                        case "Line":
                            i = new rr(r(t.geometry), o(t.material), t.mode);
                            break;
                        case "LineLoop":
                            i = new ar(r(t.geometry), o(t.material));
                            break;
                        case "LineSegments":
                            i = new or(r(t.geometry), o(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            i = new cr(r(t.geometry), o(t.material));
                            break;
                        case "Sprite":
                            i = new Qi(o(t.material));
                            break;
                        case "Group":
                            i = new Ui;
                            break;
                        default:
                            i = new Ze
                    }
                    if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children)
                        for (var c = t.children, l = 0; l < c.length; l++) i.add(this.parseObject(c[l], e, n));
                    if ("LOD" === t.type)
                        for (var h = t.levels, u = 0; u < h.length; u++) {
                            var p = h[u],
                                d = i.getObjectByProperty("uuid", p.object);
                            void 0 !== d && i.addLevel(d, p.distance)
                        }
                    return i
                }
            });
            var Ja, Ka = {
                    UVMapping: 300,
                    CubeReflectionMapping: Q,
                    CubeRefractionMapping: $,
                    EquirectangularReflectionMapping: tt,
                    EquirectangularRefractionMapping: et,
                    SphericalReflectionMapping: nt,
                    CubeUVReflectionMapping: it,
                    CubeUVRefractionMapping: rt
                },
                Qa = {
                    RepeatWrapping: ot,
                    ClampToEdgeWrapping: at,
                    MirroredRepeatWrapping: st
                },
                $a = {
                    NearestFilter: ct,
                    NearestMipMapNearestFilter: lt,
                    NearestMipMapLinearFilter: ht,
                    LinearFilter: ut,
                    LinearMipMapNearestFilter: pt,
                    LinearMipMapLinearFilter: dt
                };

            function ts(t) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : Uo, this.options = void 0
            }

            function es() {
                this.type = "ShapePath", this.color = new Ue, this.subPaths = [], this.currentPath = null
            }

            function ns(t) {
                this.type = "Font", this.data = t
            }

            function is(t, e, n, i, r) {
                var o = r.glyphs[t] || r.glyphs["?"];
                if (o) {
                    var a, s, c, l, h, u, p, d, f = new es;
                    if (o.o)
                        for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g;) {
                            var y = m[v++];
                            switch (y) {
                                case "m":
                                    a = m[v++] * e + n, s = m[v++] * e + i, f.moveTo(a, s);
                                    break;
                                case "l":
                                    a = m[v++] * e + n, s = m[v++] * e + i, f.lineTo(a, s);
                                    break;
                                case "q":
                                    c = m[v++] * e + n, l = m[v++] * e + i, h = m[v++] * e + n, u = m[v++] * e + i, f.quadraticCurveTo(h, u, c, l);
                                    break;
                                case "b":
                                    c = m[v++] * e + n, l = m[v++] * e + i, h = m[v++] * e + n, u = m[v++] * e + i, p = m[v++] * e + n, d = m[v++] * e + i, f.bezierCurveTo(h, u, p, d, c, l)
                            }
                        }
                    return {
                        offsetX: o.ha * e,
                        path: f
                    }
                }
            }

            function rs(t) {
                this.manager = void 0 !== t ? t : Uo
            }
            ts.prototype = {
                constructor: ts,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Fo.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    fetch(t).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return createImageBitmap(t, r.options)
                    }).then(function(n) {
                        Fo.add(t, n), e && e(n), r.manager.itemEnd(t)
                    }).catch(function(e) {
                        i && i(e), r.manager.itemEnd(t), r.manager.itemError(t)
                    })
                },
                setCrossOrigin: function() {
                    return this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }, Object.assign(es.prototype, {
                moveTo: function(t, e) {
                    this.currentPath = new ma, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
                },
                lineTo: function(t, e) {
                    this.currentPath.lineTo(t, e)
                },
                quadraticCurveTo: function(t, e, n, i) {
                    this.currentPath.quadraticCurveTo(t, e, n, i)
                },
                bezierCurveTo: function(t, e, n, i, r, o) {
                    this.currentPath.bezierCurveTo(t, e, n, i, r, o)
                },
                splineThru: function(t) {
                    this.currentPath.splineThru(t)
                },
                toShapes: function(t, e) {
                    function n(t) {
                        for (var e = [], n = 0, i = t.length; n < i; n++) {
                            var r = t[n],
                                o = new va;
                            o.curves = r.curves, e.push(o)
                        }
                        return e
                    }

                    function i(t, e) {
                        for (var n = e.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
                            var a = e[r],
                                s = e[o],
                                c = s.x - a.x,
                                l = s.y - a.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (a = e[o], c = -c, s = e[r], l = -l), t.y < a.y || t.y > s.y) continue;
                                if (t.y === a.y) {
                                    if (t.x === a.x) return !0
                                } else {
                                    var h = l * (t.x - a.x) - c * (t.y - a.y);
                                    if (0 === h) return !0;
                                    if (h < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (t.y !== a.y) continue;
                                if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                            }
                        }
                        return i
                    }
                    var r = to.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === e) return n(o);
                    var a, s, c, l = [];
                    if (1 === o.length) return s = o[0], (c = new va).curves = s.curves, l.push(c), l;
                    var h = !r(o[0].getPoints());
                    h = t ? !h : h;
                    var u, p, d = [],
                        f = [],
                        m = [],
                        v = 0;
                    f[v] = void 0, m[v] = [];
                    for (var g = 0, y = o.length; g < y; g++) s = o[g], u = s.getPoints(), a = r(u), (a = t ? !a : a) ? (!h && f[v] && v++, f[v] = {
                        s: new va,
                        p: u
                    }, f[v].s.curves = s.curves, h && v++, m[v] = []) : m[v].push({
                        h: s,
                        p: u[0]
                    });
                    if (!f[0]) return n(o);
                    if (f.length > 1) {
                        for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) d[b] = [];
                        for (var b = 0, w = f.length; b < w; b++)
                            for (var M = m[b], T = 0; T < M.length; T++) {
                                for (var E = M[T], S = !0, A = 0; A < f.length; A++) i(E.p, f[A].p) && (b !== A && x.push({
                                    froms: b,
                                    tos: A,
                                    hole: T
                                }), S ? (S = !1, d[A].push(E)) : _ = !0);
                                S && d[b].push(E)
                            }
                        x.length > 0 && (_ || (m = d))
                    }
                    for (var g = 0, P = f.length; g < P; g++) {
                        c = f[g].s, l.push(c);
                        for (var L = 0, R = (p = m[g]).length; L < R; L++) c.holes.push(p[L].h)
                    }
                    return l
                }
            }), Object.assign(ns.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    for (var n = [], i = function(t, e, n) {
                            for (var i = Array.from ? Array.from(t) : String(t).split(""), r = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, a = [], s = 0, c = 0, l = 0; l < i.length; l++) {
                                var h = i[l];
                                if ("\n" === h) s = 0, c -= o;
                                else {
                                    var u = is(h, r, s, c, n);
                                    s += u.offsetX, a.push(u.path)
                                }
                            }
                            return a
                        }(t, e, this.data), r = 0, o = i.length; r < o; r++) Array.prototype.push.apply(n, i[r].toShapes());
                    return n
                }
            }), Object.assign(rs.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        o = new Go(this.manager);
                    o.setPath(this.path), o.load(t, function(t) {
                        var n;
                        try {
                            n = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var i = r.parse(n);
                        e && e(i)
                    }, n, i)
                },
                parse: function(t) {
                    return new ns(t)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            });
            var os, as, ss = {
                getContext: function() {
                    return void 0 === Ja && (Ja = new(window.AudioContext || window.webkitAudioContext)), Ja
                },
                setContext: function(t) {
                    Ja = t
                }
            };

            function cs(t) {
                this.manager = void 0 !== t ? t : Uo
            }

            function ls() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Gi, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Gi, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }

            function hs(t, e, n) {
                Ze.call(this), this.type = "CubeCamera";
                var i = new Gi(90, 1, t, e);
                i.up.set(0, -1, 0), i.lookAt(new Te(1, 0, 0)), this.add(i);
                var r = new Gi(90, 1, t, e);
                r.up.set(0, -1, 0), r.lookAt(new Te(-1, 0, 0)), this.add(r);
                var o = new Gi(90, 1, t, e);
                o.up.set(0, 0, 1), o.lookAt(new Te(0, 1, 0)), this.add(o);
                var a = new Gi(90, 1, t, e);
                a.up.set(0, 0, -1), a.lookAt(new Te(0, -1, 0)), this.add(a);
                var s = new Gi(90, 1, t, e);
                s.up.set(0, -1, 0), s.lookAt(new Te(0, 0, 1)), this.add(s);
                var c = new Gi(90, 1, t, e);
                c.up.set(0, -1, 0), c.lookAt(new Te(0, 0, -1)), this.add(c);
                var l = {
                    format: At,
                    magFilter: ut,
                    minFilter: ut
                };
                this.renderTarget = new Ce(n, n, l), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = this.renderTarget,
                        l = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, n.activeCubeFace = 0, t.render(e, i, n), n.activeCubeFace = 1, t.render(e, r, n), n.activeCubeFace = 2, t.render(e, o, n), n.activeCubeFace = 3, t.render(e, a, n), n.activeCubeFace = 4, t.render(e, s, n), n.texture.generateMipmaps = l, n.activeCubeFace = 5, t.render(e, c, n), t.setRenderTarget(null)
                }, this.clear = function(t, e, n, i) {
                    for (var r = this.renderTarget, o = 0; o < 6; o++) r.activeCubeFace = o, t.setRenderTarget(r), t.clear(e, n, i);
                    t.setRenderTarget(null)
                }
            }

            function us() {
                Ze.call(this), this.type = "AudioListener", this.context = ss.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
            }

            function ps(t) {
                Ze.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function ds(t) {
                ps.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }

            function fs(t, e) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }

            function ms(t, e, n) {
                this.binding = t, this.valueSize = n;
                var i, r = Float64Array;
                switch (e) {
                    case "quaternion":
                        i = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array, i = this._select;
                        break;
                    default:
                        i = this._lerp
                }
                this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }

            function vs(t, e, n) {
                var i = n || gs.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }

            function gs(t, e, n) {
                this.path = e, this.parsedPath = n || gs.parseTrackName(e), this.node = gs.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }

            function ys() {
                this.uuid = xe.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var t = {};
                this._indicesByUUID = t;
                for (var e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var i = this;
                this.stats = {
                    objects: {
                        get total() {
                            return i._objects.length
                        },
                        get inUse() {
                            return this.total - i.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return i._bindings.length
                    }
                }
            }

            function _s(t, e, n) {
                this._mixer = t, this._clip = e, this._localRoot = n || null;
                for (var i = e.tracks, r = i.length, o = new Array(r), a = {
                        endingStart: oe,
                        endingEnd: oe
                    }, s = 0; s !== r; ++s) {
                    var c = i[s].createInterpolant(null);
                    o[s] = c, c.settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = re, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function xs(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function bs(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }

            function ws() {
                pn.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function Ms(t, e, n) {
                Zi.call(this, t, e), this.meshPerAttribute = n || 1
            }

            function Ts(t, e, n, i) {
                "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Qe.call(this, t, e, n), this.meshPerAttribute = i || 1
            }

            function Es(t, e, n, i) {
                this.ray = new xn(t, e), this.near = n || 0, this.far = i || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function Ss(t, e) {
                return t.distance - e.distance
            }

            function As(t, e, n, i) {
                if (!1 !== t.visible && (t.raycast(e, n), !0 === i))
                    for (var r = t.children, o = 0, a = r.length; o < a; o++) As(r[o], e, n, !0)
            }

            function Ps(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            function Ls(t, e, n) {
                return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
            }

            function Rs(t, e, n) {
                return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
            }

            function Cs(t, e) {
                this.min = void 0 !== t ? t : new be(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new be(-1 / 0, -1 / 0)
            }

            function Os(t, e) {
                this.start = void 0 !== t ? t : new Te, this.end = void 0 !== e ? e : new Te
            }

            function Is(t) {
                Ze.call(this), this.material = t, this.render = function() {}
            }

            function Ds(t, e, n, i) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== n ? n : 16711680,
                    o = void 0 !== i ? i : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
                var c = new pn,
                    l = new sn(2 * a * 3, 3);
                c.addAttribute("position", l), or.call(this, c, new ir({
                    color: r,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Ns(t, e) {
                Ze.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var n = new pn, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
                    var a = r / 32 * Math.PI * 2,
                        s = o / 32 * Math.PI * 2;
                    i.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                n.addAttribute("position", new sn(i, 3));
                var c = new ir({
                    fog: !1
                });
                this.cone = new or(n, c), this.add(this.cone), this.update()
            }

            function Bs(t) {
                for (var e = function t(e) {
                        var n = [];
                        e && e.isBone && n.push(e);
                        for (var i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                        return n
                    }(t), n = new pn, i = [], r = [], o = new Ue(0, 0, 1), a = new Ue(0, 1, 0), s = 0; s < e.length; s++) {
                    var c = e[s];
                    c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
                }
                n.addAttribute("position", new sn(i, 3)), n.addAttribute("color", new sn(r, 3));
                var l = new ir({
                    vertexColors: d,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                or.call(this, n, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }

            function Hs(t, e, n) {
                this.light = t, this.light.updateMatrixWorld(), this.color = n;
                var i = new ho(e, 4, 2),
                    r = new wn({
                        wireframe: !0,
                        fog: !1
                    });
                Mn.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function Fs(t, e) {
                Ze.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                var n = new ir({
                        fog: !1
                    }),
                    i = new pn;
                i.addAttribute("position", new Qe(new Float32Array(15), 3)), this.line = new rr(i, n), this.add(this.line), this.update()
            }

            function ks(t, e, n) {
                Ze.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var i = new br(e);
                i.rotateY(.5 * Math.PI), this.material = new wn({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = d);
                var r = i.getAttribute("position"),
                    o = new Float32Array(3 * r.count);
                i.addAttribute("color", new Qe(o, 3)), this.add(new Mn(i, this.material)), this.update()
            }

            function Us(t, e, n, i) {
                t = t || 10, e = e || 10, n = new Ue(void 0 !== n ? n : 4473924), i = new Ue(void 0 !== i ? i : 8947848);
                for (var r = e / 2, o = t / e, a = t / 2, s = [], c = [], l = 0, h = 0, u = -a; l <= e; l++, u += o) {
                    s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
                    var p = l === r ? n : i;
                    p.toArray(c, h), h += 3, p.toArray(c, h), h += 3, p.toArray(c, h), h += 3, p.toArray(c, h), h += 3
                }
                var f = new pn;
                f.addAttribute("position", new sn(s, 3)), f.addAttribute("color", new sn(c, 3));
                var m = new ir({
                    vertexColors: d
                });
                or.call(this, f, m)
            }

            function zs(t, e, n, i, r, o) {
                t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new Ue(void 0 !== r ? r : 4473924), o = new Ue(void 0 !== o ? o : 8947848);
                var a, s, c, l, h, u, p, f = [],
                    m = [];
                for (l = 0; l <= e; l++) c = l / e * (2 * Math.PI), a = Math.sin(c) * t, s = Math.cos(c) * t, f.push(0, 0, 0), f.push(a, 0, s), p = 1 & l ? r : o, m.push(p.r, p.g, p.b), m.push(p.r, p.g, p.b);
                for (l = 0; l <= n; l++)
                    for (p = 1 & l ? r : o, u = t - t / n * l, h = 0; h < i; h++) c = h / i * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, f.push(a, 0, s), m.push(p.r, p.g, p.b), c = (h + 1) / i * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, f.push(a, 0, s), m.push(p.r, p.g, p.b);
                var v = new pn;
                v.addAttribute("position", new sn(f, 3)), v.addAttribute("color", new sn(m, 3));
                var g = new ir({
                    vertexColors: d
                });
                or.call(this, v, g)
            }

            function Gs(t, e, n, i) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== n ? n : 16776960,
                    o = void 0 !== i ? i : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new pn,
                    l = new sn(2 * a * 3, 3);
                c.addAttribute("position", l), or.call(this, c, new ir({
                    color: r,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function js(t, e, n) {
                Ze.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                var i = new pn;
                i.addAttribute("position", new sn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                var r = new ir({
                    fog: !1
                });
                this.lightPlane = new rr(i, r), this.add(this.lightPlane), (i = new pn).addAttribute("position", new sn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new rr(i, r), this.add(this.targetLine), this.update()
            }

            function Vs(t) {
                var e = new pn,
                    n = new ir({
                        color: 16777215,
                        vertexColors: p
                    }),
                    i = [],
                    r = [],
                    o = {},
                    a = new Ue(16755200),
                    s = new Ue(16711680),
                    c = new Ue(43775),
                    l = new Ue(16777215),
                    h = new Ue(3355443);

                function u(t, e, n) {
                    d(t, n), d(e, n)
                }

                function d(t, e) {
                    i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(i.length / 3 - 1)
                }
                u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", l), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.addAttribute("position", new sn(i, 3)), e.addAttribute("color", new sn(r, 3)), or.call(this, e, n), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }

            function Ws(t, e) {
                this.object = t, void 0 === e && (e = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Float32Array(24),
                    r = new pn;
                r.setIndex(new Qe(n, 1)), r.addAttribute("position", new Qe(i, 3)), or.call(this, r, new ir({
                    color: e
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Xs(t, e) {
                this.type = "Box3Helper", this.box = t;
                var n = void 0 !== e ? e : 16776960,
                    i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new pn;
                r.setIndex(new Qe(i, 1)), r.addAttribute("position", new sn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), or.call(this, r, new ir({
                    color: n
                })), this.geometry.computeBoundingSphere()
            }

            function qs(t, e, n) {
                this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                var i = void 0 !== n ? n : 16776960,
                    r = new pn;
                r.addAttribute("position", new sn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), rr.call(this, r, new ir({
                    color: i
                }));
                var o = new pn;
                o.addAttribute("position", new sn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Mn(o, new wn({
                    color: i,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }

            function Ys(t, e, n, i, r, o) {
                Ze.call(this), void 0 === i && (i = 16776960), void 0 === n && (n = 1), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === os && ((os = new pn).addAttribute("position", new sn([0, 0, 0, 0, 1, 0], 3)), (as = new bo(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new rr(os, new ir({
                    color: i
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mn(as, new wn({
                    color: i
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o)
            }

            function Zs(t) {
                var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    n = new pn;
                n.addAttribute("position", new sn(e, 3)), n.addAttribute("color", new sn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var i = new ir({
                    vertexColors: d
                });
                or.call(this, n, i)
            }

            function Js(t) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), na.call(this, t), this.type = "catmullrom", this.closed = !0
            }

            function Ks(t) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), na.call(this, t), this.type = "catmullrom"
            }

            function Qs(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), na.call(this, t), this.type = "catmullrom"
            }
            Object.assign(cs.prototype, {
                    load: function(t, e, n, i) {
                        var r = new Go(this.manager);
                        r.setResponseType("arraybuffer"), r.load(t, function(t) {
                            var n = t.slice(0),
                                i = ss.getContext();
                            i.decodeAudioData(n, function(t) {
                                e(t)
                            })
                        }, n, i)
                    }
                }), Object.assign(ls.prototype, {
                    update: function() {
                        var t, e, n, i, r, o, a, s, c = new we,
                            l = new we;
                        return function(h) {
                            var u = t !== this || e !== h.focus || n !== h.fov || i !== h.aspect * this.aspect || r !== h.near || o !== h.far || a !== h.zoom || s !== this.eyeSep;
                            if (u) {
                                t = this, e = h.focus, n = h.fov, i = h.aspect * this.aspect, r = h.near, o = h.far, a = h.zoom;
                                var p, d, f = h.projectionMatrix.clone(),
                                    m = (s = this.eyeSep / 2) * r / e,
                                    v = r * Math.tan(xe.DEG2RAD * n * .5) / a;
                                l.elements[12] = -s, c.elements[12] = s, p = -v * i + m, d = v * i + m, f.elements[0] = 2 * r / (d - p), f.elements[8] = (d + p) / (d - p), this.cameraL.projectionMatrix.copy(f), p = -v * i - m, d = v * i - m, f.elements[0] = 2 * r / (d - p), f.elements[8] = (d + p) / (d - p), this.cameraR.projectionMatrix.copy(f)
                            }
                            this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(c)
                        }
                    }()
                }), hs.prototype = Object.create(Ze.prototype), hs.prototype.constructor = hs, us.prototype = Object.assign(Object.create(Ze.prototype), {
                    constructor: us,
                    getInput: function() {
                        return this.gain
                    },
                    removeFilter: function() {
                        return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                    },
                    getFilter: function() {
                        return this.filter
                    },
                    setFilter: function(t) {
                        return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                    },
                    getMasterVolume: function() {
                        return this.gain.gain.value
                    },
                    setMasterVolume: function(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                    },
                    updateMatrixWorld: function() {
                        var t = new Te,
                            e = new Me,
                            n = new Te,
                            i = new Te;
                        return function(r) {
                            Ze.prototype.updateMatrixWorld.call(this, r);
                            var o = this.context.listener,
                                a = this.up;
                            this.matrixWorld.decompose(t, e, n), i.set(0, 0, -1).applyQuaternion(e), o.positionX ? (o.positionX.setValueAtTime(t.x, this.context.currentTime), o.positionY.setValueAtTime(t.y, this.context.currentTime), o.positionZ.setValueAtTime(t.z, this.context.currentTime), o.forwardX.setValueAtTime(i.x, this.context.currentTime), o.forwardY.setValueAtTime(i.y, this.context.currentTime), o.forwardZ.setValueAtTime(i.z, this.context.currentTime), o.upX.setValueAtTime(a.x, this.context.currentTime), o.upY.setValueAtTime(a.y, this.context.currentTime), o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(t.x, t.y, t.z), o.setOrientation(i.x, i.y, i.z, a.x, a.y, a.z))
                        }
                    }()
                }), ps.prototype = Object.assign(Object.create(Ze.prototype), {
                    constructor: ps,
                    getOutput: function() {
                        return this.gain
                    },
                    setNodeSource: function(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                    },
                    setMediaElementSource: function(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                    },
                    setBuffer: function(t) {
                        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                    },
                    play: function() {
                        if (!0 !== this.isPlaying) {
                            if (!1 !== this.hasPlaybackControl) {
                                var t = this.context.createBufferSource();
                                return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                            }
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        } else console.warn("THREE.Audio: Audio is already playing.")
                    },
                    pause: function() {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    },
                    stop: function() {
                        if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    },
                    connect: function() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else this.source.connect(this.getOutput());
                        return this
                    },
                    disconnect: function() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else this.source.disconnect(this.getOutput());
                        return this
                    },
                    getFilters: function() {
                        return this.filters
                    },
                    setFilters: function(t) {
                        return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                    },
                    getFilter: function() {
                        return this.getFilters()[0]
                    },
                    setFilter: function(t) {
                        return this.setFilters(t ? [t] : [])
                    },
                    setPlaybackRate: function(t) {
                        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    },
                    getPlaybackRate: function() {
                        return this.playbackRate
                    },
                    onEnded: function() {
                        this.isPlaying = !1
                    },
                    getLoop: function() {
                        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                    },
                    setLoop: function(t) {
                        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    },
                    getVolume: function() {
                        return this.gain.gain.value
                    },
                    setVolume: function(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                    }
                }), ds.prototype = Object.assign(Object.create(ps.prototype), {
                    constructor: ds,
                    getOutput: function() {
                        return this.panner
                    },
                    getRefDistance: function() {
                        return this.panner.refDistance
                    },
                    setRefDistance: function(t) {
                        return this.panner.refDistance = t, this
                    },
                    getRolloffFactor: function() {
                        return this.panner.rolloffFactor
                    },
                    setRolloffFactor: function(t) {
                        return this.panner.rolloffFactor = t, this
                    },
                    getDistanceModel: function() {
                        return this.panner.distanceModel
                    },
                    setDistanceModel: function(t) {
                        return this.panner.distanceModel = t, this
                    },
                    getMaxDistance: function() {
                        return this.panner.maxDistance
                    },
                    setMaxDistance: function(t) {
                        return this.panner.maxDistance = t, this
                    },
                    setDirectionalCone: function(t, e, n) {
                        return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
                    },
                    updateMatrixWorld: function() {
                        var t = new Te,
                            e = new Me,
                            n = new Te,
                            i = new Te;
                        return function(r) {
                            Ze.prototype.updateMatrixWorld.call(this, r);
                            var o = this.panner;
                            this.matrixWorld.decompose(t, e, n), i.set(0, 0, 1).applyQuaternion(e), o.setPosition(t.x, t.y, t.z), o.setOrientation(i.x, i.y, i.z)
                        }
                    }()
                }), Object.assign(fs.prototype, {
                    getFrequencyData: function() {
                        return this.analyser.getByteFrequencyData(this.data), this.data
                    },
                    getAverageFrequency: function() {
                        for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n];
                        return t / e.length
                    }
                }), Object.assign(ms.prototype, {
                    accumulate: function(t, e) {
                        var n = this.buffer,
                            i = this.valueSize,
                            r = t * i + i,
                            o = this.cumulativeWeight;
                        if (0 === o) {
                            for (var a = 0; a !== i; ++a) n[r + a] = n[a];
                            o = e
                        } else {
                            var s = e / (o += e);
                            this._mixBufferRegion(n, r, 0, s, i)
                        }
                        this.cumulativeWeight = o
                    },
                    apply: function(t) {
                        var e = this.valueSize,
                            n = this.buffer,
                            i = t * e + e,
                            r = this.cumulativeWeight,
                            o = this.binding;
                        if (this.cumulativeWeight = 0, r < 1) {
                            var a = 3 * e;
                            this._mixBufferRegion(n, i, a, 1 - r, e)
                        }
                        for (var s = e, c = e + e; s !== c; ++s)
                            if (n[s] !== n[s + e]) {
                                o.setValue(n, i);
                                break
                            }
                    },
                    saveOriginalState: function() {
                        var t = this.binding,
                            e = this.buffer,
                            n = this.valueSize,
                            i = 3 * n;
                        t.getValue(e, i);
                        for (var r = n, o = i; r !== o; ++r) e[r] = e[i + r % n];
                        this.cumulativeWeight = 0
                    },
                    restoreOriginalState: function() {
                        var t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t)
                    },
                    _select: function(t, e, n, i, r) {
                        if (i >= .5)
                            for (var o = 0; o !== r; ++o) t[e + o] = t[n + o]
                    },
                    _slerp: function(t, e, n, i) {
                        Me.slerpFlat(t, e, t, e, t, n, i)
                    },
                    _lerp: function(t, e, n, i, r) {
                        for (var o = 1 - i, a = 0; a !== r; ++a) {
                            var s = e + a;
                            t[s] = t[s] * o + t[n + a] * i
                        }
                    }
                }), Object.assign(vs.prototype, {
                    getValue: function(t, e) {
                        this.bind();
                        var n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
                    },
                    bind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                    },
                    unbind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                    }
                }), Object.assign(gs, {
                    Composite: vs,
                    create: function(t, e, n) {
                        return t && t.isAnimationObjectGroup ? new gs.Composite(t, e, n) : new gs(t, e, n)
                    },
                    sanitizeNodeName: function() {
                        var t = new RegExp("[\\[\\]\\.:\\/]", "g");
                        return function(e) {
                            return e.replace(/\s/g, "_").replace(t, "")
                        }
                    }(),
                    parseTrackName: function() {
                        var t = "[^\\[\\]\\.:\\/]",
                            e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                            n = /((?:WC+[\/:])*)/.source.replace("WC", t),
                            i = /(WCOD+)?/.source.replace("WCOD", e),
                            r = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t),
                            o = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t),
                            a = new RegExp("^" + n + i + r + o + "$"),
                            s = ["material", "materials", "bones"];
                        return function(t) {
                            var e = a.exec(t);
                            if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                            var n = {
                                    nodeName: e[2],
                                    objectName: e[3],
                                    objectIndex: e[4],
                                    propertyName: e[5],
                                    propertyIndex: e[6]
                                },
                                i = n.nodeName && n.nodeName.lastIndexOf(".");
                            if (void 0 !== i && -1 !== i) {
                                var r = n.nodeName.substring(i + 1); - 1 !== s.indexOf(r) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
                            }
                            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                            return n
                        }
                    }(),
                    findNode: function(t, e) {
                        if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) {
                            var n = t.skeleton.getBoneByName(e);
                            if (void 0 !== n) return n
                        }
                        if (t.children) {
                            var i = function(t) {
                                    for (var n = 0; n < t.length; n++) {
                                        var r = t[n];
                                        if (r.name === e || r.uuid === e) return r;
                                        var o = i(r.children);
                                        if (o) return o
                                    }
                                    return null
                                },
                                r = i(t.children);
                            if (r) return r
                        }
                        return null
                    }
                }), Object.assign(gs.prototype, {
                    _getValue_unavailable: function() {},
                    _setValue_unavailable: function() {},
                    BindingType: {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    },
                    Versioning: {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    },
                    GetterByBindingType: [function(t, e) {
                        t[e] = this.node[this.propertyName]
                    }, function(t, e) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
                    }, function(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }, function(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }],
                    SetterByBindingTypeAndVersioning: [
                        [function(t, e) {
                            this.targetObject[this.propertyName] = t[e]
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                        }, function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                            this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e]
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty.fromArray(t, e)
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                        }]
                    ],
                    getValue: function(t, e) {
                        this.bind(), this.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        this.bind(), this.setValue(t, e)
                    },
                    bind: function() {
                        var t = this.node,
                            e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName,
                            r = e.propertyIndex;
                        if (t || (t = gs.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                            if (n) {
                                var o = e.objectIndex;
                                switch (n) {
                                    case "materials":
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        t = t.material.materials;
                                        break;
                                    case "bones":
                                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        t = t.skeleton.bones;
                                        for (var a = 0; a < t.length; a++)
                                            if (t[a].name === o) {
                                                o = a;
                                                break
                                            }
                                        break;
                                    default:
                                        if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        t = t[n]
                                }
                                if (void 0 !== o) {
                                    if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    t = t[o]
                                }
                            }
                            var s = t[i];
                            if (void 0 !== s) {
                                var c = this.Versioning.None;
                                this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                                var l = this.BindingType.Direct;
                                if (void 0 !== r) {
                                    if ("morphTargetInfluences" === i) {
                                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                        if (t.geometry.isBufferGeometry) {
                                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                            for (var a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                                if (t.geometry.morphAttributes.position[a].name === r) {
                                                    r = a;
                                                    break
                                                }
                                        } else {
                                            if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                            for (var a = 0; a < this.node.geometry.morphTargets.length; a++)
                                                if (t.geometry.morphTargets[a].name === r) {
                                                    r = a;
                                                    break
                                                }
                                        }
                                    }
                                    l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                                this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                            } else {
                                var h = e.nodeName;
                                console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + i + " but it wasn't found.", t)
                            }
                        } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                    },
                    unbind: function() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(gs.prototype, {
                    _getValue_unbound: gs.prototype.getValue,
                    _setValue_unbound: gs.prototype.setValue
                }), Object.assign(ys.prototype, {
                    isAnimationObjectGroup: !0,
                    add: function() {
                        for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, l = 0, h = arguments.length; l !== h; ++l) {
                            var u = arguments[l],
                                p = u.uuid,
                                d = i[p];
                            if (void 0 === d) {
                                d = e++, i[p] = d, t.push(u);
                                for (var f = 0, m = s; f !== m; ++f) a[f].push(new gs(u, r[f], o[f]))
                            } else if (d < n) {
                                c = t[d];
                                var v = --n,
                                    g = t[v];
                                i[g.uuid] = d, t[d] = g, i[p] = v, t[v] = u;
                                for (var f = 0, m = s; f !== m; ++f) {
                                    var y = a[f],
                                        _ = y[v],
                                        x = y[d];
                                    y[d] = _, void 0 === x && (x = new gs(u, r[f], o[f])), y[v] = x
                                }
                            } else t[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = n
                    },
                    remove: function() {
                        for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, o = 0, a = arguments.length; o !== a; ++o) {
                            var s = arguments[o],
                                c = s.uuid,
                                l = n[c];
                            if (void 0 !== l && l >= e) {
                                var h = e++,
                                    u = t[h];
                                n[u.uuid] = l, t[l] = u, n[c] = h, t[h] = s;
                                for (var p = 0, d = r; p !== d; ++p) {
                                    var f = i[p],
                                        m = f[h],
                                        v = f[l];
                                    f[l] = m, f[h] = v
                                }
                            }
                        }
                        this.nCachedObjects_ = e
                    },
                    uncache: function() {
                        for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                            var c = arguments[a],
                                l = c.uuid,
                                h = i[l];
                            if (void 0 !== h)
                                if (delete i[l], h < n) {
                                    var u = --n,
                                        p = t[u],
                                        d = --e,
                                        f = t[d];
                                    i[p.uuid] = h, t[h] = p, i[f.uuid] = u, t[u] = f, t.pop();
                                    for (var m = 0, v = o; m !== v; ++m) {
                                        var g = r[m],
                                            y = g[u],
                                            _ = g[d];
                                        g[h] = y, g[u] = _, g.pop()
                                    }
                                } else {
                                    var d = --e,
                                        f = t[d];
                                    i[f.uuid] = h, t[h] = f, t.pop();
                                    for (var m = 0, v = o; m !== v; ++m) {
                                        var g = r[m];
                                        g[h] = g[d], g.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = n
                    },
                    subscribe_: function(t, e) {
                        var n = this._bindingsIndicesByPath,
                            i = n[t],
                            r = this._bindings;
                        if (void 0 !== i) return r[i];
                        var o = this._paths,
                            a = this._parsedPaths,
                            s = this._objects,
                            c = s.length,
                            l = this.nCachedObjects_,
                            h = new Array(c);
                        i = r.length, n[t] = i, o.push(t), a.push(e), r.push(h);
                        for (var u = l, p = s.length; u !== p; ++u) {
                            var d = s[u];
                            h[u] = new gs(d, t, e)
                        }
                        return h
                    },
                    unsubscribe_: function(t) {
                        var e = this._bindingsIndicesByPath,
                            n = e[t];
                        if (void 0 !== n) {
                            var i = this._paths,
                                r = this._parsedPaths,
                                o = this._bindings,
                                a = o.length - 1,
                                s = o[a],
                                c = t[a];
                            e[c] = n, o[n] = s, o.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop()
                        }
                    }
                }), Object.assign(_s.prototype, {
                    play: function() {
                        return this._mixer._activateAction(this), this
                    },
                    stop: function() {
                        return this._mixer._deactivateAction(this), this.reset()
                    },
                    reset: function() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    },
                    isRunning: function() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    },
                    isScheduled: function() {
                        return this._mixer._isActiveAction(this)
                    },
                    startAt: function(t) {
                        return this._startTime = t, this
                    },
                    setLoop: function(t, e) {
                        return this.loop = t, this.repetitions = e, this
                    },
                    setEffectiveWeight: function(t) {
                        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                    },
                    getEffectiveWeight: function() {
                        return this._effectiveWeight
                    },
                    fadeIn: function(t) {
                        return this._scheduleFading(t, 0, 1)
                    },
                    fadeOut: function(t) {
                        return this._scheduleFading(t, 1, 0)
                    },
                    crossFadeFrom: function(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            var i = this._clip.duration,
                                r = t._clip.duration,
                                o = r / i,
                                a = i / r;
                            t.warp(1, o, e), this.warp(a, 1, e)
                        }
                        return this
                    },
                    crossFadeTo: function(t, e, n) {
                        return t.crossFadeFrom(this, e, n)
                    },
                    stopFading: function() {
                        var t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    setEffectiveTimeScale: function(t) {
                        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                    },
                    getEffectiveTimeScale: function() {
                        return this._effectiveTimeScale
                    },
                    setDuration: function(t) {
                        return this.timeScale = this._clip.duration / t, this.stopWarping()
                    },
                    syncWith: function(t) {
                        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                    },
                    halt: function(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    },
                    warp: function(t, e, n) {
                        var i = this._mixer,
                            r = i.time,
                            o = this._timeScaleInterpolant,
                            a = this.timeScale;
                        null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        var s = o.parameterPositions,
                            c = o.sampleValues;
                        return s[0] = r, s[1] = r + n, c[0] = t / a, c[1] = e / a, this
                    },
                    stopWarping: function() {
                        var t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    getMixer: function() {
                        return this._mixer
                    },
                    getClip: function() {
                        return this._clip
                    },
                    getRoot: function() {
                        return this._localRoot || this._mixer._root
                    },
                    _update: function(t, e, n, i) {
                        if (this.enabled) {
                            var r = this._startTime;
                            if (null !== r) {
                                var o = (t - r) * n;
                                if (o < 0 || 0 === n) return;
                                this._startTime = null, e = n * o
                            }
                            e *= this._updateTimeScale(t);
                            var a = this._updateTime(e),
                                s = this._updateWeight(t);
                            if (s > 0)
                                for (var c = this._interpolants, l = this._propertyBindings, h = 0, u = c.length; h !== u; ++h) c[h].evaluate(a), l[h].accumulate(i, s)
                        } else this._updateWeight(t)
                    },
                    _updateWeight: function(t) {
                        var e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            var n = this._weightInterpolant;
                            if (null !== n) {
                                var i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    },
                    _updateTimeScale: function(t) {
                        var e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            var n = this._timeScaleInterpolant;
                            if (null !== n) {
                                var i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                            }
                        }
                        return this._effectiveTimeScale = e, e
                    },
                    _updateTime: function(t) {
                        var e = this.time + t,
                            n = this._clip.duration,
                            i = this.loop,
                            r = this._loopCount,
                            o = 2202 === i;
                        if (0 === t) return -1 === r ? e : o && 1 == (1 & r) ? n - e : e;
                        if (2200 === i) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (e >= n) e = n;
                                else {
                                    if (!(e < 0)) break t;
                                    e = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= n || e < 0) {
                                var a = Math.floor(e / n);
                                e -= n * a, r += Math.abs(a);
                                var s = this.repetitions - r;
                                if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === s) {
                                        var c = t < 0;
                                        this._setEndings(c, !c, o)
                                    } else this._setEndings(!1, !1, o);
                                    this._loopCount = r, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: a
                                    })
                                }
                            }
                            if (o && 1 == (1 & r)) return this.time = e, n - e
                        }
                        return this.time = e, e
                    },
                    _setEndings: function(t, e, n) {
                        var i = this._interpolantSettings;
                        n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : oe : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : oe : 2402)
                    },
                    _scheduleFading: function(t, e, n) {
                        var i = this._mixer,
                            r = i.time,
                            o = this._weightInterpolant;
                        null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
                        var a = o.parameterPositions,
                            s = o.sampleValues;
                        return a[0] = r, s[0] = e, a[1] = r + t, s[1] = n, this
                    }
                }), xs.prototype = Object.assign(Object.create(e.prototype), {
                    constructor: xs,
                    _bindAction: function(t, e) {
                        var n = t._localRoot || this._root,
                            i = t._clip.tracks,
                            r = i.length,
                            o = t._propertyBindings,
                            a = t._interpolants,
                            s = n.uuid,
                            c = this._bindingsByRootAndName,
                            l = c[s];
                        void 0 === l && (l = {}, c[s] = l);
                        for (var h = 0; h !== r; ++h) {
                            var u = i[h],
                                p = u.name,
                                d = l[p];
                            if (void 0 !== d) o[h] = d;
                            else {
                                if (void 0 !== (d = o[h])) {
                                    null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p));
                                    continue
                                }
                                var f = e && e._propertyBindings[h].binding.parsedPath;
                                ++(d = new ms(gs.create(n, p, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), o[h] = d
                            }
                            a[h].resultBuffer = d.buffer
                        }
                    },
                    _activateAction: function(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                var e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    i = this._actionsByClip[n];
                                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            for (var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                                var s = r[o];
                                0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    },
                    _deactivateAction: function(t) {
                        if (this._isActiveAction(t)) {
                            for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                                var r = e[n];
                                0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                            }
                            this._takeBackAction(t)
                        }
                    },
                    _initMemoryManager: function() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        var t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    },
                    _isActiveAction: function(t) {
                        var e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    },
                    _addInactiveAction: function(t, e, n) {
                        var i = this._actions,
                            r = this._actionsByClip,
                            o = r[e];
                        if (void 0 === o) o = {
                            knownActions: [t],
                            actionByRoot: {}
                        }, t._byClipCacheIndex = 0, r[e] = o;
                        else {
                            var a = o.knownActions;
                            t._byClipCacheIndex = a.length, a.push(t)
                        }
                        t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t
                    },
                    _removeInactiveAction: function(t) {
                        var e = this._actions,
                            n = e[e.length - 1],
                            i = t._cacheIndex;
                        n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                        var r = t._clip.uuid,
                            o = this._actionsByClip,
                            a = o[r],
                            s = a.knownActions,
                            c = s[s.length - 1],
                            l = t._byClipCacheIndex;
                        c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null;
                        var h = a.actionByRoot,
                            u = (t._localRoot || this._root).uuid;
                        delete h[u], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(t)
                    },
                    _removeInactiveBindingsForAction: function(t) {
                        for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                            var r = e[n];
                            0 == --r.referenceCount && this._removeInactiveBinding(r)
                        }
                    },
                    _lendAction: function(t) {
                        var e = this._actions,
                            n = t._cacheIndex,
                            i = this._nActiveActions++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _takeBackAction: function(t) {
                        var e = this._actions,
                            n = t._cacheIndex,
                            i = --this._nActiveActions,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _addInactiveBinding: function(t, e, n) {
                        var i = this._bindingsByRootAndName,
                            r = i[e],
                            o = this._bindings;
                        void 0 === r && (r = {}, i[e] = r), r[n] = t, t._cacheIndex = o.length, o.push(t)
                    },
                    _removeInactiveBinding: function(t) {
                        var e = this._bindings,
                            n = t.binding,
                            i = n.rootNode.uuid,
                            r = n.path,
                            o = this._bindingsByRootAndName,
                            a = o[i],
                            s = e[e.length - 1],
                            c = t._cacheIndex;
                        s._cacheIndex = c, e[c] = s, e.pop(), delete a[r];
                        t: {
                            for (var l in a) break t;delete o[i]
                        }
                    },
                    _lendBinding: function(t) {
                        var e = this._bindings,
                            n = t._cacheIndex,
                            i = this._nActiveBindings++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _takeBackBinding: function(t) {
                        var e = this._bindings,
                            n = t._cacheIndex,
                            i = --this._nActiveBindings,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _lendControlInterpolant: function() {
                        var t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++,
                            n = t[e];
                        return void 0 === n && ((n = new Ca(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n
                    },
                    _takeBackControlInterpolant: function(t) {
                        var e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            i = --this._nActiveControlInterpolants,
                            r = e[i];
                        t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(1),
                    clipAction: function(t, e) {
                        var n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? za.findByName(n, t) : t,
                            o = null !== r ? r.uuid : t,
                            a = this._actionsByClip[o],
                            s = null;
                        if (void 0 !== a) {
                            var c = a.actionByRoot[i];
                            if (void 0 !== c) return c;
                            s = a.knownActions[0], null === r && (r = s._clip)
                        }
                        if (null === r) return null;
                        var l = new _s(this, r, e);
                        return this._bindAction(l, s), this._addInactiveAction(l, o, i), l
                    },
                    existingAction: function(t, e) {
                        var n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? za.findByName(n, t) : t,
                            o = r ? r.uuid : t,
                            a = this._actionsByClip[o];
                        return void 0 !== a && a.actionByRoot[i] || null
                    },
                    stopAllAction: function() {
                        var t = this._actions,
                            e = this._nActiveActions,
                            n = this._bindings,
                            i = this._nActiveBindings;
                        this._nActiveActions = 0, this._nActiveBindings = 0;
                        for (var r = 0; r !== e; ++r) t[r].reset();
                        for (var r = 0; r !== i; ++r) n[r].useCount = 0;
                        return this
                    },
                    update: function(t) {
                        t *= this.timeScale;
                        for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                            var s = e[a];
                            s._update(i, t, r, o)
                        }
                        for (var c = this._bindings, l = this._nActiveBindings, a = 0; a !== l; ++a) c[a].apply(o);
                        return this
                    },
                    getRoot: function() {
                        return this._root
                    },
                    uncacheClip: function(t) {
                        var e = this._actions,
                            n = t.uuid,
                            i = this._actionsByClip,
                            r = i[n];
                        if (void 0 !== r) {
                            for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                                var c = o[a];
                                this._deactivateAction(c);
                                var l = c._cacheIndex,
                                    h = e[e.length - 1];
                                c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = l, e[l] = h, e.pop(), this._removeInactiveBindingsForAction(c)
                            }
                            delete i[n]
                        }
                    },
                    uncacheRoot: function(t) {
                        var e = t.uuid,
                            n = this._actionsByClip;
                        for (var i in n) {
                            var r = n[i].actionByRoot,
                                o = r[e];
                            void 0 !== o && (this._deactivateAction(o), this._removeInactiveAction(o))
                        }
                        var a = this._bindingsByRootAndName,
                            s = a[e];
                        if (void 0 !== s)
                            for (var c in s) {
                                var l = s[c];
                                l.restoreOriginalState(), this._removeInactiveBinding(l)
                            }
                    },
                    uncacheAction: function(t, e) {
                        var n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }), bs.prototype.clone = function() {
                    return new bs(void 0 === this.value.clone ? this.value : this.value.clone())
                }, ws.prototype = Object.assign(Object.create(pn.prototype), {
                    constructor: ws,
                    isInstancedBufferGeometry: !0,
                    copy: function(t) {
                        return pn.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    }
                }), Ms.prototype = Object.assign(Object.create(Zi.prototype), {
                    constructor: Ms,
                    isInstancedInterleavedBuffer: !0,
                    copy: function(t) {
                        return Zi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), Ts.prototype = Object.assign(Object.create(Qe.prototype), {
                    constructor: Ts,
                    isInstancedBufferAttribute: !0,
                    copy: function(t) {
                        return Qe.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), Object.assign(Es.prototype, {
                    linePrecision: 1,
                    set: function(t, e) {
                        this.ray.set(t, e)
                    },
                    setFromCamera: function(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function(t, e, n) {
                        var i = n || [];
                        return As(t, this, i, e), i.sort(Ss), i
                    },
                    intersectObjects: function(t, e, n) {
                        var i = n || [];
                        if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                        for (var r = 0, o = t.length; r < o; r++) As(t[r], this, i, e);
                        return i.sort(Ss), i
                    }
                }), Object.assign(Ps.prototype, {
                    start: function() {
                        this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                    },
                    stop: function() {
                        this.getElapsedTime(), this.running = !1, this.autoStart = !1
                    },
                    getElapsedTime: function() {
                        return this.getDelta(), this.elapsedTime
                    },
                    getDelta: function() {
                        var t = 0;
                        if (this.autoStart && !this.running) return this.start(), 0;
                        if (this.running) {
                            var e = ("undefined" == typeof performance ? Date : performance).now();
                            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                        }
                        return t
                    }
                }), Object.assign(Ls.prototype, {
                    set: function(t, e, n) {
                        return this.radius = t, this.phi = e, this.theta = n, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                    },
                    makeSafe: function() {
                        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, n) {
                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(xe.clamp(e / this.radius, -1, 1))), this
                    }
                }), Object.assign(Rs.prototype, {
                    set: function(t, e, n) {
                        return this.radius = t, this.theta = e, this.y = n, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, n) {
                        return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
                    }
                }), Object.assign(Cs.prototype, {
                    set: function(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    },
                    setFromPoints: function(t) {
                        this.makeEmpty();
                        for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                        return this
                    },
                    setFromCenterAndSize: function() {
                        var t = new be;
                        return function(e, n) {
                            var i = t.copy(n).multiplyScalar(.5);
                            return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                        }
                    }(),
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    },
                    makeEmpty: function() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    },
                    isEmpty: function() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    },
                    getCenter: function(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new be), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    },
                    getSize: function(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new be), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    },
                    expandByPoint: function(t) {
                        return this.min.min(t), this.max.max(t), this
                    },
                    expandByVector: function(t) {
                        return this.min.sub(t), this.max.add(t), this
                    },
                    expandByScalar: function(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    },
                    containsPoint: function(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    },
                    containsBox: function(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    },
                    getParameter: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new be), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    },
                    intersectsBox: function(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    },
                    clampPoint: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new be), e.copy(t).clamp(this.min, this.max)
                    },
                    distanceToPoint: function() {
                        var t = new be;
                        return function(e) {
                            var n = t.copy(e).clamp(this.min, this.max);
                            return n.sub(e).length()
                        }
                    }(),
                    intersect: function(t) {
                        return this.min.max(t.min), this.max.min(t.max), this
                    },
                    union: function(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    },
                    translate: function(t) {
                        return this.min.add(t), this.max.add(t), this
                    },
                    equals: function(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }), Object.assign(Os.prototype, {
                    set: function(t, e) {
                        return this.start.copy(t), this.end.copy(e), this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.start.copy(t.start), this.end.copy(t.end), this
                    },
                    getCenter: function(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new Te), t.addVectors(this.start, this.end).multiplyScalar(.5)
                    },
                    delta: function(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new Te), t.subVectors(this.end, this.start)
                    },
                    distanceSq: function() {
                        return this.start.distanceToSquared(this.end)
                    },
                    distance: function() {
                        return this.start.distanceTo(this.end)
                    },
                    at: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new Te), this.delta(e).multiplyScalar(t).add(this.start)
                    },
                    closestPointToPointParameter: function() {
                        var t = new Te,
                            e = new Te;
                        return function(n, i) {
                            t.subVectors(n, this.start), e.subVectors(this.end, this.start);
                            var r = e.dot(e),
                                o = e.dot(t),
                                a = o / r;
                            return i && (a = xe.clamp(a, 0, 1)), a
                        }
                    }(),
                    closestPointToPoint: function(t, e, n) {
                        var i = this.closestPointToPointParameter(t, e);
                        return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Te), this.delta(n).multiplyScalar(i).add(this.start)
                    },
                    applyMatrix4: function(t) {
                        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                    },
                    equals: function(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                }), Is.prototype = Object.create(Ze.prototype), Is.prototype.constructor = Is, Is.prototype.isImmediateRenderObject = !0, Ds.prototype = Object.create(or.prototype), Ds.prototype.constructor = Ds, Ds.prototype.update = function() {
                    var t = new Te,
                        e = new Te,
                        n = new Ee;
                    return function() {
                        var i = ["a", "b", "c"];
                        this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                        var r = this.object.matrixWorld,
                            o = this.geometry.attributes.position,
                            a = this.object.geometry;
                        if (a && a.isGeometry)
                            for (var s = a.vertices, c = a.faces, l = 0, h = 0, u = c.length; h < u; h++)
                                for (var p = c[h], d = 0, f = p.vertexNormals.length; d < f; d++) {
                                    var m = s[p[i[d]]],
                                        v = p.vertexNormals[d];
                                    t.copy(m).applyMatrix4(r), e.copy(v).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(l, t.x, t.y, t.z), l += 1, o.setXYZ(l, e.x, e.y, e.z), l += 1
                                } else if (a && a.isBufferGeometry)
                                    for (var g = a.attributes.position, y = a.attributes.normal, l = 0, d = 0, f = g.count; d < f; d++) t.set(g.getX(d), g.getY(d), g.getZ(d)).applyMatrix4(r), e.set(y.getX(d), y.getY(d), y.getZ(d)), e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(l, t.x, t.y, t.z), l += 1, o.setXYZ(l, e.x, e.y, e.z), l += 1;
                        o.needsUpdate = !0
                    }
                }(), Ns.prototype = Object.create(Ze.prototype), Ns.prototype.constructor = Ns, Ns.prototype.dispose = function() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }, Ns.prototype.update = function() {
                    var t = new Te,
                        e = new Te;
                    return function() {
                        this.light.updateMatrixWorld();
                        var n = this.light.distance ? this.light.distance : 1e3,
                            i = n * Math.tan(this.light.angle);
                        this.cone.scale.set(i, i, n), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }(), Bs.prototype = Object.create(or.prototype), Bs.prototype.constructor = Bs, Bs.prototype.updateMatrixWorld = function() {
                    var t = new Te,
                        e = new we,
                        n = new we;
                    return function(i) {
                        var r = this.bones,
                            o = this.geometry,
                            a = o.getAttribute("position");
                        n.getInverse(this.root.matrixWorld);
                        for (var s = 0, c = 0; s < r.length; s++) {
                            var l = r[s];
                            l.parent && l.parent.isBone && (e.multiplyMatrices(n, l.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(n, l.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c + 1, t.x, t.y, t.z), c += 2)
                        }
                        o.getAttribute("position").needsUpdate = !0, Ze.prototype.updateMatrixWorld.call(this, i)
                    }
                }(), Hs.prototype = Object.create(Mn.prototype), Hs.prototype.constructor = Hs, Hs.prototype.dispose = function() {
                    this.geometry.dispose(), this.material.dispose()
                }, Hs.prototype.update = function() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }, Fs.prototype = Object.create(Ze.prototype), Fs.prototype.constructor = Fs, Fs.prototype.dispose = function() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, Fs.prototype.update = function() {
                    var t = .5 * this.light.width,
                        e = .5 * this.light.height,
                        n = this.line.geometry.attributes.position,
                        i = n.array;
                    i[0] = t, i[1] = -e, i[2] = 0, i[3] = t, i[4] = e, i[5] = 0, i[6] = -t, i[7] = e, i[8] = 0, i[9] = -t, i[10] = -e, i[11] = 0, i[12] = t, i[13] = -e, i[14] = 0, n.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
                }, ks.prototype = Object.create(Ze.prototype), ks.prototype.constructor = ks, ks.prototype.dispose = function() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, ks.prototype.update = function() {
                    var t = new Te,
                        e = new Ue,
                        n = new Ue;
                    return function() {
                        var i = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            var r = i.geometry.getAttribute("color");
                            e.copy(this.light.color), n.copy(this.light.groundColor);
                            for (var o = 0, a = r.count; o < a; o++) {
                                var s = o < a / 2 ? e : n;
                                r.setXYZ(o, s.r, s.g, s.b)
                            }
                            r.needsUpdate = !0
                        }
                        i.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }(), Us.prototype = Object.create(or.prototype), Us.prototype.constructor = Us, zs.prototype = Object.create(or.prototype), zs.prototype.constructor = zs, Gs.prototype = Object.create(or.prototype), Gs.prototype.constructor = Gs, Gs.prototype.update = function() {
                    var t = new Te,
                        e = new Te,
                        n = new Ee;
                    return function() {
                        this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                        for (var i = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, l = 0, h = s.length; l < h; l++) {
                            var u = s[l],
                                p = u.normal;
                            t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(i), e.copy(p).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), r.setXYZ(c, t.x, t.y, t.z), c += 1, r.setXYZ(c, e.x, e.y, e.z), c += 1
                        }
                        r.needsUpdate = !0
                    }
                }(), js.prototype = Object.create(Ze.prototype), js.prototype.constructor = js, js.prototype.dispose = function() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }, js.prototype.update = function() {
                    var t = new Te,
                        e = new Te,
                        n = new Te;
                    return function() {
                        t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(e, t), this.lightPlane.lookAt(n), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(n), this.targetLine.scale.z = n.length()
                    }
                }(), Vs.prototype = Object.create(or.prototype), Vs.prototype.constructor = Vs, Vs.prototype.update = function() {
                    var t, e, n = new Te,
                        i = new zi;

                    function r(r, o, a, s) {
                        n.set(o, a, s).unproject(i);
                        var c = e[r];
                        if (void 0 !== c)
                            for (var l = t.getAttribute("position"), h = 0, u = c.length; h < u; h++) l.setXYZ(c[h], n.x, n.y, n.z)
                    }
                    return function() {
                        t = this.geometry, e = this.pointMap, i.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                }(), Ws.prototype = Object.create(or.prototype), Ws.prototype.constructor = Ws, Ws.prototype.update = function() {
                    var t = new Ie;
                    return function(e) {
                        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                            var n = t.min,
                                i = t.max,
                                r = this.geometry.attributes.position,
                                o = r.array;
                            o[0] = i.x, o[1] = i.y, o[2] = i.z, o[3] = n.x, o[4] = i.y, o[5] = i.z, o[6] = n.x, o[7] = n.y, o[8] = i.z, o[9] = i.x, o[10] = n.y, o[11] = i.z, o[12] = i.x, o[13] = i.y, o[14] = n.z, o[15] = n.x, o[16] = i.y, o[17] = n.z, o[18] = n.x, o[19] = n.y, o[20] = n.z, o[21] = i.x, o[22] = n.y, o[23] = n.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                        }
                    }
                }(), Ws.prototype.setFromObject = function(t) {
                    return this.object = t, this.update(), this
                }, Xs.prototype = Object.create(or.prototype), Xs.prototype.constructor = Xs, Xs.prototype.updateMatrixWorld = function(t) {
                    var e = this.box;
                    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Ze.prototype.updateMatrixWorld.call(this, t))
                }, qs.prototype = Object.create(rr.prototype), qs.prototype.constructor = qs, qs.prototype.updateMatrixWorld = function(t) {
                    var e = -this.plane.constant;
                    Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? l : c, this.lookAt(this.plane.normal), Ze.prototype.updateMatrixWorld.call(this, t)
                }, Ys.prototype = Object.create(Ze.prototype), Ys.prototype.constructor = Ys, Ys.prototype.setDirection = function() {
                    var t, e = new Te;
                    return function(n) {
                        n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
                    }
                }(), Ys.prototype.setLength = function(t, e, n) {
                    void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
                }, Ys.prototype.setColor = function(t) {
                    this.line.material.color.copy(t), this.cone.material.color.copy(t)
                }, Zs.prototype = Object.create(or.prototype), Zs.prototype.constructor = Zs, Yo.create = function(t, e) {
                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Yo.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
                }, Object.assign(fa.prototype, {
                    createPointsGeometry: function(t) {
                        console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                        var e = this.getPoints(t);
                        return this.createGeometry(e)
                    },
                    createSpacedPointsGeometry: function(t) {
                        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                        var e = this.getSpacedPoints(t);
                        return this.createGeometry(e)
                    },
                    createGeometry: function(t) {
                        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                        for (var e = new Ke, n = 0, i = t.length; n < i; n++) {
                            var r = t[n];
                            e.vertices.push(new Te(r.x, r.y, r.z || 0))
                        }
                        return e
                    }
                }), Object.assign(ma.prototype, {
                    fromPoints: function(t) {
                        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                    }
                }), Js.prototype = Object.create(na.prototype), Ks.prototype = Object.create(na.prototype), Qs.prototype = Object.create(na.prototype), Object.assign(Qs.prototype, {
                    initFromArray: function() {
                        console.error("THREE.Spline: .initFromArray() has been removed.")
                    },
                    getControlPointsArray: function() {
                        console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                    },
                    reparametrizeByArcLength: function() {
                        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                    }
                }), Us.prototype.setColors = function() {
                    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
                }, Bs.prototype.update = function() {
                    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
                }, Object.assign(Xa.prototype, {
                    extractUrlBase: function(t) {
                        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), qa.extractUrlBase(t)
                    }
                }), Object.assign(Ya.prototype, {
                    setTexturePath: function(t) {
                        return console.warn("THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                    }
                }), Object.assign(Cs.prototype, {
                    center: function(t) {
                        return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                    },
                    empty: function() {
                        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                    },
                    isIntersectionBox: function(t) {
                        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                    },
                    size: function(t) {
                        return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                    }
                }), Object.assign(Ie.prototype, {
                    center: function(t) {
                        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                    },
                    empty: function() {
                        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                    },
                    isIntersectionBox: function(t) {
                        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                    },
                    isIntersectionSphere: function(t) {
                        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                    },
                    size: function(t) {
                        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                    }
                }), Os.prototype.center = function(t) {
                    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                }, Object.assign(xe, {
                    random16: function() {
                        return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                    },
                    nearestPowerOfTwo: function(t) {
                        return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), xe.floorPowerOfTwo(t)
                    },
                    nextPowerOfTwo: function(t) {
                        return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), xe.ceilPowerOfTwo(t)
                    }
                }), Object.assign(Ee.prototype, {
                    flattenToArrayOffset: function(t, e) {
                        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                    },
                    multiplyVector3: function(t) {
                        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                    },
                    multiplyVector3Array: function() {
                        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                    },
                    applyToBuffer: function(t) {
                        return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                    },
                    applyToVector3Array: function() {
                        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                    }
                }), Object.assign(we.prototype, {
                    extractPosition: function(t) {
                        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                    },
                    flattenToArrayOffset: function(t, e) {
                        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                    },
                    getPosition: function() {
                        var t;
                        return function() {
                            return void 0 === t && (t = new Te), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                        }
                    }(),
                    setRotationFromQuaternion: function(t) {
                        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                    },
                    multiplyToArray: function() {
                        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                    },
                    multiplyVector3: function(t) {
                        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                    },
                    multiplyVector4: function(t) {
                        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                    },
                    multiplyVector3Array: function() {
                        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                    },
                    rotateAxis: function(t) {
                        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                    },
                    crossVector: function(t) {
                        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                    },
                    translate: function() {
                        console.error("THREE.Matrix4: .translate() has been removed.")
                    },
                    rotateX: function() {
                        console.error("THREE.Matrix4: .rotateX() has been removed.")
                    },
                    rotateY: function() {
                        console.error("THREE.Matrix4: .rotateY() has been removed.")
                    },
                    rotateZ: function() {
                        console.error("THREE.Matrix4: .rotateZ() has been removed.")
                    },
                    rotateByAxis: function() {
                        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                    },
                    applyToBuffer: function(t) {
                        return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                    },
                    applyToVector3Array: function() {
                        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                    },
                    makeFrustum: function(t, e, n, i, r, o) {
                        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o)
                    }
                }), Ne.prototype.isIntersectionLine = function(t) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
                }, Me.prototype.multiplyVector3 = function(t) {
                    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
                }, Object.assign(xn.prototype, {
                    isIntersectionBox: function(t) {
                        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                    },
                    isIntersectionPlane: function(t) {
                        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                    },
                    isIntersectionSphere: function(t) {
                        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                    }
                }), Object.assign(bn.prototype, {
                    area: function() {
                        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                    },
                    barycoordFromPoint: function(t, e) {
                        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                    },
                    midpoint: function(t) {
                        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                    },
                    normal: function(t) {
                        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                    },
                    plane: function(t) {
                        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                    }
                }), Object.assign(bn, {
                    barycoordFromPoint: function(t, e, n, i, r) {
                        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), bn.getBarycoord(t, e, n, i, r)
                    },
                    normal: function(t, e, n, i) {
                        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), bn.getNormal(t, e, n, i)
                    }
                }), Object.assign(va.prototype, {
                    extractAllPoints: function(t) {
                        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                    },
                    extrude: function(t) {
                        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new io(this, t)
                    },
                    makeGeometry: function(t) {
                        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new vo(this, t)
                    }
                }), Object.assign(be.prototype, {
                    fromAttribute: function(t, e, n) {
                        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                    },
                    distanceToManhattan: function(t) {
                        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                    },
                    lengthManhattan: function() {
                        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                    }
                }), Object.assign(Te.prototype, {
                    setEulerFromRotationMatrix: function() {
                        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                    },
                    setEulerFromQuaternion: function() {
                        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                    },
                    getPositionFromMatrix: function(t) {
                        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                    },
                    getScaleFromMatrix: function(t) {
                        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                    },
                    getColumnFromMatrix: function(t, e) {
                        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                    },
                    applyProjection: function(t) {
                        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                    },
                    fromAttribute: function(t, e, n) {
                        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                    },
                    distanceToManhattan: function(t) {
                        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                    },
                    lengthManhattan: function() {
                        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                    }
                }), Object.assign(Le.prototype, {
                    fromAttribute: function(t, e, n) {
                        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                    },
                    lengthManhattan: function() {
                        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                    }
                }), Object.assign(Ke.prototype, {
                    computeTangents: function() {
                        console.error("THREE.Geometry: .computeTangents() has been removed.")
                    },
                    computeLineDistances: function() {
                        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                    }
                }), Object.assign(Ze.prototype, {
                    getChildByName: function(t) {
                        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                    },
                    renderDepth: function() {
                        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                    },
                    translate: function(t, e) {
                        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                    },
                    getWorldRotation: function() {
                        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                    }
                }), Object.defineProperties(Ze.prototype, {
                    eulerOrder: {
                        get: function() {
                            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                        },
                        set: function(t) {
                            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                        }
                    },
                    useQuaternion: {
                        get: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        },
                        set: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        }
                    }
                }), Object.defineProperties($i.prototype, {
                    objects: {
                        get: function() {
                            return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                        }
                    }
                }), Object.defineProperty(tr.prototype, "useVertexTexture", {
                    get: function() {
                        console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                    }
                }), Object.defineProperty(Yo.prototype, "__arcLengthDivisions", {
                    get: function() {
                        return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                    },
                    set: function(t) {
                        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                    }
                }), Gi.prototype.setLens = function(t, e) {
                    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
                }, Object.defineProperties(ga.prototype, {
                    onlyShadow: {
                        set: function() {
                            console.warn("THREE.Light: .onlyShadow has been removed.")
                        }
                    },
                    shadowCameraFov: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                        }
                    },
                    shadowCameraLeft: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                        }
                    },
                    shadowCameraRight: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                        }
                    },
                    shadowCameraTop: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                        }
                    },
                    shadowCameraBottom: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                        }
                    },
                    shadowCameraNear: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                        }
                    },
                    shadowCameraFar: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                        }
                    },
                    shadowCameraVisible: {
                        set: function() {
                            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                        }
                    },
                    shadowBias: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                        }
                    },
                    shadowDarkness: {
                        set: function() {
                            console.warn("THREE.Light: .shadowDarkness has been removed.")
                        }
                    },
                    shadowMapWidth: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                        }
                    },
                    shadowMapHeight: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                        }
                    }
                }), Object.defineProperties(Qe.prototype, {
                    length: {
                        get: function() {
                            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                        }
                    },
                    copyIndicesArray: function() {
                        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                    }
                }), Object.assign(pn.prototype, {
                    addIndex: function(t) {
                        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                    },
                    addDrawCall: function(t, e, n) {
                        void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                    },
                    clearDrawCalls: function() {
                        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                    },
                    computeTangents: function() {
                        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                    },
                    computeOffsets: function() {
                        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                    }
                }), Object.defineProperties(pn.prototype, {
                    drawcalls: {
                        get: function() {
                            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                        }
                    },
                    offsets: {
                        get: function() {
                            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                        }
                    }
                }), Object.assign(ro.prototype, {
                    getArrays: function() {
                        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                    },
                    addShapeList: function() {
                        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                    },
                    addShape: function() {
                        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                    }
                }), Object.defineProperties(bs.prototype, {
                    dynamic: {
                        set: function() {
                            console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                        }
                    },
                    onUpdate: {
                        value: function() {
                            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                        }
                    }
                }), Object.defineProperties(yn.prototype, {
                    wrapAround: {
                        get: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        }
                    },
                    wrapRGB: {
                        get: function() {
                            return console.warn("THREE.Material: .wrapRGB has been removed."), new Ue
                        }
                    },
                    shading: {
                        get: function() {
                            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                        },
                        set: function(t) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                        }
                    }
                }), Object.defineProperties(Co.prototype, {
                    metal: {
                        get: function() {
                            return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                        },
                        set: function() {
                            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                        }
                    }
                }), Object.defineProperties(_n.prototype, {
                    derivatives: {
                        get: function() {
                            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                        },
                        set: function(t) {
                            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                        }
                    }
                }), Object.assign(Wi.prototype, {
                    clearTarget: function(t, e, n, i) {
                        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
                    },
                    animate: function(t) {
                        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                    },
                    getCurrentRenderTarget: function() {
                        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                    },
                    getMaxAnisotropy: function() {
                        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                    },
                    getPrecision: function() {
                        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                    },
                    resetGLState: function() {
                        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                    },
                    supportsFloatTextures: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                    },
                    supportsHalfFloatTextures: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                    },
                    supportsStandardDerivatives: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                    },
                    supportsCompressedTextureS3TC: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                    },
                    supportsCompressedTexturePVRTC: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                    },
                    supportsBlendMinMax: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                    },
                    supportsVertexTextures: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                    },
                    supportsInstancedArrays: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                    },
                    enableScissorTest: function(t) {
                        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                    },
                    initMaterial: function() {
                        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                    },
                    addPrePlugin: function() {
                        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                    },
                    addPostPlugin: function() {
                        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                    },
                    updateShadowMap: function() {
                        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                    },
                    setFaceCulling: function() {
                        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                    }
                }), Object.defineProperties(Wi.prototype, {
                    shadowMapEnabled: {
                        get: function() {
                            return this.shadowMap.enabled
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                        }
                    },
                    shadowMapType: {
                        get: function() {
                            return this.shadowMap.type
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                        }
                    },
                    shadowMapCullFace: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        }
                    }
                }), Object.defineProperties(Hi.prototype, {
                    cullFace: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderReverseSided: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderSingleSided: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        }
                    }
                }), Object.defineProperties(Re.prototype, {
                    wrapS: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                        }
                    },
                    wrapT: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                        }
                    },
                    magFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                        }
                    },
                    minFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                        }
                    },
                    anisotropy: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                        }
                    },
                    offset: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                        }
                    },
                    repeat: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                        }
                    },
                    format: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                        }
                    },
                    type: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                        }
                    },
                    generateMipmaps: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                        }
                    }
                }), Object.defineProperties(Vi.prototype, {
                    standing: {
                        set: function() {
                            console.warn("THREE.WebVRManager: .standing has been removed.")
                        }
                    },
                    userHeight: {
                        set: function() {
                            console.warn("THREE.WebVRManager: .userHeight has been removed.")
                        }
                    }
                }), ps.prototype.load = function(t) {
                    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                    var e = this,
                        n = new cs;
                    return n.load(t, function(t) {
                        e.setBuffer(t)
                    }), this
                }, fs.prototype.getData = function() {
                    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
                }, hs.prototype.updateCubeMap = function(t, e) {
                    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
                };
            var $s = {
                merge: function(t, e, n) {
                    var i;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, n)
                },
                center: function(t) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
                }
            };
            Se.crossOrigin = void 0, Se.loadTexture = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new qo;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, n, void 0, i);
                return e && (o.mapping = e), o
            }, Se.loadTextureCube = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new Xo;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, n, void 0, i);
                return e && (o.mapping = e), o
            }, Se.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Se.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            var tc = {
                createMultiMaterialObject: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };
            t.WebGLRenderTargetCube = Ce, t.WebGLRenderTarget = Re, t.WebGLRenderer = Wi, t.ShaderLib = Ge, t.UniformsLib = ze, t.UniformsUtils = Fe, t.ShaderChunk = He, t.FogExp2 = Xi, t.Fog = qi, t.Scene = Yi, t.Sprite = Qi, t.LOD = $i, t.SkinnedMesh = nr, t.Skeleton = tr, t.Bone = er, t.Mesh = Mn, t.LineSegments = or, t.LineLoop = ar, t.Line = rr, t.Points = cr, t.Group = Ui, t.VideoTexture = lr, t.DataTexture = Oe, t.DataTexture3D = Sn, t.CompressedTexture = hr, t.CubeTexture = En, t.CanvasTexture = ur, t.DepthTexture = pr, t.Texture = Pe, t.CompressedTextureLoader = jo, t.DataTextureLoader = Vo, t.CubeTextureLoader = Xo, t.TextureLoader = qo, t.ObjectLoader = Za, t.MaterialLoader = ja, t.BufferGeometryLoader = Va, t.DefaultLoadingManager = Uo, t.LoadingManager = ko, t.JSONLoader = Ya, t.ImageLoader = Wo, t.ImageBitmapLoader = ts, t.FontLoader = rs, t.FileLoader = Go, t.Loader = Xa, t.LoaderUtils = qa, t.Cache = Fo, t.AudioLoader = cs, t.SpotLightShadow = xa, t.SpotLight = ba, t.PointLight = wa, t.RectAreaLight = Aa, t.HemisphereLight = ya, t.DirectionalLightShadow = Ta, t.DirectionalLight = Ea, t.AmbientLight = Sa, t.LightShadow = _a, t.Light = ga, t.StereoCamera = ls, t.PerspectiveCamera = Gi, t.OrthographicCamera = Ma, t.CubeCamera = hs, t.ArrayCamera = ji, t.Camera = zi, t.AudioListener = us, t.PositionalAudio = ds, t.AudioContext = ss, t.AudioAnalyser = fs, t.Audio = ps, t.VectorKeyframeTrack = Ua, t.StringKeyframeTrack = ka, t.QuaternionKeyframeTrack = Fa, t.NumberKeyframeTrack = Ba, t.ColorKeyframeTrack = Na, t.BooleanKeyframeTrack = Da, t.PropertyMixer = ms, t.PropertyBinding = gs, t.KeyframeTrack = Ia, t.AnimationUtils = Pa, t.AnimationObjectGroup = ys, t.AnimationMixer = xs, t.AnimationClip = za, t.Uniform = bs, t.InstancedBufferGeometry = ws, t.BufferGeometry = pn, t.Geometry = Ke, t.InterleavedBufferAttribute = Ji, t.InstancedInterleavedBuffer = Ms, t.InterleavedBuffer = Zi, t.InstancedBufferAttribute = Ts, t.Face3 = We, t.Object3D = Ze, t.Raycaster = Es, t.Layers = qe, t.EventDispatcher = e, t.Clock = Ps, t.QuaternionLinearInterpolant = Ha, t.LinearInterpolant = Ca, t.DiscreteInterpolant = Oa, t.CubicInterpolant = Ra, t.Interpolant = La, t.Triangle = bn, t.Math = xe, t.Spherical = Ls, t.Cylindrical = Rs, t.Plane = Ne, t.Frustum = Be, t.Sphere = De, t.Ray = xn, t.Matrix4 = we, t.Matrix3 = Ee, t.Box3 = Ie, t.Box2 = Cs, t.Line3 = Os, t.Euler = Xe, t.Vector4 = Le, t.Vector3 = Te, t.Vector2 = be, t.Quaternion = Me, t.Color = Ue, t.ImmediateRenderObject = Is, t.VertexNormalsHelper = Ds, t.SpotLightHelper = Ns, t.SkeletonHelper = Bs, t.PointLightHelper = Hs, t.RectAreaLightHelper = Fs, t.HemisphereLightHelper = ks, t.GridHelper = Us, t.PolarGridHelper = zs, t.FaceNormalsHelper = Gs, t.DirectionalLightHelper = js, t.CameraHelper = Vs, t.BoxHelper = Ws, t.Box3Helper = Xs, t.PlaneHelper = qs, t.ArrowHelper = Ys, t.AxesHelper = Zs, t.Shape = va, t.Path = ma, t.ShapePath = es, t.Font = ns, t.CurvePath = fa, t.Curve = Yo, t.ImageUtils = Se, t.ShapeUtils = to, t.WebGLUtils = ki, t.WireframeGeometry = dr, t.ParametricGeometry = fr, t.ParametricBufferGeometry = mr, t.TetrahedronGeometry = yr, t.TetrahedronBufferGeometry = _r, t.OctahedronGeometry = xr, t.OctahedronBufferGeometry = br, t.IcosahedronGeometry = wr, t.IcosahedronBufferGeometry = Mr, t.DodecahedronGeometry = Tr, t.DodecahedronBufferGeometry = Er, t.PolyhedronGeometry = vr, t.PolyhedronBufferGeometry = gr, t.TubeGeometry = Sr, t.TubeBufferGeometry = Ar, t.TorusKnotGeometry = Pr, t.TorusKnotBufferGeometry = Lr, t.TorusGeometry = Rr, t.TorusBufferGeometry = Cr, t.TextGeometry = so, t.TextBufferGeometry = co, t.SphereGeometry = lo, t.SphereBufferGeometry = ho, t.RingGeometry = uo, t.RingBufferGeometry = po, t.PlaneGeometry = mn, t.PlaneBufferGeometry = vn, t.LatheGeometry = fo, t.LatheBufferGeometry = mo, t.ShapeGeometry = vo, t.ShapeBufferGeometry = go, t.ExtrudeGeometry = io, t.ExtrudeBufferGeometry = ro, t.EdgesGeometry = _o, t.ConeGeometry = wo, t.ConeBufferGeometry = Mo, t.CylinderGeometry = xo, t.CylinderBufferGeometry = bo, t.CircleGeometry = To, t.CircleBufferGeometry = Eo, t.BoxGeometry = dn, t.BoxBufferGeometry = fn, t.ShadowMaterial = Ao, t.SpriteMaterial = Ki, t.RawShaderMaterial = Po, t.ShaderMaterial = _n, t.PointsMaterial = sr, t.MeshPhysicalMaterial = Ro, t.MeshStandardMaterial = Lo, t.MeshPhongMaterial = Co, t.MeshToonMaterial = Oo, t.MeshNormalMaterial = Io, t.MeshLambertMaterial = Do, t.MeshDepthMaterial = Ni, t.MeshDistanceMaterial = Bi, t.MeshBasicMaterial = wn, t.MeshMatcapMaterial = No, t.LineDashedMaterial = Bo, t.LineBasicMaterial = ir, t.Material = yn, t.Float64BufferAttribute = cn, t.Float32BufferAttribute = sn, t.Uint32BufferAttribute = an, t.Int32BufferAttribute = on, t.Uint16BufferAttribute = rn, t.Int16BufferAttribute = nn, t.Uint8ClampedBufferAttribute = en, t.Uint8BufferAttribute = tn, t.Int8BufferAttribute = $e, t.BufferAttribute = Qe, t.ArcCurve = Jo, t.CatmullRomCurve3 = na, t.CubicBezierCurve = aa, t.CubicBezierCurve3 = sa, t.EllipseCurve = Zo, t.LineCurve = ca, t.LineCurve3 = la, t.QuadraticBezierCurve = ha, t.QuadraticBezierCurve3 = ua, t.SplineCurve = pa, t.REVISION = n, t.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            }, t.CullFaceNone = i, t.CullFaceBack = r, t.CullFaceFront = o, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = a, t.PCFSoftShadowMap = s, t.FrontSide = c, t.BackSide = l, t.DoubleSide = h, t.FlatShading = 1, t.SmoothShading = 2, t.NoColors = u, t.FaceColors = p, t.VertexColors = d, t.NoBlending = f, t.NormalBlending = m, t.AdditiveBlending = v, t.SubtractiveBlending = g, t.MultiplyBlending = y, t.CustomBlending = _, t.AddEquation = x, t.SubtractEquation = b, t.ReverseSubtractEquation = w, t.MinEquation = M, t.MaxEquation = T, t.ZeroFactor = E, t.OneFactor = S, t.SrcColorFactor = A, t.OneMinusSrcColorFactor = P, t.SrcAlphaFactor = L, t.OneMinusSrcAlphaFactor = R, t.DstAlphaFactor = C, t.OneMinusDstAlphaFactor = O, t.DstColorFactor = I, t.OneMinusDstColorFactor = D, t.SrcAlphaSaturateFactor = N, t.NeverDepth = B, t.AlwaysDepth = H, t.LessDepth = F, t.LessEqualDepth = k, t.EqualDepth = U, t.GreaterEqualDepth = z, t.GreaterDepth = G, t.NotEqualDepth = j, t.MultiplyOperation = V, t.MixOperation = W, t.AddOperation = X, t.NoToneMapping = q, t.LinearToneMapping = Y, t.ReinhardToneMapping = Z, t.Uncharted2ToneMapping = J, t.CineonToneMapping = K, t.UVMapping = 300, t.CubeReflectionMapping = Q, t.CubeRefractionMapping = $, t.EquirectangularReflectionMapping = tt, t.EquirectangularRefractionMapping = et, t.SphericalReflectionMapping = nt, t.CubeUVReflectionMapping = it, t.CubeUVRefractionMapping = rt, t.RepeatWrapping = ot, t.ClampToEdgeWrapping = at, t.MirroredRepeatWrapping = st, t.NearestFilter = ct, t.NearestMipMapNearestFilter = lt, t.NearestMipMapLinearFilter = ht, t.LinearFilter = ut, t.LinearMipMapNearestFilter = pt, t.LinearMipMapLinearFilter = dt, t.UnsignedByteType = ft, t.ByteType = mt, t.ShortType = vt, t.UnsignedShortType = gt, t.IntType = yt, t.UnsignedIntType = _t, t.FloatType = xt, t.HalfFloatType = bt, t.UnsignedShort4444Type = wt, t.UnsignedShort5551Type = Mt, t.UnsignedShort565Type = Tt, t.UnsignedInt248Type = Et, t.AlphaFormat = St, t.RGBFormat = At, t.RGBAFormat = Pt, t.LuminanceFormat = Lt, t.LuminanceAlphaFormat = Rt, t.RGBEFormat = Ct, t.DepthFormat = Ot, t.DepthStencilFormat = It, t.RedFormat = Dt, t.RGB_S3TC_DXT1_Format = Nt, t.RGBA_S3TC_DXT1_Format = Bt, t.RGBA_S3TC_DXT3_Format = Ht, t.RGBA_S3TC_DXT5_Format = Ft, t.RGB_PVRTC_4BPPV1_Format = kt, t.RGB_PVRTC_2BPPV1_Format = Ut, t.RGBA_PVRTC_4BPPV1_Format = zt, t.RGBA_PVRTC_2BPPV1_Format = Gt, t.RGB_ETC1_Format = jt, t.RGBA_ASTC_4x4_Format = Vt, t.RGBA_ASTC_5x4_Format = Wt, t.RGBA_ASTC_5x5_Format = Xt, t.RGBA_ASTC_6x5_Format = qt, t.RGBA_ASTC_6x6_Format = Yt, t.RGBA_ASTC_8x5_Format = Zt, t.RGBA_ASTC_8x6_Format = Jt, t.RGBA_ASTC_8x8_Format = Kt, t.RGBA_ASTC_10x5_Format = Qt, t.RGBA_ASTC_10x6_Format = $t, t.RGBA_ASTC_10x8_Format = te, t.RGBA_ASTC_10x10_Format = ee, t.RGBA_ASTC_12x10_Format = ne, t.RGBA_ASTC_12x12_Format = ie, t.LoopOnce = 2200, t.LoopRepeat = re, t.LoopPingPong = 2202, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = oe, t.ZeroSlopeEnding = 2401, t.WrapAroundEnding = 2402, t.TrianglesDrawMode = ae, t.TriangleStripDrawMode = se, t.TriangleFanDrawMode = ce, t.LinearEncoding = le, t.sRGBEncoding = he, t.GammaEncoding = ue, t.RGBEEncoding = pe, t.LogLuvEncoding = 3003, t.RGBM7Encoding = de, t.RGBM16Encoding = fe, t.RGBDEncoding = me, t.BasicDepthPacking = ve, t.RGBADepthPacking = ge, t.TangentSpaceNormalMap = ye, t.ObjectSpaceNormalMap = _e, t.CubeGeometry = dn, t.Face4 = function(t, e, n, i, r, o, a) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new We(t, e, n, r, o, a)
            }, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = function(t) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
            }, t.MultiMaterial = function(t) {
                return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                    return t.slice()
                }, t
            }, t.PointCloud = function(t, e) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new cr(t, e)
            }, t.Particle = function(t) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Qi(t)
            }, t.ParticleSystem = function(t, e) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new cr(t, e)
            }, t.PointCloudMaterial = function(t) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new sr(t)
            }, t.ParticleBasicMaterial = function(t) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new sr(t)
            }, t.ParticleSystemMaterial = function(t) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new sr(t)
            }, t.Vertex = function(t, e, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Te(t, e, n)
            }, t.DynamicBufferAttribute = function(t, e) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new Qe(t, e).setDynamic(!0)
            }, t.Int8Attribute = function(t, e) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new $e(t, e)
            }, t.Uint8Attribute = function(t, e) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new tn(t, e)
            }, t.Uint8ClampedAttribute = function(t, e) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new en(t, e)
            }, t.Int16Attribute = function(t, e) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new nn(t, e)
            }, t.Uint16Attribute = function(t, e) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new rn(t, e)
            }, t.Int32Attribute = function(t, e) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new on(t, e)
            }, t.Uint32Attribute = function(t, e) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new an(t, e)
            }, t.Float32Attribute = function(t, e) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new sn(t, e)
            }, t.Float64Attribute = function(t, e) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new cn(t, e)
            }, t.ClosedSplineCurve3 = Js, t.SplineCurve3 = Ks, t.Spline = Qs, t.AxisHelper = function(t) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Zs(t)
            }, t.BoundingBoxHelper = function(t, e) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Ws(t, e)
            }, t.EdgesHelper = function(t, e) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new or(new _o(t.geometry), new ir({
                    color: void 0 !== e ? e : 16777215
                }))
            }, t.WireframeHelper = function(t, e) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new or(new dr(t.geometry), new ir({
                    color: void 0 !== e ? e : 16777215
                }))
            }, t.XHRLoader = function(t) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Go(t)
            }, t.BinaryTextureLoader = function(t) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Vo(t)
            }, t.GeometryUtils = $s, t.Projector = function() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
                }, this.unprojectVector = function(t, e) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
                }, this.pickingRay = function() {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }, t.CanvasRenderer = function() {
                console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
            }, t.SceneUtils = tc, t.LensFlare = function() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }, Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }(e)
    }, function(t, e) {
        ! function(t, e) {
            "use strict";
            if ("IntersectionObserver" in t && "IntersectionObserverEntry" in t && "intersectionRatio" in t.IntersectionObserverEntry.prototype) "isIntersecting" in t.IntersectionObserverEntry.prototype || Object.defineProperty(t.IntersectionObserverEntry.prototype, "isIntersecting", {
                get: function() {
                    return this.intersectionRatio > 0
                }
            });
            else {
                var n = [];
                r.prototype.THROTTLE_TIMEOUT = 100, r.prototype.POLL_INTERVAL = null, r.prototype.USE_MUTATION_OBSERVER = !0, r.prototype.observe = function(t) {
                    if (!this._observationTargets.some(function(e) {
                            return e.element == t
                        })) {
                        if (!t || 1 != t.nodeType) throw new Error("target must be an Element");
                        this._registerInstance(), this._observationTargets.push({
                            element: t,
                            entry: null
                        }), this._monitorIntersections(), this._checkForIntersections()
                    }
                }, r.prototype.unobserve = function(t) {
                    this._observationTargets = this._observationTargets.filter(function(e) {
                        return e.element != t
                    }), this._observationTargets.length || (this._unmonitorIntersections(), this._unregisterInstance())
                }, r.prototype.disconnect = function() {
                    this._observationTargets = [], this._unmonitorIntersections(), this._unregisterInstance()
                }, r.prototype.takeRecords = function() {
                    var t = this._queuedEntries.slice();
                    return this._queuedEntries = [], t
                }, r.prototype._initThresholds = function(t) {
                    var e = t || [0];
                    return Array.isArray(e) || (e = [e]), e.sort().filter(function(t, e, n) {
                        if ("number" != typeof t || isNaN(t) || t < 0 || t > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
                        return t !== n[e - 1]
                    })
                }, r.prototype._parseRootMargin = function(t) {
                    var e = (t || "0px").split(/\s+/).map(function(t) {
                        var e = /^(-?\d*\.?\d+)(px|%)$/.exec(t);
                        if (!e) throw new Error("rootMargin must be specified in pixels or percent");
                        return {
                            value: parseFloat(e[1]),
                            unit: e[2]
                        }
                    });
                    return e[1] = e[1] || e[0], e[2] = e[2] || e[0], e[3] = e[3] || e[1], e
                }, r.prototype._monitorIntersections = function() {
                    this._monitoringIntersections || (this._monitoringIntersections = !0, this.POLL_INTERVAL ? this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL) : (o(t, "resize", this._checkForIntersections, !0), o(e, "scroll", this._checkForIntersections, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in t && (this._domObserver = new MutationObserver(this._checkForIntersections), this._domObserver.observe(e, {
                        attributes: !0,
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    }))))
                }, r.prototype._unmonitorIntersections = function() {
                    this._monitoringIntersections && (this._monitoringIntersections = !1, clearInterval(this._monitoringInterval), this._monitoringInterval = null, a(t, "resize", this._checkForIntersections, !0), a(e, "scroll", this._checkForIntersections, !0), this._domObserver && (this._domObserver.disconnect(), this._domObserver = null))
                }, r.prototype._checkForIntersections = function() {
                    var e = this._rootIsInDom(),
                        n = e ? this._getRootRect() : {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0,
                            width: 0,
                            height: 0
                        };
                    this._observationTargets.forEach(function(r) {
                        var o = r.element,
                            a = c(o),
                            s = this._rootContainsTarget(o),
                            l = r.entry,
                            h = e && s && this._computeTargetAndRootIntersection(o, n),
                            u = r.entry = new i({
                                time: t.performance && performance.now && performance.now(),
                                target: o,
                                boundingClientRect: a,
                                rootBounds: n,
                                intersectionRect: h
                            });
                        l ? e && s ? this._hasCrossedThreshold(l, u) && this._queuedEntries.push(u) : l && l.isIntersecting && this._queuedEntries.push(u) : this._queuedEntries.push(u)
                    }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
                }, r.prototype._computeTargetAndRootIntersection = function(n, i) {
                    if ("none" != t.getComputedStyle(n).display) {
                        for (var r = c(n), o = h(n), a = !1; !a;) {
                            var l = null,
                                u = 1 == o.nodeType ? t.getComputedStyle(o) : {};
                            if ("none" == u.display) return;
                            if (o == this.root || o == e ? (a = !0, l = i) : o != e.body && o != e.documentElement && "visible" != u.overflow && (l = c(o)), l && !(r = s(l, r))) break;
                            o = h(o)
                        }
                        return r
                    }
                }, r.prototype._getRootRect = function() {
                    var t;
                    if (this.root) t = c(this.root);
                    else {
                        var n = e.documentElement,
                            i = e.body;
                        t = {
                            top: 0,
                            left: 0,
                            right: n.clientWidth || i.clientWidth,
                            width: n.clientWidth || i.clientWidth,
                            bottom: n.clientHeight || i.clientHeight,
                            height: n.clientHeight || i.clientHeight
                        }
                    }
                    return this._expandRectByRootMargin(t)
                }, r.prototype._expandRectByRootMargin = function(t) {
                    var e = this._rootMarginValues.map(function(e, n) {
                            return "px" == e.unit ? e.value : e.value * (n % 2 ? t.width : t.height) / 100
                        }),
                        n = {
                            top: t.top - e[0],
                            right: t.right + e[1],
                            bottom: t.bottom + e[2],
                            left: t.left - e[3]
                        };
                    return n.width = n.right - n.left, n.height = n.bottom - n.top, n
                }, r.prototype._hasCrossedThreshold = function(t, e) {
                    var n = t && t.isIntersecting ? t.intersectionRatio || 0 : -1,
                        i = e.isIntersecting ? e.intersectionRatio || 0 : -1;
                    if (n !== i)
                        for (var r = 0; r < this.thresholds.length; r++) {
                            var o = this.thresholds[r];
                            if (o == n || o == i || o < n != o < i) return !0
                        }
                }, r.prototype._rootIsInDom = function() {
                    return !this.root || l(e, this.root)
                }, r.prototype._rootContainsTarget = function(t) {
                    return l(this.root || e, t)
                }, r.prototype._registerInstance = function() {
                    n.indexOf(this) < 0 && n.push(this)
                }, r.prototype._unregisterInstance = function() {
                    var t = n.indexOf(this); - 1 != t && n.splice(t, 1)
                }, t.IntersectionObserver = r, t.IntersectionObserverEntry = i
            }

            function i(t) {
                this.time = t.time, this.target = t.target, this.rootBounds = t.rootBounds, this.boundingClientRect = t.boundingClientRect, this.intersectionRect = t.intersectionRect || {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    width: 0,
                    height: 0
                }, this.isIntersecting = !!t.intersectionRect;
                var e = this.boundingClientRect,
                    n = e.width * e.height,
                    i = this.intersectionRect,
                    r = i.width * i.height;
                this.intersectionRatio = n ? Number((r / n).toFixed(4)) : this.isIntersecting ? 1 : 0
            }

            function r(t, e) {
                var n = e || {};
                if ("function" != typeof t) throw new Error("callback must be a function");
                if (n.root && 1 != n.root.nodeType) throw new Error("root must be an Element");
                this._checkForIntersections = function(t, e) {
                    var n = null;
                    return function() {
                        n || (n = setTimeout(function() {
                            t(), n = null
                        }, e))
                    }
                }(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT), this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(n.rootMargin), this.thresholds = this._initThresholds(n.threshold), this.root = n.root || null, this.rootMargin = this._rootMarginValues.map(function(t) {
                    return t.value + t.unit
                }).join(" ")
            }

            function o(t, e, n, i) {
                "function" == typeof t.addEventListener ? t.addEventListener(e, n, i || !1) : "function" == typeof t.attachEvent && t.attachEvent("on" + e, n)
            }

            function a(t, e, n, i) {
                "function" == typeof t.removeEventListener ? t.removeEventListener(e, n, i || !1) : "function" == typeof t.detatchEvent && t.detatchEvent("on" + e, n)
            }

            function s(t, e) {
                var n = Math.max(t.top, e.top),
                    i = Math.min(t.bottom, e.bottom),
                    r = Math.max(t.left, e.left),
                    o = Math.min(t.right, e.right),
                    a = o - r,
                    s = i - n;
                return a >= 0 && s >= 0 && {
                    top: n,
                    bottom: i,
                    left: r,
                    right: o,
                    width: a,
                    height: s
                }
            }

            function c(t) {
                var e;
                try {
                    e = t.getBoundingClientRect()
                } catch (t) {}
                return e ? (e.width && e.height || (e = {
                    top: e.top,
                    right: e.right,
                    bottom: e.bottom,
                    left: e.left,
                    width: e.right - e.left,
                    height: e.bottom - e.top
                }), e) : {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    width: 0,
                    height: 0
                }
            }

            function l(t, e) {
                for (var n = e; n;) {
                    if (n == t) return !0;
                    n = h(n)
                }
                return !1
            }

            function h(t) {
                var e = t.parentNode;
                return e && 11 == e.nodeType && e.host ? e.host : e
            }
        }(window, document)
    }, , , function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
            return h
        });
        var i = n(29),
            r = (i.a.document || {}).documentElement,
            o = i.a,
            a = function(t, e) {
                var n = "x" === e ? "Width" : "Height",
                    i = "scroll" + n,
                    a = "client" + n,
                    s = document.body;
                return t === o || t === r || t === s ? Math.max(r[i], s[i]) - (o["inner" + n] || r[a] || s[a]) : t[i] - t["offset" + n]
            },
            s = function(t, e) {
                var n = "scroll" + ("x" === e ? "Left" : "Top");
                return t === o && (null != t.pageXOffset ? n = "page" + e.toUpperCase() + "Offset" : t = null != r[n] ? r : document.body),
                    function() {
                        return t[n]
                    }
            },
            c = function(t, e) {
                var n = function(t) {
                        return "string" == typeof t && (t = TweenLite.selector(t)), t.length && t !== o && t[0] && t[0].style && !t.nodeType && (t = t[0]), t === o || t.nodeType && t.style ? t : null
                    }(t).getBoundingClientRect(),
                    i = document.body,
                    a = !e || e === o || e === i,
                    c = a ? {
                        top: r.clientTop - (window.pageYOffset || r.scrollTop || i.scrollTop || 0),
                        left: r.clientLeft - (window.pageXOffset || r.scrollLeft || i.scrollLeft || 0)
                    } : e.getBoundingClientRect(),
                    l = {
                        x: n.left - c.left,
                        y: n.top - c.top
                    };
                return !a && e && (l.x += s(e, "x")(), l.y += s(e, "y")()), l
            },
            l = function(t, e, n, i) {
                var r = typeof t;
                return isNaN(t) ? "string" === r && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + i : "max" === t ? a(e, n) : Math.min(a(e, n), c(t, e)[n]) : parseFloat(t)
            },
            h = i.a._gsDefine.plugin({
                propName: "scrollTo",
                API: 2,
                global: !0,
                version: "1.9.2",
                init: function(t, e, n) {
                    return this._wdw = t === o, this._target = t, this._tween = n, "object" != typeof e ? "string" == typeof(e = {
                        y: e
                    }).y && "max" !== e.y && "=" !== e.y.charAt(1) && (e.x = e.y) : e.nodeType && (e = {
                        y: e,
                        x: e
                    }), this.vars = e, this._autoKill = !1 !== e.autoKill, this.getX = s(t, "x"), this.getY = s(t, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != e.x ? (this._addTween(this, "x", this.x, l(e.x, t, "x", this.x) - (e.offsetX || 0), "scrollTo_x", !0), this._overwriteProps.push("scrollTo_x")) : this.skipX = !0, null != e.y ? (this._addTween(this, "y", this.y, l(e.y, t, "y", this.y) - (e.offsetY || 0), "scrollTo_y", !0), this._overwriteProps.push("scrollTo_y")) : this.skipY = !0, !0
                },
                set: function(t) {
                    this._super.setRatio.call(this, t);
                    var e = this._wdw || !this.skipX ? this.getX() : this.xPrev,
                        n = this._wdw || !this.skipY ? this.getY() : this.yPrev,
                        i = n - this.yPrev,
                        r = e - this.xPrev,
                        s = h.autoKillThreshold;
                    this.x < 0 && (this.x = 0), this.y < 0 && (this.y = 0), this._autoKill && (!this.skipX && (r > s || r < -s) && e < a(this._target, "x") && (this.skipX = !0), !this.skipY && (i > s || i < -s) && n < a(this._target, "y") && (this.skipY = !0), this.skipX && this.skipY && (this._tween.kill(), this.vars.onAutoKill && this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []))), this._wdw ? o.scrollTo(this.skipX ? e : this.x, this.skipY ? n : this.y) : (this.skipY || (this._target.scrollTop = this.y), this.skipX || (this._target.scrollLeft = this.x)), this.xPrev = this.x, this.yPrev = this.y
                }
            }),
            u = h.prototype;
        /*!
         * VERSION: 1.9.2
         * DATE: 2019-02-07
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         * 
         * @author: Jack Doyle, jack@greensock.com
         **/
        h.max = a, h.getOffset = c, h.buildGetter = s, h.autoKillThreshold = 7, u._kill = function(t) {
            return t.scrollTo_x && (this.skipX = !0), t.scrollTo_y && (this.skipY = !0), this._super._kill.call(this, t)
        }
    }]
]);